<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AmiroKDの小屋</title>
  
  
  <link href="https://amirokd.dpdns.org/atom.xml" rel="self"/>
  
  <link href="https://amirokd.dpdns.org/"/>
  <updated>2025-07-22T07:28:14.430Z</updated>
  <id>https://amirokd.dpdns.org/</id>
  
  <author>
    <name>AmiroKD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rerank——RAG中百尺竿头更进一步的神器，从原理到解决方案</title>
    <link href="https://amirokd.dpdns.org/posts/3bd00f39.html"/>
    <id>https://amirokd.dpdns.org/posts/3bd00f39.html</id>
    <published>2025-07-22T07:27:36.000Z</published>
    <updated>2025-07-22T07:28:14.430Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容：  </p></blockquote><ul><li>为什么一般情况下RAG的检索相关性存在问题？</li><li>Rerank为什么可以解决这个问题？</li><li>几种常用Rerank组合评测；</li><li>如何在自己的产品中使用Rerank？</li></ul><p>检索增强生成（RAG）是解决大语言模型（LLM）实际使用中的一套完整的技术，它可以有效解决LLM的三个主要问题：<strong>数据时效性</strong>、<strong>幻觉</strong>和<strong>数据安全问题</strong>（在我之前的文章《大模型主流应用RAG的介绍——从架构到技术细节》中有详细介绍）。但是随着RAG越来越火热，使用者越来越多，我们也会发现用的好的人/团队其实还是不多的。这也是RAG常被人吐槽的一点：<strong>入门简单，用好却非常难！</strong></p><p>对于RAG的效果，我们之前已经做了很多方面的优化了，包括：</p><ul><li><strong>优化内容提取的方法</strong>：从源头解决内容提取的有效性，包括文本内容、表格内容（保留制表符）和图片内容（OCR识别）等，可以参看我之前的文章<a href="https://www.luxiangdong.com/2023/10/05/extract/">《完全指南——使用python提取PDF中的文本信息（包括表格和图片OCR）》</a>；</li><li><strong>优化chunking</strong>：从最开始的512固定长度切分，到后面的句切分，再到后面的NLTK和SpaCy，具体可参见我之前写的<a href="https://www.luxiangdong.com/2023/09/20/chunk/">《最详细的文本分块(Chunking)方法——可以直接影响基于LLM应用效果》</a>；</li><li><strong>再之后是优化embedding模型</strong>：Embedding模型的选择其实很魔性，我们在优化过程中也会不断否定之前的一些判断。比如我们最开始用m3e，后面用bge，再后面还用了通义千问的embedding模型。总体来说，收费的通义千问还是好一些，但是不明显，有些方面却不如bge。最近一朋友也向我推荐了Jina embedding模型，不过他们的中文模型需要12月份才出来；</li><li><strong>我们还优化了其他一些过程</strong>：比如prompt模板、关键词摘要、元数据存储等。</li></ul><p>这些优化确实给我们带来了非常好的效果，但不够！我们在一些客户的实践过程中，还是发现相关性效果不佳，甚至造成了其中一个客户选择了其他方案（使用RAG+GPT-4的方案）。</p><p>我们还是坚持用国产大模型（如Baichuan2-13B、ChatGLM3-6B和QWen-14B等），毕竟主要服务的还是国内客户，加上现在接触的多数客户其实都有私有化部署的需求。所以我们进行了一段时间的探索，发现我们还有一项很有效的优化没有去做——ReRank。</p><p>所以，虽然Rerank优化我们还在做，但是今天我们可以先聊聊ReRank这个话题。</p><h2 id="为什么需要Rerank"><a href="#为什么需要Rerank" class="headerlink" title="为什么需要Rerank"></a>为什么需要Rerank</h2><p>我们发现，在10月中旬之前，国内外的互联网上很难发现Rerank相关的话题。有少量人提到了，但是基本上都没有提到解决方案。我和小明在讨论Rerank的时候其实是先从提问题开始的。</p><h3 id="Elasticsearch中的相似度检索算法"><a href="#Elasticsearch中的相似度检索算法" class="headerlink" title="Elasticsearch中的相似度检索算法"></a><strong>Elasticsearch中的相似度检索算法</strong></h3><p>前面说了，我们自己的RAG产品之前是存在一些相关性问题的，其他方面能优化的我们觉得也基本上优化的差不多了，除了我们采用的国产大模型在通用能力上和ChatGPT-3.5/4是存在差距的。我们发现的最大的问题就是使用elasticsearch的<strong>retrieval</strong>召回的内容相关度有问题，多数情况下score最高的chunk相关度没问题，但是top2-5的相关度就很随机了，这是最影响最终结果的。</p><p><img src="https://pic4.zhimg.com/v2-b99e2b5ffdcbacbd1d49297723f61ccb_1440w.jpg" alt=""></p><p>图1：elasticsearch8.4的knn使用方式</p><p>我们看了elasticsearch的相似度算法，es用的是KNN算法（开始我们以为是暴力搜索），但仔细看了一下，在es8的相似度检索中，用的其实是基于HNSW（分层的最小世界导航算法），HNSW是有能力在几毫秒内从数百万个数据点中找到最近邻的。</p><p><img src="https://pic4.zhimg.com/v2-0017703c3263ec5230bbe684309c4995_1440w.jpg" alt=""></p><p>图2：elasticsearch实际使用的是HNSW算法</p><h3 id="HNSW带来的随机性问题"><a href="#HNSW带来的随机性问题" class="headerlink" title="HNSW带来的随机性问题"></a><strong>HNSW带来的随机性问题</strong></h3><p>我们想象这么一个场景：你昨天刚在其他地方看到过一本新书，你想在图书馆找到类似的书。K-最近邻（KNN）算法的逻辑是浏览书架上的每一本书，并将它们从最相似到最不相似的顺序排列，以确定最相似的书（最有可能是你昨天看过的那本）。这也就是我们常说的暴力搜索，你有耐心做这么麻烦的工作吗？相反，如果我们对图书馆中的图书进行预排序和索引，要找到与你昨天看过的新书相似的书，你所需要做的就是去正确的楼层，正确的区域，正确的通道找到相似的书。</p><p>此外，<strong>你通常不需要对前10本相似的书进行精确排名，比如100%、99%或95%的匹配度</strong>，而是通通先拿回来。这就是<strong>近似近邻（ANN）</strong>的思想。你应该注意到了，这里已经出现了一些随机性——不做匹配分数的排名。但是这些准确度上的损失是为了让检索效率更快，<strong>为了显著降低计算成本，它牺牲了找到绝对最近邻的保证，这算是在计算效率和准确性之间取得平衡</strong>。</p><p>ANN算法目前主要有三种：</p><ul><li><strong>基于图的算法创建数据的图</strong>表示，最主要的就是**分层可导航小世界图算法(HNSW)**。</li><li><strong>基于哈希的算法</strong>：流行的算法包括:位置敏感哈希（LSH）、多索引哈希（MIH）；</li><li><strong>基于树的算法</strong>：流行的是kd树、球树和随机投影树（RP树）。对于低维空间（≤10），基于树的算法是非常有效的。</li></ul><p>HNSW借鉴了跳表（Skip List）的思路。跳表是一种数据结构，用于维护一组已排序的元素，并允许进行高效的搜索、插入和删除操作。它是由William Pugh在1989年发明的。图(3)显示了数字[3、6、7、9、12、17、19、21、25、26]的排序链表。假设我们想找到目标19。当值小于目标时，我们向右移动，如果是传统的方式，需要6步才能找到它。</p><p><img src="https://pic4.zhimg.com/v2-14499dcd804e8311f52479bf9f181fe1_1440w.jpg" alt=""></p><p>图3：链表中查找数据</p><p>但是我们在每个节点增加向后的指向指针，比如列表中每三个其他节点都有一个指向后面三个节点的指针，如图(4)所示，那么只需要3步就可以到达19</p><p><img src="https://pic4.zhimg.com/v2-806796c3cbeaad78012a046d2aba0359_1440w.jpg" alt=""></p><p>图4：跳表每三个节点就设置一个多指向指针节点，可以让搜索速度明显加快，如果我们再增加这个指针节点数量呢？</p><p>这就是small world的底层思路，说回到小世界（small world）网络，它是一种特殊的网络，在这种网络中，你可以快速地联系到网络中的其他人或点。这有点像“凯文·培根的六度”(Six Degrees of Kevin Bacon)游戏，在这个游戏中，你可以通过一系列其他演员，在不到六个步骤的时间里，将任何演员与凯文·培根联系起来。想象一下，你有一群朋友排成一个圆圈，如图5所示。每个朋友都与坐在他们旁边的人直接相连。我们称它为“原始圆”。</p><p>现在，这就是奇迹发生的地方。你可以随机选择将其中一些连接改变给圆圈中的其他人，就像图5中的红色连接线一样。这就像这些连接的“抢椅子”游戏。有人跳到另一把椅子上的几率用概率p表示。如果p很小，移动的人就不多，网络看起来就很像原来的圆圈。但如果p很大，很多人就会跳来跳去，网络就会变得有点混乱。当您选择正确的p值(不太小也不太大)时，红色连接是最优的。网络变成了一个小世界网络。你可以很快地从一个朋友转到另一个朋友(这就是“小世界”的特点)。</p><p><img src="https://pic2.zhimg.com/v2-9ed00d3738d35131a35e84419f517f47_1440w.jpg" alt=""></p><p>图5：small world网络结构</p><p>现在我们要扩展到高维空间，图中的每个节点都是一个高维向量。在高维空间中，搜索速度会变慢。这是不可避免的“维度的诅咒”。HNSW是一种高级数据结构，用于优化高维空间中的相似性搜索。让我们看看HNSW如何构建图的层次结构。HNSW从图(6)中的第0层这样的基础图开始。它通常使用<strong>随机初始化数据点</strong>来构建。</p><p><img src="https://picx.zhimg.com/v2-33efb63cb78392eb99ee93357737bdf7_1440w.jpg" alt=""></p><p>图6：HNSW的结构示例</p><p>这里大家要注意再次出现了”<strong>随机</strong>“，所以，为了检索的快速，HNSW算法会存在一些随机性，反映在实际召回结果中，最大的影响就是返回结果中top_K并不是我们最想要的，至少这K个文件的排名并不是我们认为的从高分到低分排序的。</p><h3 id="Rerank可以在小范围内逐一计算分值"><a href="#Rerank可以在小范围内逐一计算分值" class="headerlink" title="Rerank可以在小范围内逐一计算分值"></a><strong>Rerank可以在小范围内逐一计算分值</strong></h3><p><strong>因为在搜索的时候存在随机性，这应该就是我们在RAG中第一次召回的结果往往不太满意的原因</strong>。但是这也没办法，如果你的索引有数百万甚至千万的级别，那你只能牺牲一些精确度，换回时间。这时候我们可以做的就是增加<code>top_k</code>的大小，比如从原来的10个，增加到30个。然后再使用更精确的算法来做rerank，使用一一计算打分的方式，做好排序。比如30次的遍历相似度计算的时间，我们还是可以接受的。</p><p><em>关于HNSW的内容，大家可以查看<a href="https://www.luxiangdong.com/2023/11/06/hnsw/">像光速一样搜索——HNSW算法介绍</a>。</em></p><h2 id="主要的Reank方式评测"><a href="#主要的Reank方式评测" class="headerlink" title="主要的Reank方式评测"></a>主要的Reank方式评测</h2><h3 id="评测方法"><a href="#评测方法" class="headerlink" title="评测方法"></a><strong>评测方法</strong></h3><p>为了衡量我们的检索系统的有效性，我们主要依赖于两个被广泛接受的指标:<strong>命中率</strong>和**平均倒数排名(MRR)**。让我们深入研究这些指标，了解它们的重要性以及它们是如何运作的。我们来解释一下这两个指标：</p><ul><li>**命中率:**Hit rate计算在前k个检索文档中找到正确答案的查询比例。简单来说，它是关于我们的系统在前几次猜测中正确的频率。</li><li>**平均倒数排名(MRR):**对于每个查询，MRR通过查看排名最高的相关文档的排名来评估系统的准确性。具体来说，它是所有查询中这些秩的倒数的平均值。因此，如果第一个相关文档是顶部结果，则倒数排名为1;如果是第二个，倒数是1/2，以此类推。</li></ul><h3 id="评测结果"><a href="#评测结果" class="headerlink" title="评测结果"></a><strong>评测结果</strong></h3><p>具体的评测过程大家可以看<a href="https://www.luxiangdong.com/2023/11/06/rerank-ev">提升RAG——选择最佳Embedding和重新排名模型</a>，也是llamaindex最近刚刚发布的一篇著名rerank评测文章，我这里就不具体展开了，直接用他们的结果。评测采用的是<strong>embedding模型</strong> + <strong>rerank模型</strong>的方式进行的。</p><p>以下是使用的模型:</p><p><strong>Embedding模型</strong>:</p><ul><li><a href="https://platform.openai.com/docs/guides/embeddings">OpenAI Embedding</a></li><li><a href="https://www.voyageai.com/">Voyage Embedding</a></li><li><a href="https://txt.cohere.com/introducing-embed-v3/">CohereAI Embedding</a> (v2.0/ v3.0)</li><li><a href="https://huggingface.co/jinaai/jina-embeddings-v2-small-en">Jina Embeddings</a></li><li><a href="https://huggingface.co/BAAI/bge-large-en">BAAI/bge-large-en</a></li></ul><p><strong>Rerank模型</strong>:</p><ul><li><a href="https://txt.cohere.com/rerank/">CohereAI</a></li><li><a href="https://huggingface.co/BAAI/bge-reranker-base">bge-reranker-base</a></li><li><a href="https://huggingface.co/BAAI/bge-reranker-large">bge-reranker-large</a></li></ul><blockquote><p>值得一提的是，这些结果为这个特定数据集和任务的性能提供了坚实的见解。但是，实际结果可能会根据数据特征、数据集大小和其他变量(如chunk_size、similarity_top_k等)而有所不同。</p></blockquote><p>下表展示了基于<strong>命中率</strong>和<strong>MRR</strong>指标的评估结果:</p><p><img src="https://pic4.zhimg.com/v2-b55576a528c8797f6202a2f2b35ea9ed_1440w.jpg" alt=""></p><p>图7：测试结果</p><p>我对LlamaIndex的评测结果做一个简单总结：</p><ul><li><strong>目前rerank模型里面，最好的应该是cohere，不过它是收费的。开源的是智源发布的bge-reranker-base和bge-reranker-large。bge-reranker-large的能力基本上接近cohere，而且在一些方面还更好；</strong></li><li><strong>几乎所有的Embeddings都在重排之后显示出更高的命中率和MRR，所以rerank的效果是非常显著的；</strong></li><li><strong>embedding模型和rerank模型的组合也会有影响，可能需要开发者在实际过程中去调测最佳组合。</strong></li></ul><h2 id="我们可以如何使用Rerank"><a href="#我们可以如何使用Rerank" class="headerlink" title="我们可以如何使用Rerank"></a>我们可以如何使用Rerank</h2><p>目前最无脑的方式就是使用bge-reranker-large，我们可以在<a href="https://huggingface.co/BAAI/bge-reranker-large/tree/main%E4%B8%8A%E6%89%BE%E5%88%B0models%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E3%80%82%E6%88%91%E5%B7%B2%E7%BB%8F%E4%B8%8B%E8%BD%BD%E4%BA%86%EF%BC%9A">https://huggingface.co/BAAI/bge-reranker-large/tree/main上找到models文件，下载安装。我已经下载了：</a></p><p><img src="https://pic1.zhimg.com/v2-fe66d938455a56ed6277164cc29228de_1440w.jpg" alt=""></p><p>图8：bge-reranker-large的models文件，大约4.5GB</p><p>这两天要给它安装起来，测测我们的产品rerank之后的效果。</p><p>其实还有一种比较简单的方式，这种方式其实是从上面的原理中得出来的：</p><ul><li>第一次召回不精确，是因为要对抗时间过长，所以使用了ANN等方法；</li><li>那么，我们是否可以在已经得到top_k的情况下，使用KNN这种暴力检索（逐个计算相似度，打分）来做一个精准排序，然后取top_n。假设这里k=30，n=5.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要内容：  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为什么一般情况下RAG的检索相关性存在问题？&lt;/li&gt;
&lt;li&gt;Rerank为什么可以解决这个问题？&lt;/li&gt;
&lt;li&gt;几种常用Rerank组合评测；&lt;/li&gt;
&lt;li&gt;如何</summary>
      
    
    
    
    
    <category term="开发" scheme="https://amirokd.dpdns.org/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>为AI而生的数据库：Milvus详解及实战</title>
    <link href="https://amirokd.dpdns.org/posts/8ef6a909.html"/>
    <id>https://amirokd.dpdns.org/posts/8ef6a909.html</id>
    <published>2025-07-18T01:40:14.000Z</published>
    <updated>2025-07-18T01:42:12.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-向量数据库"><a href="#1-向量数据库" class="headerlink" title="1 向量数据库"></a>1 向量数据库</h2><h3 id="1-1-向量数据库的由来"><a href="#1-1-向量数据库的由来" class="headerlink" title="1.1 向量数据库的由来"></a>1.1 向量数据库的由来</h3><p>在当今数字化时代，<a href="https://so.csdn.net/so/search?q=%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD&amp;spm=1001.2101.3001.7020">人工智能</a>AI正迅速改变着我们的生活和工作方式。从智能助手到自动驾驶汽车，AI正在成为各行各业的创新引擎。然而，这种AI的崛起也带来了一个关键的挑战：如何有效地处理和分析越来越丰富和复杂的数据。在这个背景下，向量数据库技术应运而生，为AI提供了强大的加速引擎。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/801fbc6ebacfac0225da5fcbf01631bd.jpeg" alt=""></p><blockquote><p>AI时代的数据挑战：随着AI应用范围的扩大，大量的数据涌入各个行业。图像、文本、音频等多种数据形式都成为了AI的输入。这些数据的特点是多模态、高维、复杂和关联性强。传统的关系型数据库虽然在一些场景中仍然有用，但在处理这种多模态、高维数据时显得力不从心。因此，需要一种更适合AI应用需求的数据库技术，这就是向量数据库。</p><p>AI的加速引擎：向量数据库是一种专门为存储和检索向量数据而设计的数据库。它的核心思想是将数据映射到向量空间中，从而使得数据的相似性计算、聚类、分类和检索变得更加高效和精确。</p></blockquote><p>向量数据库是专门用来存储和查询向量的数据库，其存储的向量来自于对文本、语音、图像、视频等的向量化。同传统数据库相比，向量数据库不仅能够完成基本的CRUD（添加、读取查询、更新、删除）等操作，还能够对向量数据进行更快速的相似性搜索</p><h3 id="1-2-向量数据库对大模型的赋能"><a href="#1-2-向量数据库对大模型的赋能" class="headerlink" title="1.2 向量数据库对大模型的赋能"></a>1.2 向量数据库对大模型的赋能</h3><p>向量数据库拓展了大模型的边界，这种拓张包含两个方面，时间边界和空间边界：</p><blockquote><p>时间边界的扩展：向量数据库能够使得大模型LLM拥有“长期记忆”。</p></blockquote><p>目前的大模型（无论是NLP领域的GPT系列还是CV领域的ResNET系列）都是预先训练Pretrain的大模型，有着非常明晰的训练截止日Cut-off Date，这导致这些模型对于训练截止日之后发生的事情一无所知。而随着向量数据库的引入，其内部存储的最新的信息向量能够极大地拓展大模型的应用边界，向量数据库可以使得大模型保持准实时性，提高大模型的适用性，并使得大模型能够动态调整。因此向量数据库使得大模型具有了长期记忆。</p><p>假设一个预训练的新闻摘要模型在2021年底完成了训练，到了2023年，许多新闻事件和趋势已经发生了变化。为了使大模型能够处理这些新信息，可以使用向量数据库来存储和查询2023年的新闻文章向量。</p><p>在推荐系统中，预训练的大模型可能无法识别新用户和新产品的特征，通过向量数据库，可以实时更新用户和产品的特征向量，从而使大模型能够根据最新的信息为用户提供更精准的推荐。</p><p>此外，向量数据库还可以支持实时监测和分析。例如，在金融领域，预训练的股票预测模型可能无法获取训练截止日期之后的股票价格信息。通过将最新的股票价格向量存储在向量数据库中，大模型可以实时分析和预测未来股票价格走势。还有就是在客服领域，向量数据库将使得大模型可以追溯到对话的开始。</p><blockquote><p>空间边界的扩展：向量数据库能够协助解决目前企业界最担忧的大模型泄露隐私的问题。</p></blockquote><p>用户给出的Prompt可能会包含一些敏感信息。根据媒体报道，员工A用ChatGPT帮自己查一段代码的bug，而这段源代码与半导体设备测量数据有关；员工B想用ChatGPT帮自己优化一段代码，就直接将与产量和良品率记录设备相关的一段代码输入了其中。</p><p>这些行为直接导致了三星关键数据的泄露，而ChatGPT本身其实也出现过隐私泄露事件，使得有一小部分的对话历史/支付数据会被其他用户查看，这些数据都极为敏感，而通过本地部署，向量数据库能够在很大程度上解决这个问题。</p><p>向量数据库本地部署后可以存储企业有关的大量隐私数据，在本地部署或者专有云部署大模型后，通过特别的Agent大模型可以在有保护的情况下访问向量数据库的隐私数据，进而可以在不向外网暴露公司的隐私的情况下，使得公司的业务得到大模型的助力。</p><h3 id="1-3-向量数据库实现多模态搜索"><a href="#1-3-向量数据库实现多模态搜索" class="headerlink" title="1.3 向量数据库实现多模态搜索"></a>1.3 向量数据库实现多模态搜索</h3><p>向量数据库自带多模态功能，这意味着它能够通过机器学习方法处理和理解来自不同源的多种模态信息，如文本、图像、音频和视频等，数据向量化过程使得这些不同模态数据的内部隐藏信息得以暴露，进而为多模态应用提供支持。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1aef47ca0b2c455cbacc08ecb8cc3eba.webp?x-image-process=image/format,png" alt=""></p><p> 一个典型的应用场景是多语言搜索，向量数据库支持跨语言的信息检索，用户可以使用英语、法语、中文等多种语言搜索图书库，而无需事先对书名进行多语言翻译处理。这得益于向量表示能够捕捉到语义相似性，使得来自不同语言的查询和内容能够相互匹配。</p><h3 id="1-4-向量数据排名"><a href="#1-4-向量数据排名" class="headerlink" title="1.4 向量数据排名"></a>1.4 向量数据排名</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/31c1e9794de15462c32a14aab28a706b.jpeg" alt=""></p><h2 id="2-Milvus数据库介绍"><a href="#2-Milvus数据库介绍" class="headerlink" title="2 Milvus数据库介绍"></a>2 Milvus数据库介绍</h2><h3 id="2-1-Milvus概述"><a href="#2-1-Milvus概述" class="headerlink" title="2.1 Milvus概述"></a><strong>2.1 Milvus概述</strong></h3><p>Milvus 是一款云原生向量数据库，它具备高可用、高性能、易拓展的特点，用于海量向量数据的实时召回。</p><p>Milvus官网地址：<a href="https://milvus.io/" title="Milvus">Milvus</a></p><p>Milvus 基于FAISS、Annoy、HNSW 等向量搜索库构建，核心是解决稠密向量相似度检索的问题。在向量检索库的基础上，Milvus 支持数据分区分片、数据持久化、增量数据摄取、标量向量混合查询、time travel 等功能，同时大幅优化了向量检索的性能，可满足任何向量检索场景的应用需求。通常，建议用户使用 Kubernetes 部署 Milvus，以获得最佳可用性和弹性。</p><p>Milvus 采用共享存储架构，​存储计算完全分离​，计算节点支持横向扩展。从架构上来看，Milvus 遵循数据流和控制流分离，整体分为了四个层次，分别为接入层（access layer）、协调服务（coordinator service）、执行节点（worker node）和存储层（storage）。各个层次相互独立，独立扩展和容灾。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9c2dd5465ccd7593013f936b7c2f24ef.jpeg" alt=""></p><p>Milvus 向量数据库能够帮助用户轻松应对海量非结构化数据（图片/视频/语音/文本）检索。单节点 Milvus 可以在秒内完成十亿级的向量搜索，分布式架构亦能满足用户的水平扩展需求。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/25f3805d24834144f92340bd5aebfa04.webp?x-image-process=image/format,png" alt=""></p><p>milvus特点总结如下：</p><ul><li>高性能：性能高超，可对海量数据集进行向量相似度检索。</li><li>高可用、高可靠：Milvus 支持在云上扩展，其容灾能力能够保证服务高可用。</li><li>混合查询：Milvus 支持在向量相似度检索过程中进行标量字段过滤，实现混合查询。</li><li>开发者友好：支持多语言、多工具的 Milvus 生态系统。</li></ul><h3 id="2-2-Milvus关键概念"><a href="#2-2-Milvus关键概念" class="headerlink" title="2.2 Milvus关键概念"></a>2.2 Milvus关键概念</h3><p><strong>非结构化数据：</strong>非结构化数据指的是数据结构不规则，没有统一的预定义数据模型，不方便用数据库二维逻辑表来表现的数据。非结构化数据包括图片、视频、音频、自然语言等，占所有数据总量的 80%。非结构化数据的处理可以通过各种人工智能（AI）或机器学习（ML）模型转化为向量数据后进行处理。</p><p><strong>特征向量：</strong>向量又称为embedding vector，是指由 embedding 技术从离散变量（如图片、视频、音频、自然语言等各种非结构化数据）转变而来的连续向量。在数学表示上，向量是一个由浮点数或者二值型数据组成的 n 维数组。</p><p>通过现代的向量转化技术，比如各种人工智能（AI）或者机器学习（ML）模型，可以将非结构化数据抽象为 n 维特征向量空间的向量。这样就可以采用最近邻算法（ANN）计算非结构化数据之间的相似度。</p><p><strong>向量相似度检索：</strong>相似度检索是指将目标对象与数据库中数据进行比对，并召回最相似的结果。同理，向量相似度检索返回的是最相似的向量数据。近似最近邻搜索（ANN）算法能够计算向量之间的距离，从而提升向量相似度检索的速度。如果两条向量十分相似，这就意味着他们所代表的源数据也十分相似。</p><p><strong>Collection-集合：</strong>包含一组entity，可以等价于关系型数据库系统（RDBMS）中的表。</p><p><strong>Entity-实体：</strong>包含一组 field。field 与实际对象相对应。field 可以是代表对象属性的结构化数据，也可以是代表对象特征的向量。primary key 是用于指代一个 entity 的唯一值。<strong>注意：</strong>你可以自定义primary key，否则 Milvus 将会自动生成primary key。目前Milvus 不支持primary key去重，因此有可能在一个collection内出现primary key相同的entity。</p><p><strong>Field-字段：</strong>Entity 的组成部分。Field可以是结构化数据，例如数字和字符串，也可以是向量。<strong>注意：</strong>Milvus2.0现已支持标量字段过滤。并且，Milvus 2.0在一个集合中只支持一个主键字段。</p><p>Milvus与关系型数据库的对应关系如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b205683ca073db313f1440fdad22495f.png" alt=""></p><p><strong>Partition-分区：</strong>分区是集合（Collection）的一个分区。Milvus 支持将收集数据划分为物理存储上的多个部分。这个过程称为分区，每个分区可以包含多个段。</p><p><strong>Segment-段：</strong>Milvus 在数据插入时，通过合并数据自动创建的数据文件。一个collection可以包含多个segment。一个segment可以包含多个entity。在搜索中，Milvus会搜索每个segment，并返回合并后的结果。</p><p><strong>Sharding-分片：</strong>Shard是指将数据写入操作分散到不同节点上，使 Milvus 能充分利用集群的并行计算能力进行写入。默认情况下，单个Collection包含 2 个分片（Shard）。目前 Milvus 采用基于<strong>主键哈希</strong>的分片方式，未来将支持随机分片、自定义分片等更加灵活的分片方式。<strong>注意：</strong> 分区的意义在于通过划定分区减少数据读取，而分片的意义在于多台机器上并行写入操作。</p><p><strong>索引：</strong>索引基于原始数据构建，可以提高对 collection 数据搜索的速度。Milvus 支持多种索引类型。为提高查询性能，你可以为每个向量字段指定一种索引类型。目前，一个向量字段仅支持一种索引类型。切换索引类型时，Milvus 自动删除之前的索引。<strong>相似性搜索引擎的工作原理</strong>是将输入的对象与数据库中的对象进行比较，找出与输入最相似的对象。索引是有效组织数据的过程，极大地加速了对大型数据集的查询，在相似性搜索的实现中起着重要作用。对一个大规模向量数据集创建索引后，查询可以被路由到最有可能包含与输入查询相似的向量的集群或数据子集。在实践中，这意味着要牺牲一定程度的准确性来加快对真正的大规模向量数据集的查询。</p><p><strong>PChannel：</strong>PChannel 表示物理通道。每个 PChannel 对应一个日志存储主题。默认情况下，将分配一组 256 个 PChannels 来存储记录 Milvus 集群启动时数据插入、删除和更新的日志。</p><p><strong>VChannel：</strong>VChannel 表示逻辑通道（虚拟通道）。每个集合将分配一组 VChannels，用于记录数据的插入、删除和更新。VChannels 在逻辑上是分开的，但在物理上共享资源。</p><p><strong>Binlog：</strong>binlog 是一个二进制日志，或者是一个更小的段单位，记录和处理 Milvus 向量数据库中数据的更新和更改。 一个段的数据保存在多个二进制日志中。 Milvus 中的 binlog 分为三种：InsertBinlog、DeleteBinlog 和 DDLBinlog。</p><p><strong>日志代理（Log broker）：</strong>日志代理是一个支持回放的发布订阅系统。它负责流数据持久化、可靠异步查询的执行、事件通知和查询结果的返回。当工作节点从系统崩溃中恢复时，它还确保增量数据的完整性。</p><p><strong>日志订阅者：</strong>日志订阅方通过订阅日志序列来更新本地数据，并以只读副本的形式提供服务。</p><p><strong>日志序列（Log sequence）：</strong>日志序列记录了在 Milvus 中更改集合状态的所有操作。</p><p><strong>正则化：</strong>正则化是指转换嵌入（向量）以使其范数等于1的过程。 如果使用内积 (IP) 来计算embeddings相似度，则必须对所有embeddings进行正则化。 正则化后，内积等于余弦相似度。</p><h3 id="2-2-Milvus架构"><a href="#2-2-Milvus架构" class="headerlink" title="2.2 Milvus架构"></a>2.2 Milvus架构</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/77810c9769fd116479b6f3aba508a7f3.jpeg" alt=""></p><p> Milvus文档地址：<a href="https://milvus.io/docs" title="Milvus doc">Milvus doc</a></p><p>整个系统分为四个层次：</p><ul><li>接入层（Access Layer）：系统的门面，由一组无状态 proxy 组成。对外提供用户连接的 endpoint，负责验证客户端请求并合并返回结果。</li><li>协调服务（Coordinator Service）：系统的大脑，负责分配任务给执行节点。协调服务共有四种角色，分别为 root coord、data coord、query coord 和 index coord。</li><li>执行节点（Worker Node）：系统的四肢，负责完成协调服务下发的指令和 proxy 发起的数据操作语言（DML）命令。执行节点分为三种角色，分别为 data node、query node 和 index node。</li><li>存储服务 （Storage）： 系统的骨骼，负责 Milvus 数据的持久化，分为元数据存储（meta store）、消息存储（log broker）和对象存储（object storage）三个部分。</li></ul><p>各个层次相互独立，独立扩展和容灾。</p><h4 id="2-2-1-接入层"><a href="#2-2-1-接入层" class="headerlink" title="2.2.1 接入层"></a><strong>2.2.1 接入层</strong></h4><p>接入层由一组无状态 proxy 组成，是整个系统的门面，对外提供用户连接的 endpoint。接入层负责验证客户端请求并减少返回结果。</p><ul><li>Proxy 本身是无状态的，一般通过负载均衡组件（Nginx、Kubernetes Ingress、NodePort、LVS）对外提供统一的访问地址并提供服务。</li><li>由于 Milvus 采用大规模并行处理（MPP）架构，proxy 会先对执行节点返回的中间结果进行全局聚合和后处理后，再返回至客户端。</li></ul><h4 id="2-2-2-协调服务"><a href="#2-2-2-协调服务" class="headerlink" title="2.2.2 协调服务"></a><strong>2.2.2 协调服务</strong></h4><p>协调服务是系统的大脑，负责向执行节点分配任务。它承担的任务包括集群拓扑节点管理、负载均衡、时间戳生成、数据声明和数据管理等。</p><p>协调服务共有四种角色：</p><ul><li><strong>Root coordinator（root coord）</strong>：负责处理数据定义语言（DDL）和数据控制语言（DCL）请求。比如，创建或删除 collection、partition、index 等，同时负责维护中心授时服务 TSO 和时间窗口的推进。</li><li><strong>Query coordinator (query coord）</strong>：负责管理 query node 的拓扑结构和负载均衡以及从 growing segment 移交切换到 sealed segment。Query node 中的 segment 只存在两种状态：growing 和 sealed，分别对应增量数据和历史数据。</li><li><strong>Data coordinator (data coord）</strong>：负责管理 data node 的拓扑结构，维护数据的元信息以及触发 flush、compact 等后台数据操作。</li><li><strong>Index coordinator (index coord）</strong>：负责管理 index node 的拓扑结构，构建索引和维护索引元信息。</li></ul><h4 id="2-2-3-执行节点"><a href="#2-2-3-执行节点" class="headerlink" title="2.2.3 执行节点"></a><strong>2.2.3 执行节点</strong></h4><p>执行节点是系统的四肢，负责完成协调服务下发的指令和 proxy 发起的数据操作语言（DML）命令。由于采取了存储计算分离，执行节点是无状态的，可以配合 Kubernetes 快速实现扩缩容和故障恢复。</p><p>执行节点分为三种角色：</p><ul><li><strong>Query node：</strong> Query node 通过订阅消息存储（log broker）获取增量日志数据并转化为 growing segment，基于对象存储加载历史数据，提供标量+向量的混合查询和搜索功能。</li><li><strong>Data node：</strong> Data node 通过订阅消息存储获取增量日志数据，处理更改请求，并将日志数据打包存储在对象存储上实现日志快照持久化。</li><li><strong>Index node：</strong> Index node 负责执行索引构建任务。Index node不需要常驻于内存，可以通过 serverless 的模式实现。</li></ul><h4 id="2-3-4-存储服务"><a href="#2-3-4-存储服务" class="headerlink" title="2.3.4 存储服务"></a><strong>2.3.4 存储服务</strong></h4><p>存储服务是系统的骨骼，负责 Milvus 数据的持久化，分为元数据存储（meta store）、消息存储（log broker）和对象存储（object storage）三个部分。</p><p><strong>元数据存储：</strong>负责存储元信息的快照，比如：集合 schema 信息、节点状态信息、消息消费的 checkpoint 等。元信息存储需要极高的可用性、强一致和事务支持，因此，etcd 是这个场景下的不二选择。除此之外，etcd 还承担了服务注册和健康检查的职责。</p><p><strong>对象存储：</strong>负责存储日志的快照文件、标量/向量索引文件以及查询的中间处理结果。Milvus 采用 MinIO 作为对象存储，另外也支持部署于 AWS S3 和Azure Blob 这两大最广泛使用的低成本存储。但是，由于对象存储访问延迟较高，且需要按照查询计费，因此 Milvus 未来计划支持基于内存或 SSD 的缓存池，通过冷热分离的方式提升性能以降低成本。</p><p><strong>消息存储：</strong>消息存储是一套支持回放的发布订阅系统，用于持久化流式写入的数据，以及可靠的异步执行查询、事件通知和结果返回。执行节点宕机恢复时，通过回放消息存储保证增量数据的完整性。</p><p>目前，分布式版Milvus依赖 Pulsar 作为消息存储，单机版Milvus依赖 RocksDB 作为消息存储。消息存储也可以替换为 Kafka、Pravega 等流式存储。</p><p>整个 Milvus 围绕日志为核心来设计，遵循<strong>日志即数据</strong>的准则，因此在 2.0 版本中没有维护物理上的表，而是通过日志持久化和日志快照来保证数据的可靠性。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4bed07b1d1f9c2165e60ab61d2b5f122.png" alt=""></p><p>日志系统作为系统的主干，承担了数据持久化和解耦的作用。通过日志的发布订阅机制，Milvus 将系统的读、写组件解耦。一个极致简化的模型如上图所示，整个系统主要由两个角色构成，分别是消息存储（log broker）（负责维护”日志序列“）与“日志订阅者”。其中的“日志序列”记录了所有改变库表状态的操作，“日志订阅者”通过订阅日志序列更新本地数据，以只读副本的方式提供服务。 发布订阅机制还为系统在变更数据捕获（CDC）和全面的分布式部署方面的可扩展性提供了空间。</p><h3 id="2-3-milvus主要组件"><a href="#2-3-milvus主要组件" class="headerlink" title="2.3 milvus主要组件"></a>2.3 milvus主要组件</h3><p>Milvus 支持两种部署模式，单机模式（standalone）和分布式模式（cluster）。两种模式具备完全相同的能力，用户可以根据数据规模、访问量等因素选择适合自己的模式。Standalone 模式部署的 Milvus 暂时不支持在线升级为 cluster 模式。</p><h4 id="2-3-1-单机版-Milvus"><a href="#2-3-1-单机版-Milvus" class="headerlink" title="2.3.1 单机版 Milvus"></a><strong>2.3.1 单机版 Milvus</strong></h4><p>单机版 Milvus包括三个组件：</p><ul><li><strong>Milvus</strong> 负责提供系统的核心功能。</li><li><strong>etcd</strong> 是元数据引擎，用于管理 Milvus 内部组件的元数据访问和存储，例如：proxy、index node 等。</li><li><strong>MinIO</strong> 是存储引擎，负责维护 Milvus 的数据持久化。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/82579743f897601e764f89c63d08bbff.jpeg" alt=""></p><h4 id="2-3-2-分布式版-Milvus"><a href="#2-3-2-分布式版-Milvus" class="headerlink" title="2.3.2 分布式版 Milvus"></a><strong>2.3.2 分布式版 Milvus</strong></h4><p>分布式版 Milvus 由八个微服务组件和三个第三方依赖组成，每个微服务组件可使用 Kubernetes 独立部署。</p><p><strong>微服务组件</strong></p><ul><li>Root coord</li><li>Proxy</li><li>Query coord</li><li>Query node</li><li>Index coord</li><li>Index node</li><li>Data coord</li><li>Data node</li></ul><p><strong>第三方依赖</strong></p><ul><li><strong>etcd</strong> 负责存储集群中各组件的元数据信息。</li><li><strong>MinIO</strong> 负责处理集群中大型文件的数据持久化，如索引文件和全二进制日志文件。</li><li><strong>Pulsar</strong> 负责管理近期更改操作的日志，输出流式日志及提供日志订阅服务。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6ce1cbb60b4a1e7309f4ccc3dcc37c89.jpeg" alt=""></p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="2-4-Milvus应用场景"><a href="#2-4-Milvus应用场景" class="headerlink" title="2.4 Milvus应用场景"></a>2.4 Milvus应用场景</h3><p>使用Milvus向量数据库，可以快速搭建符合自己场景需求的向量相似度检索系统。Milvus 的使用场景如下所示：</p><ul><li>图片检索系统：以图搜图，从海量数据库中即时返回与上传图片最相似的图片。</li><li>视频检索系统：将视频关键帧转化为向量并插入 Milvus，便可检索相似视频，或进行实时视频推荐。</li><li>音频检索系统：快速检索海量演讲、音乐、音效等音频数据，并返回相似音频。</li><li>分子式检索系统：超高速检索相似化学分子结构、超结构、子结构。</li><li>推荐系统：根据用户行为及需求推荐相关信息或商品。</li><li>智能问答机器人：交互式智能问答机器人可自动为用户答疑解惑。</li><li>DNA序列分类系统：通过对比相似 DNA 序列，仅需几毫秒便可精确对基因进行分类。</li><li>文本搜索引擎：帮助用户从文本数据库中通过关键词搜索所需信息。</li></ul><h2 id="3-Milvus部署及使用"><a href="#3-Milvus部署及使用" class="headerlink" title="3 Milvus部署及使用"></a>3 Milvus部署及使用</h2><h3 id="3-1-Milvus安装"><a href="#3-1-Milvus安装" class="headerlink" title="3.1 Milvus安装"></a>3.1 Milvus安装</h3><pre><code>wget https://github.com/milvus-io/milvus/releases/download/v2.2.13/milvus-standalone-docker-compose.yml -O docker-compose.yml sudo docker-compose up -d sudo docker-compose ps</code></pre><p>通过命令查看显示信息如下：</p><pre><code>      Name                     Command                  State                            Ports--------------------------------------------------------------------------------------------------------------------milvus-etcd         etcd -advertise-client-url ...   Up             2379/tcp, 2380/tcpmilvus-minio        /usr/bin/docker-entrypoint ...   Up (healthy)   9000/tcpmilvus-standalone   /tini -- milvus run standalone   Up             0.0.0.0:19530-&gt;19530/tcp, 0.0.0.0:9091-&gt;9091/tcp</code></pre><p> 验证连接：</p><pre><code>docker port milvus-standalone 19530/tcp</code></pre><p>停止Milvus</p><pre><code>sudo docker-compose down</code></pre><p>停止后删除数据</p><pre><code>sudo rm -rf  volumes</code></pre><h3 id="3-2-Milvus可视化工具Attu"><a href="#3-2-Milvus可视化工具Attu" class="headerlink" title="3.2 Milvus可视化工具Attu"></a>3.2 Milvus可视化工具Attu</h3><p>Attu地址：<a href="https://github.com/zilliztech/attu/blob/main/doc/zh-CN/attu_install-docker.md" title="Attu">Attu</a></p><p>Milvus与Attu对应关系：</p><p>Milvus Version</p><p>Recommended Attu Image Version</p><p>v2.0.x</p><p>v2.0.5</p><p>v2.1.x</p><p>v2.1.5</p><p>v2.2.x</p><p>v2.2.6</p><p>执行命令：</p><pre><code>docker run -p 8000:3000  -e MILVUS_URL=&#123;your machine IP&#125;:19530 zilliz/attu:v2.2.6</code></pre><p>启动docker后，在浏览器中访问“<a href="http://{your">http://{your</a> machine IP}:8000”，点击“<strong>Connect</strong>”进入Attu服务。连接方式用户名和密码。 </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/18a96ef64148c6cc233b4c09e4ae9f50.png" alt=""></p><p> 连接connect后，显示如下：<img src="https://i-blog.csdnimg.cn/blog_migrate/c8cba97e9a52bc71b41f20961fbd1954.png" alt=""></p><h3 id="3-3-通过python使用Milvus"><a href="#3-3-通过python使用Milvus" class="headerlink" title="3.3 通过python使用Milvus"></a>3.3 通过python使用Milvus</h3><p>安装pymilvus</p><pre><code>pip install pymilvus==2.2.15</code></pre><h4 id="3-2-1-创建数据库"><a href="#3-2-1-创建数据库" class="headerlink" title="3.2.1 创建数据库"></a>3.2.1 创建数据库</h4><pre><code>from pymilvus import connections, db conn = connections.connect(host=&quot;192.168.1.156&quot;, port=19530)database = db.create_database(&quot;sample_db&quot;)</code></pre><p>切换和显示db</p><pre><code>db.using_database(&quot;sample_db&quot;)db.list_database()</code></pre><h4 id="3-2-2-创建collection"><a href="#3-2-2-创建collection" class="headerlink" title="3.2.2 创建collection"></a>3.2.2 创建collection</h4><pre><code>from pymilvus import CollectionSchema, FieldSchema, DataTypefrom pymilvus import Collection, db, connections conn = connections.connect(host=&quot;192.168.1.156&quot;, port=19530)db.using_database(&quot;sample_db&quot;) m_id = FieldSchema(name=&quot;m_id&quot;, dtype=DataType.INT64, is_primary=True,)embeding = FieldSchema(name=&quot;embeding&quot;, dtype=DataType.FLOAT_VECTOR, dim=768,)count = FieldSchema(name=&quot;count&quot;, dtype=DataType.INT64,)desc = FieldSchema(name=&quot;desc&quot;, dtype=DataType.VARCHAR, max_length=256,)schema = CollectionSchema(  fields=[m_id, embeding, desc, count],  description=&quot;Test embeding search&quot;,  enable_dynamic_field=True) collection_name = &quot;word_vector&quot;collection = Collection(name=collection_name, schema=schema, using=&#39;default&#39;, shards_num=2)</code></pre><p>通过Attu查看创建结果：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e594bdfea03c817a1dc3cc55fe31ac6.png" alt=""></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2ddb814ba2110332535118f84ecc052b.png" alt=""></p><h4 id="3-2-3-创建索引"><a href="#3-2-3-创建索引" class="headerlink" title="3.2.3 创建索引"></a>3.2.3 创建索引</h4><pre><code>from pymilvus import Collection, utility, connections, db conn = connections.connect(host=&quot;192.168.1.156&quot;, port=19530)db.using_database(&quot;sample_db&quot;) index_params = &#123;  &quot;metric_type&quot;: &quot;IP&quot;,  &quot;index_type&quot;: &quot;IVF_FLAT&quot;,  &quot;params&quot;: &#123;&quot;nlist&quot;: 1024&#125;&#125; collection = Collection(&quot;word_vector&quot;)collection.create_index(  field_name=&quot;embeding&quot;,  index_params=index_params) utility.index_building_progress(&quot;word_vector&quot;)</code></pre><p> 通过Attu查看结果：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/395ae7e89ac481201c39c040a034632e.png" alt=""></p><p> <strong>索引方式：</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b32c6d2df4fba597320c47a308d572b6.png" alt=""></p><ul><li>FLAT：准确率高， 适合数据量小，暴力求解相似。</li><li>IVF-FLAT：量化操作， 准确率和速度的平衡</li><li>IVF: inverted file 先对空间的点进行聚类，查询时先比较聚类中心距离，再找到最近的N个点。</li><li>IVF-SQ8：量化操作，disk cpu GPU 友好</li><li>SQ8：对向量做标量量化，浮点数表示转为int型表示，4字节-&gt;1字节。</li><li>IVF-PQ：快速，但是准确率降低，把向量切分成m段，对每段进行聚类；查询时，查询向量分端后与聚类中心计算距离，各段相加后即为最终距离。使用对称距离(聚类中心之前的距离)不需要计算直接查表，但是误差回更大一些。</li><li>HNSW：基于图的索引，高效搜索场景，构建多层的NSW。</li><li>ANNOY：基于树的索引，高召回率</li></ul><h4 id="3-2-4-插入数据"><a href="#3-2-4-插入数据" class="headerlink" title="3.2.4 插入数据"></a>3.2.4 插入数据</h4><pre><code>from pymilvus import Collection, db, connectionsimport numpy as np conn = connections.connect(host=&quot;192.168.1.156&quot;, port=19530)db.using_database(&quot;sample_db&quot;)coll_name = &#39;word_vector&#39; mids, embedings, counts, descs = [], [], [], []data_num = 100for idx in range(0, data_num):    mids.append(idx)    embedings.append(np.random.normal(0, 0.1, 768).tolist())    descs.append(f&#39;random num &#123;idx&#125;&#39;)    counts.append(idx) collection = Collection(coll_name)mr = collection.insert([mids, embedings, descs, counts])print(mr)</code></pre><p>运行结果：</p><pre><code>(insert count: 100, delete count: 0, upsert count: 0, timestamp: 443639998144839682, success count: 100, err count: 0)</code></pre><p>通过Attu查看：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a8dcecc665b305bb98be62e3304ec4d4.png" alt=""></p><h4 id="3-2-5-检索数据"><a href="#3-2-5-检索数据" class="headerlink" title="3.2.5 检索数据"></a>3.2.5 检索数据</h4><pre><code>from pymilvus import Collection, db, connectionsimport numpy as np conn = connections.connect(host=&quot;192.168.1.156&quot;, port=19530)db.using_database(&quot;sample_db&quot;)coll_name = &#39;word_vector&#39; search_params = &#123;    &quot;metric_type&quot;: &#39;IP&#39;,    &quot;offset&quot;: 0,    &quot;ignore_growing&quot;: False,    &quot;params&quot;: &#123;&quot;nprobe&quot;: 16&#125;&#125; collection = Collection(coll_name)collection.load() results = collection.search(    data=[np.random.normal(0, 0.1, 768).tolist()],    anns_field=&quot;embeding&quot;,    param=search_params,    limit=16,    expr=None,    # output_fields=[&#39;m_id&#39;, &#39;embeding&#39;, &#39;desc&#39;, &#39;count&#39;],    output_fields=[&#39;m_id&#39;, &#39;desc&#39;, &#39;count&#39;],    consistency_level=&quot;Strong&quot;)collection.release()print(results[0].ids)print(results[0].distances)hit = results[0][0]print(hit.entity.get(&#39;desc&#39;))print(results) </code></pre><p>运行结果如下：</p><pre><code>[0, 93, 77, 61, 64, 79, 22, 43, 25, 35, 83, 49, 51, 84, 75, 36][0.7047597169876099, 0.5948767066001892, 0.54373699426651, 0.5294350981712341, 0.5216281414031982, 0.5035749673843384, 0.41662347316741943, 0.4026581346988678, 0.40143388509750366, 0.3841533362865448, 0.371593713760376, 0.35352253913879395, 0.3377170264720917, 0.33591681718826294, 0.32786160707473755, 0.3214406967163086]random num 0[&#39;[&quot;id: 0, distance: 0.7047597169876099, entity: &#123;\&#39;m_id\&#39;: 0, \&#39;desc\&#39;: \&#39;random num 0\&#39;, \&#39;count\&#39;: 0&#125;&quot;, &quot;id: 93, distance: 0.5948767066001892, entity: &#123;\&#39;m_id\&#39;: 93, \&#39;desc\&#39;: \&#39;random num 93\&#39;, \&#39;count\&#39;: 93&#125;&quot;, &quot;id: 77, distance: 0.54373699426651, entity: &#123;\&#39;m_id\&#39;: 77, \&#39;desc\&#39;: \&#39;random num 77\&#39;, \&#39;count\&#39;: 77&#125;&quot;, &quot;id: 61, distance: 0.5294350981712341, entity: &#123;\&#39;m_id\&#39;: 61, \&#39;desc\&#39;: \&#39;random num 61\&#39;, \&#39;count\&#39;: 61&#125;&quot;, &quot;id: 64, distance: 0.5216281414031982, entity: &#123;\&#39;m_id\&#39;: 64, \&#39;desc\&#39;: \&#39;random num 64\&#39;, \&#39;count\&#39;: 64&#125;&quot;, &quot;id: 79, distance: 0.5035749673843384, entity: &#123;\&#39;m_id\&#39;: 79, \&#39;desc\&#39;: \&#39;random num 79\&#39;, \&#39;count\&#39;: 79&#125;&quot;, &quot;id: 22, distance: 0.41662347316741943, entity: &#123;\&#39;m_id\&#39;: 22, \&#39;desc\&#39;: \&#39;random num 22\&#39;, \&#39;count\&#39;: 22&#125;&quot;, &quot;id: 43, distance: 0.4026581346988678, entity: &#123;\&#39;m_id\&#39;: 43, \&#39;desc\&#39;: \&#39;random num 43\&#39;, \&#39;count\&#39;: 43&#125;&quot;, &quot;id: 25, distance: 0.40143388509750366, entity: &#123;\&#39;m_id\&#39;: 25, \&#39;desc\&#39;: \&#39;random num 25\&#39;, \&#39;count\&#39;: 25&#125;&quot;, &quot;id: 35, distance: 0.3841533362865448, entity: &#123;\&#39;m_id\&#39;: 35, \&#39;desc\&#39;: \&#39;random num 35\&#39;, \&#39;count\&#39;: 35&#125;&quot;]&#39;]</code></pre><h4 id="3-2-6-删除数据"><a href="#3-2-6-删除数据" class="headerlink" title="3.2.6 删除数据"></a>3.2.6 删除数据</h4><pre><code>from pymilvus import Collection, db, connections conn = connections.connect(host=&quot;192.168.1.156&quot;, port=19530)db.using_database(&quot;sample_db&quot;)coll_name = &#39;word_vector&#39; collection = Collection(coll_name) ids = [str(idx) for idx in range(10)]temp_str = &#39;, &#39;.join(ids)query_expr = f&#39;m_id in [&#123;temp_str&#125;]&#39;result = collection.delete(query_expr) print(result)</code></pre><p>运行结果显示：</p><pre><code>(insert count: 0, delete count: 10, upsert count: 0, timestamp: 443640854673883146, success count: 0, err count: 0)</code></pre><p>为了检索提供性能，Milvus 中引入 bitset，当调用删除数据时，Milvus对数据进行软删除。软删除的向量仍然存在于数据库中，但在向量相似性搜索或查询期间不会被计算。位集中的每个位对应于一个索引向量。如果一个向量在位集中被标记为 <code>1</code>，则意味着该向量被软删除，并且在向量搜索期间不会涉及该向量。 </p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>向量数据库技术是为AI而生的创新，它充分发挥了向量表示的优势，为多模态、高维、复杂数据的存储、检索和分析提供了高效解决方案。随着AI应用的不断发展，向量数据库将成为推动AI加速创新的重要工具之一，为各行各业带来更高效、智能的解决方案。无疑，在这个AI驱动的时代，向量数据库必将继续发挥其重要作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-向量数据库&quot;&gt;&lt;a href=&quot;#1-向量数据库&quot; class=&quot;headerlink&quot; title=&quot;1 向量数据库&quot;&gt;&lt;/a&gt;1 向量数据库&lt;/h2&gt;&lt;h3 id=&quot;1-1-向量数据库的由来&quot;&gt;&lt;a href=&quot;#1-1-向量数据库的由来&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="开发" scheme="https://amirokd.dpdns.org/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>规则引擎框架LiteFlow</title>
    <link href="https://amirokd.dpdns.org/posts/430a0150.html"/>
    <id>https://amirokd.dpdns.org/posts/430a0150.html</id>
    <published>2025-07-15T07:25:55.000Z</published>
    <updated>2025-07-15T08:06:09.031Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简介：</strong> 在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护的成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_bcffabaf1b944cbbbf778d9db9bdc768.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>今天给大家介绍一款轻量、快速、稳定可编排的组件式规则引擎框架LiteFlow。</p><h2 id="LiteFlow的介绍"><a href="#LiteFlow的介绍" class="headerlink" title="LiteFlow的介绍"></a>LiteFlow的介绍</h2><p>LiteFlow官方网站和代码仓库地址</p><ul><li>官方网站：<a href="https://yomahub.com/liteflow">https://yomahub.com/liteflow</a></li><li>Gitee托管仓库：<a href="https://gitee.com/dromara/liteFlow">https://gitee.com/dromara/liteFlow</a></li><li>Github托管仓库：<a href="https://github.com/dromara/liteflow">https://github.com/dromara/liteflow</a></li></ul><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护的成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。</p><h4 id="LiteFlow框架的作用"><a href="#LiteFlow框架的作用" class="headerlink" title="LiteFlow框架的作用"></a>LiteFlow框架的作用</h4><p>LiteFlow就是为解耦复杂逻辑而生，如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个轻量，快速的组件式流程引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件，并支持热加载规则配置，实现即时修改。</p><p>使用LiteFlow，你需要去把复杂的业务逻辑按代码片段拆分成一个个小组件，并定义一个规则流程配置。这样，所有的组件，就能按照你的规则配置去进行复杂的流转。</p><h4 id="LiteFlow的设计原则"><a href="#LiteFlow的设计原则" class="headerlink" title="LiteFlow的设计原则"></a>LiteFlow的设计原则</h4><p>LiteFlow是基于工作台模式进行设计的，何谓工作台模式？</p><p>n个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。</p><p>这个模式有几个好处：</p><ul><li>每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。</li><li>即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。</li><li>如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。</li><li>因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时地被更改。这样就保证了整个生产任务的灵活性。</li></ul><p>这个模式映射到LiteFlow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以LiteFlow能做到统一解耦的组件和灵活的装配。</p><h2 id="LiteFlow的使用"><a href="#LiteFlow的使用" class="headerlink" title="LiteFlow的使用"></a>LiteFlow的使用</h2><h4 id="1）非Spring环境下"><a href="#1）非Spring环境下" class="headerlink" title="1）非Spring环境下"></a>1）非Spring环境下</h4><p>引入pom依赖</p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;com.yomahub&lt;/groupId&gt;   &lt;artifactId&gt;liteflow-core&lt;/artifactId&gt;   &lt;version&gt;2.6.13&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>第一步构建自己的业务Node，也就是继承NodeComponent，重写process方法，业务执行的过程中，会调用process来执行节点的业务。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_e40ba03890c843ac84c2169543b0224f.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>我这里写了三个</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_d1a670d37f71495f901e22bebba30ed6.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>然后编写xml文件，直接放在resources底下</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_54a7d71042b44fba9216067dcd4b824f.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_f61b21a542644099a1bdcf92a1b38083.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>配置了每个业务的节点，这里配置了我们写的那几个，标签代表了每一个业务的执行流程，配置了和标签，然后value标签设置了上面配置的的id，至于为什么这么配置，后面会解析。</p><p>然后执行这个demo</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_b07293d7e26c4e4c9d1f8200914c585c.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>构建了一个LiteflowConfig，传入xml的路径，然后构建FlowExecutor，最后调用FlowExecutor的execute2Resp，传入需要执行的业务流程名字 chain1 ，就是xml中配置的，执行业务流程。</p><p>结果</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_2002405834a74fcd95120c6ddc8bb182.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>如果业务变动，现在不需要执行B流程了，那么直接修改规则文件就行了，如图。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_d6e5b79c16dc4ff7914bc2e7932bb179.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>运行结果</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_55ada7b6359b4cb582f5146245e97e9d.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>这里发现B就没执行了。</p><h4 id="2）SpringBoot环境下"><a href="#2）SpringBoot环境下" class="headerlink" title="2）SpringBoot环境下"></a>2）SpringBoot环境下</h4><p>引入pom依赖</p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;com.yomahub&lt;/groupId&gt;   &lt;artifactId&gt;liteflow-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;2.6.13&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>构建自己的业务Node，只不过在Spring的环境底下，可以不需要在xml配置标签，直接使用@LiteflowComponent注解即可</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_04069419c1f14a6e84360a0bbeabf5c1.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>xml中没有声明标签</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_976098ffeee840c6b9aa6be198d496f7.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>application.properties中配置xml文件的路径</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_599c784ac9974a01a926e695a4b92882.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>测试代码</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_6a3982abf52643b299d09a395495290f.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>执行结果</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_d094aaaafb174106ac478dc98499554c.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>跟非spring的环境结果一致。</p><p>如果有想要获取demo的小伙伴在微信公众号后台回复 LiteFlow 即可获取。</p><p>通过上面的例子我们可以看出，其实每个业务节点之间是没有耦合的，用户只需要按照一定的业务规则配置节点的执行顺序，LiteFlow就能实现业务的执行。</p><h2 id="LiteFlow核心组件讲解"><a href="#LiteFlow核心组件讲解" class="headerlink" title="LiteFlow核心组件讲解"></a>LiteFlow核心组件讲解</h2><p>讲解核心组件的时候如果有什么不是太明白的，可以继续往下看，后面会有源码解析。</p><p>下图为LiteFlow整体架构图</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_932df9ad93644f8db47630f0d8267166.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><h4 id="1）Parser"><a href="#1）Parser" class="headerlink" title="1）Parser"></a>1）Parser</h4><p>这个组件的作用就是用来解析流程配置的规则，也就是将你配置的规则文件解析成Java代码来运行。支持的文件格式有xml、json、yaml，其实不论是什么格式，只是形式的不同，用户可根据自身配置的习惯来选择规则文件的格式。</p><p>同时，规则文件的存储目前官方支持基于zk或者本地文件的形式，同时也支持自定义的形式。</p><p>对于xml来说，Parser会将标签解析成Node对象，将解析成Chain对象，将内部的比如、等标签都会解析成Condition对象。</p><p>如下图所示。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_21b6c34f1f36405990a381dc8993318a.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>Node其实就是代表了你具体业务执行的节点，就是真正的业务是在Node中执行的</p><p>Condition可以理解为一种条件，比如前置条件，后置条件，里面一个Condition可以包含许多需要执行的Node</p><p>Chain可以理解成整个业务执行的流程，按照一定的顺序来执行Condition中的Node也就是业务节点</p><p>Condition和Node的关系</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_9811552e01314efcbde5f9b58b1c1b4a.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>Condition分为以下几种：</p><ul><li>PreCondition：在整个业务执行前执行，就是前置的作用</li><li>ThenCondition：内部的Node是串行执行的</li><li>WhenCondition：内部的Node是并行执行的</li></ul><p>FinallyCondition：当前面的Condition中的Node都执行完成之后，就会执行这个Condition中的Node节点</p><p>Chain和Condition的关系</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_5e06012b49324259a160f37e1f77bf48.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>Chain内部其实就是封装了一堆Condition，Chain的执行就是指从不同的Condition中拿出里面的Node来执行，首先会拿出来PreCondition中的Node节点来执行，执行完之后会执行ThenCondition和WhenCondition中的Node节点，最后执行完之后才会执行FinallyCondition中的Node节点。</p><h4 id="2）FlowBus"><a href="#2）FlowBus" class="headerlink" title="2）FlowBus"></a>2）FlowBus</h4><p>这个组件主要是用来存储上一步骤解析出来的Node和Chain的</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_81bb09306b7d4de786c94163bd7dadf2.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><h4 id="3）FlowExecutor"><a href="#3）FlowExecutor" class="headerlink" title="3）FlowExecutor"></a>3）FlowExecutor</h4><p>这个其实是用来执行上面解析出来的业务流程，从FlowBus找到需要执行的业务流程Chain，然后执行Chain，也就是按照Condition的顺序来分别执行每个Condition的Node，也就是业务节点。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_71c8458da92845e78f98875add7f724e.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><h4 id="4）Slot"><a href="#4）Slot" class="headerlink" title="4）Slot"></a>4）Slot</h4><p>Slot可以理解为业务的上下文，在一个业务流程中，这个Slot是共享的。</p><p>Slot有个默认的实现DefaultSlot，DefaultSlot虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议自己去实现自己的Slot，可以继承AbsSlot。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_762f00b357db4055ba386f440e6cfcc7.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><h4 id="5）DataBus"><a href="#5）DataBus" class="headerlink" title="5）DataBus"></a>5）DataBus</h4><p>用来管理Slot的，从这里面可以获取当前业务流程执行的Slot。</p><h2 id="LiteFlow源码探究"><a href="#LiteFlow源码探究" class="headerlink" title="LiteFlow源码探究"></a>LiteFlow源码探究</h2><p>说完核心的组件，接下来就来剖析一下源码，来看一看LiteFlow到底是如何实现规则编排的。</p><h4 id="1）FlowExecutor的构造流程"><a href="#1）FlowExecutor的构造流程" class="headerlink" title="1）FlowExecutor的构造流程"></a>1）FlowExecutor的构造流程</h4><p>我们这里就以非Spring环境的例子来说，因为在SpringBoot环境底下，FlowExecutor是由Spring创建的，但是创建的过程跟非Spring的例子是一样的。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_858e1a0829ed4c489f0f56cf341677bd.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>这里在构建FlowExecutor，传入了一个规则的路径flow.xml，也就是ruleSource属性值。</p><p>进入loadInstance这个方法，其实就是直接new了一个FlowExecutor。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_ad754c221a5b461187b46e013f0e4335.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>进入FlowExecutor构造方法，前面就是简单的赋值操作。然后调用liteflowConfig.isParseOnStart()，这个方法默认是返回true的，接下来会调用init方法，也就是在启动时，就去解析规则文件，保证运行时的效率。</p><p>接下来进入init方法。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_59690e170fca42df9618a394057cdaa6.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>init方法非常长，来一步一步解析</p><p>前面就是校验，不用care</p><pre><code>List&lt;String&gt; sourceRulePathList = Lists.newArrayList(liteflowConfig.getRuleSource().split(&quot;,|;&quot;));</code></pre><p>这行代码的意思就是将我们传入的规则文件路径进行分割成多个路径，从这可以看出支持配置多个规则的文件。对我们这个demo来说其实就是只有一个，那就是flow.xml。</p><p>分割完之后，就会遍历每个路径，然后判断文件的格式，比如xml、json、yaml，然后根据文件格式找到对应的FlowParser。</p><p>随后根据liteflowConfig.isSupportMultipleType()判断是不是支持多类型的，什么叫多类型，就是指规则文件配置了多个并且文件的格式不同，如果支持的话，需要每个规则文件单独去解析，如果不支持，那就说明文件的格式一定是相同的，相同可以在最后统一解析，解析是通过调用FlowParser的parseMain来解析的。</p><p>剖析完之后整个init方法就会结束，然后继续调用DataBus的init方法，其实就是初始化DataBus。</p><p>到这其实构建FlowExecutor就完成了，从上面我们得出一个结论，那就是在构造FlowExecutor的时候会通过FlowParser的parseMain来处理对应规则文件的路径，所以接下来我们分析一下这个FlowParser是如何解析xml的，并且解析了之后干了什么。</p><h4 id="2）FlowParser规则解析流程"><a href="#2）FlowParser规则解析流程" class="headerlink" title="2）FlowParser规则解析流程"></a>2）FlowParser规则解析流程</h4><p>接下来我们进入FlowParser来看看一个是如何解析规则的。</p><p>以本文的例子为例，因为是配置本地的xml文件，找到的FlowParser的实现是LocalXmlFlowParser。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_8cb6b69077cc4a7ea3b1bd66f7b327b1.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>接下会调用parseMain方法，parseMain的方法的实现很简单，首先根据PathContentParserHolder拿到一个PathContentParser来解析路径，对上面案例来说，就是flow.xml路径，拿到路径对应文件的内容，其实就是拿到了flow.xml内容。然后调用父类的parse方法来解析xml的内容，所以parse方法才是解析xml的核心方法。</p><p>这里有个细节说一下，PathContentParserHolder其实内部使用了Java的SPI机制来加载PathContentParser的实现，然后解析路径，拿到内容，在Spring环境中默认基于Spring的实现的优先级高点，但是不论是怎么实现，作用都是一样的，那就是拿到路径对应的xml文件的内容，这里就不继续研究PathContentParser是如何加载文件的源码了。</p><p>其实不光是PathContentParser，LiteFlow内部使用了很多SPI机制，但是基本上整合Spring的实现的优先级都高于框架本身的实现。</p><p>接下来我们就来看一下LocalXmlFlowParser父类中的parse方法的实现。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_4b758e17fa164a09b0e86c57fdcbdbdb.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>首先遍历每个文件中的内容，然后转成Document，Document其实是dom4j的包，其实就是将xml转成Java对象，这样可以通过Java中的方法来获取xml中每个标签的数据。</p><p>将文件都转换成Document之后，调用parseDocument方法。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_3873097db2a045e0985a39ecf2b28dda.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>首先调用了ContextCmpInitHolder.loadContextCmpInit().initCmp() ，这行代码也是通过SPI机制来加载ContextCmpInit，调用initCmp方法。框架本身对于initCmp的实现是空实现，但是在Spring环境中，主要是用来整合Spring中的Node节点的，将Node节点添加到FlowBus中，这也是为什么在Spring环境中的那个案例中不需要在xml文件中配置的原因，因为LiteFlow会自动识别这些Node节点的Spring Bean。至于怎么整合Spring的，有兴趣的同学可以看一下ComponentScanner类的实现，主要在Bean初始化之后进行判断的，这里画一张图来总结一下initCmp方法的作用。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_8400e67e2ba54a92ae76026932821443.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>至于为什么需要先将Spring中的Node节点添加到FlowBus，其实很简单，主要是因为构建Chain是需要Node，需要保证构建Chain之前，Spring中的Node节点都已经添加到了FlowBus中。</p><p>接下来就会继续遍历每个Document，也就是每个xml，然后拿到解析中的每个标签，拿出每个node标签中的属性，通过LiteFlowNodeBuilder构建Node，然后放入到FlowBus中，至于如何放入到FlowBus中，可以看一下LiteFlowNodeBuilder的build方法的实现。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_dc193af5a1ac44c8ada0b831a040cb44.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>解析完Node之后，接下来就是解析标签，拿到每一个标签对应的Element之后，调用parseOneChain来解析标签的内容。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_90b17421133a4daba85f3f4928aa5edc.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>parseOneChain方法，先拿到底下所有的标签，然后判断标签类型，标签的类型主要有四种类型：then、when、pre、finally，然后拿到每个标签的值，构建对应的Condition，就是上文提到的ThenCondition、WhenCondition、PreCondition、FinallyCondition，然后加入到Chain中，至于如何将Node设置到Condition中，主要是通过LiteFlowConditionBuilder的setValue方法来实现的，setValue这个方式设置的值是条件标签的value属性值，然后解析value属性值，然后从FlowBus中clone一个新的Node，加入到Condition中，至于为什么需要clone一下新的Node，因为同一个业务节点，可能在不同的执行链中，为了保证不同业务中的同一个业务节点不相互干扰，所以得重新clone一个新的Node对象。</p><p>构建好Condition之后，都设置到了对应的Chain中，最后将Chain添加到FlowBus中。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_e7e3217ea77d421783045601e0a8d816.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>到这里，其实整个xml就解析完了，FlowParser的最主要的作用就是解析xml，根据配置构建Node、Condition和Chain对象，有了这些基础的组件之后，后面才能运行业务流程。其实从这里也可以看出是如何流程编排的，其实就是根据配置，将一个个Node添加到Condition中，Condition再添加到Chain中，这样相同的业务节点，可能分布在不同的Chain中，这样就实现了业务代码的复用和流程的编排。</p><h4 id="3）Chain的执行流程"><a href="#3）Chain的执行流程" class="headerlink" title="3）Chain的执行流程"></a>3）Chain的执行流程</h4><p>剖析完FlowParser的作用，也就是Node和Chain的构造流程之后，接下来看一下Chain是如何执行的。</p><p>流程执行是通过FlowExecutor来执行的，FlowExecutor执行的方法很多，我们以上面demo调用的execute2Resp为例，最终会走到如下图的重载方法。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_bd6fa7dec5cd4ad6920e729bf0f32200.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>execute2Resp方法就会调用doExecute方法的实现，然后拿到Slot，封装成一个LiteflowResponse返回回去，所以从这里可以看出，doExecute是核心方法。</p><p>接下来看看doExecute方法的实现。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_697230b4c682471d99c19018ff02c666.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_509d3b7afd1c4ceca81590c73f4a850a.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>doExecute方法比较长，我截了两张图</p><p>首先从DataBus中获取一个Slot，也就是当前业务执行的上下文。之后从FlowBus中获取需要执行的Chain，最后分别调用了Chain的executePre、execute、executeFinally方法，其实不用看也知道这些方法干了什么，其实就是调用不同的Condition中Node方法。</p><p>executePre和executeFinally方法</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_c64b709fc0bc407bb1b4687bc59bc51f.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>这两个方法最后调用的是同一个方法，就是分别找到PreCondition和FinallyCondition，取出里面的Node节点，执行excute方法。</p><p>这里有重点说明一下，其实在Condition中存的不是直接的Node，而是Executable，Executable的有两个实现，一个就是我们所说的Node，还有一个就是我们一直说的Chain，为了方便大家理解，我一直说的是Node，其实这里的Executable是有可能为Chain的，取决于规则的配置。当是一个Chain的时候，其实就是一个嵌套的子流程，也就是在一个流程中嵌套另一个流程的意思，大家注意一下就行了，其实不论怎么嵌套，流程执行到最后一定是Node，因为如果是Chain，那么还会继续执行，不会停止，只有最后一个流程的Executable都是Node的时候流程才能执行完。</p><p>executePre和executeFinally方法说完之后，看一看execute方法的实现。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_135b8f0d130a4ac587cff219719b5a7b.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>execute方法主要是判断Condition的类型，然后判断是ThenCondition还是WhenCondition，ThenCondition的话其实也就是拿出Node直接执行，如果是WhenCondition的话，其实就是并行执行每个Node节点。这也是ThenCondition和WhenCondition的主要区别。</p><p>画图总结一下Chain的执行流程</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_fc12193392fb496ea4674aa16ef11a5e.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><h4 id="4）Node的执行流程"><a href="#4）Node的执行流程" class="headerlink" title="4）Node的执行流程"></a>4）Node的执行流程</h4><p>从上面我们可以看出，Chain的执行其实最终都是交给Node来执行的，只不过是不同阶段调用不同的Node而已，其实最终也就是会调用Node的execute方法，所以我们就来着重看一下Node的execute方法。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_ed8d42b8dc6a4d39946d98c7f61f2aac.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>instance就是NodeComponent对象，也就是我们自定义实现的节点对象，好家伙，终于要执行到业务了。有人可能好奇NodeComponent是如何设置到Node对象中的，其实就是在往FlowBus添加Node的时候设置的，不清楚的小伙伴可以翻一下那块相关的源码，在解析xml那块我有说过。</p><p>先调用NodeComponent的isAccess方法来判断业务要不要执行，默认是true，你可以重写这个方法，自己根据其它节点执行的情况来判断当前业务的节点要不要执行，因为Slot是公共的，每个业务节点的执行结果可以放在Slot中。</p><p>随后通过这个方法获取了NodeExecutor，NodeExecutor可以通过execute方法来执行NodeComponent的，也就是来执行业务的，NodeExecutor默认是使用DefaultNodeExecutor子类的，当然你也可以自定义NodeExecutor来执行NodeComponent</p><pre><code>NodeExecutor nodeExecutor = NodeExecutorHelper.loadInstance().buildNodeExecutor(instance.getNodeExecutorClass());</code></pre><p>DefaultNodeExecutor的execute方法也是直接调用父类NodeExecutor的execute方法，接下来我们来看一下NodeExecutor的execute方法。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_79395d61dab140ee9bb3941bca7d70f9.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>从这个方法的实现我们可以看出，LiteFlow对于业务的执行是支持重试功能的，但是不论怎么重试，最终一定调用的是NodeComponent的execute方法。</p><p>进入NodeComponent的execute方法</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_33e27c9ef16b4c0d9e14d7245d2af1c0.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>红框圈出来的，就是核心代码，self是一个变量，指的是当前这个NodeComponent对象，所以就直接调用当前这个NodeComponent的process方法，也就是用来执行业务的方法。</p><p>在执行NodeComponent的process方法前后其实有回调的，也就是可以实现拦截的效果，在Spring环境中会生效。</p><p>至于这里为什么要使用self变量而不是直接使用this，其实源码也有注释，简单点说就是如果process方法被动态代理了，那么直接使用this的话，动态代理会不生效，所以为了防止动态代理不生效，就单独使用了self变量来引用自己。至于为什么不生效，这是属于Spring的范畴了，这里就不过多赘述了。</p><p>其实到这里，一个Node就执行完成了，Node的执行其实就是在执行NodeComponent，而NodeComponent其实最终是交给NodeExecutor来执行的。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_44a84f3daced47eca42e1dc3e0ecef4f.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>每个Condition中的Node执行完之后，就将Slot返回，这样就能在调用方就能通过Slot拿到整个流程的执行结果了。</p><p>到这里，其实核心流程源码剖析就完成了，总的来说就是将规则配置文件翻译成代码，生成Node和Chain，然后通过调用Chain来执行业务流程，最终其实就是执行我们实现的NodeComponent的process方法。</p><p>最终画一张图来总结整个核心源码。</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/dg5rf4zqvuxpe_e5bc14d8d5624e0f8f3b72619b75b24a.png?x-oss-process=image/resize,w_1400/format,webp" alt="image.png"></p><p>图中我省略了Condition的示意图，因为Condition其实最终也是执行Node的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt; 在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，</summary>
      
    
    
    
    
    <category term="开发" scheme="https://amirokd.dpdns.org/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java计算地球上两点之间的椭球面距离</title>
    <link href="https://amirokd.dpdns.org/posts/bcefa0a2.html"/>
    <id>https://amirokd.dpdns.org/posts/bcefa0a2.html</id>
    <published>2025-06-05T13:04:25.000Z</published>
    <updated>2025-06-05T13:06:23.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算距离</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longitudeFrom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> latitudeFrom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longitudeTo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> latitudeTo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getDistance</span><span class="params">(<span class="type">double</span> longitudeFrom, <span class="type">double</span> latitudeFrom, <span class="type">double</span> longitudeTo, <span class="type">double</span> latitudeTo)</span> &#123;</span><br><span class="line">    <span class="type">GlobalCoordinates</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalCoordinates</span>(latitudeFrom, longitudeFrom);</span><br><span class="line">    <span class="type">GlobalCoordinates</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalCoordinates</span>(latitudeTo, longitudeTo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GeodeticCalculator</span>().calculateGeodeticCurve(Ellipsoid.Sphere, source, target)</span><br><span class="line">            .getEllipsoidalDistance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
    <category term="开发" scheme="https://amirokd.dpdns.org/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入了解海豚调度DolphinScheduler</title>
    <link href="https://amirokd.dpdns.org/posts/7fdb8b61.html"/>
    <id>https://amirokd.dpdns.org/posts/7fdb8b61.html</id>
    <published>2025-05-27T08:13:36.000Z</published>
    <updated>2025-05-27T08:14:57.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="深入了解海豚调度DolphinScheduler"><a href="#深入了解海豚调度DolphinScheduler" class="headerlink" title="深入了解海豚调度DolphinScheduler"></a>深入了解海豚调度<a href="https://so.csdn.net/so/search?q=DolphinScheduler&amp;spm=1001.2101.3001.7020">DolphinScheduler</a></h4><ul><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#_2">一、海豚调度介绍</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#_9">二、海豚调度特性</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#_29">三、建议配置</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#_44">四、名词解释</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#_71">五、模块介绍</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#_84">六、功能介绍</a></li><li><ul><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#1_86">1.项目首页</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#2_95">2.工作流定义</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#3_231">3.工作流实例</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#4_277">4.任务实例</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#5_297">5.任务定义</a></li></ul></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#_312">七、任务类型</a></li><li><ul><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#1SQL_314">1.SQL</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#2SPARK_355">2.SPARK节点</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#3Apache_Zeppelin_416">3.Apache Zeppelin</a></li></ul></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#_439">八、集群部署</a></li><li><ul><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#1_444">1.前置准备工作</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#2_DolphinScheduler__458">2.准备 DolphinScheduler 启动环境</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#3_495">3.修改相关配置</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#4_579">4.初始化数据库</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#5DolphinScheduler_586">5.登陆DolphinScheduler</a></li></ul></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#_616">九、架构设计</a></li><li><ul><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#1DolphinScheduler__619">1.DolphinScheduler 元数据文档</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#2_629">2.架构设计</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#3_672">3.架构设计思想</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#4_696">4.容错设计</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#5_719">5.任务失败重试</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#6_735">6.任务优先级设计</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#7Logbacknetty_747">7.Logback和netty实现日志访问</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#8_779">8.配置文件详解</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#9_800">9.负载均衡</a></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#10_854">10.缓存</a></li></ul></li><li><a href="https://blog.csdn.net/zhengzaifeidelushang/article/details/127841043#API_889">十、API调用</a></li></ul><h2 id="一、海豚调度介绍"><a href="#一、海豚调度介绍" class="headerlink" title="一、海豚调度介绍"></a>一、海豚调度介绍</h2><ul><li>Apache DolphinScheduler 是一个分布式易扩展的可视化DAG工作流任务调度开源系统。适用于企业级场景，提供了一个可视化操作任务、工作流和全生命周期数据处理过程的解决方案。</li><li>Apache DolphinScheduler 旨在解决复杂的大数据任务依赖关系，并为应用程序提供数据和各种 OPS 编排中的关系。 解决数据研发ETL依赖错综复杂，无法监控任务健康状态的问题。 DolphinScheduler 以 DAG（Directed Acyclic Graph，DAG）流式方式组装任务，可以及时监控任务的执行状态，支持重试、指定节点恢复失败、暂停、恢复、终止任务等操作。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/73308669cd14c42967405f5601104f84.png" alt="在这里插入图片描述"></p><h2 id="二、海豚调度特性"><a href="#二、海豚调度特性" class="headerlink" title="二、海豚调度特性"></a>二、海豚调度特性</h2><p>简单易用：</p><ul><li>可视化 DAG: 用户友好的，通过拖拽定义工作流的，运行时控制工具<br>模块化操作: 模块化有助于轻松定制和维护。</li><li>模块化操作: 模块化有助于轻松定制和维护。</li></ul><p>丰富的使用场景：</p><ul><li>支持多种任务类型: 支持Shell、MR、Spark、SQL等10余种任务类型，支持跨语言，易于扩展</li><li>丰富的工作流操作: 工作流程可以定时、暂停、恢复和停止，便于维护和控制全局和本地参数。</li></ul><p>High Reliability：</p><ul><li>高可靠性: 去中心化设计，确保稳定性。 原生 HA 任务队列支持，提供过载容错能力。 DolphinScheduler 能提供高度稳健的环境。</li></ul><p>High Scalability：</p><ul><li>高扩展性: 支持多租户和在线资源管理。支持每天10万个数据任务的稳定运行。</li></ul><h2 id="三、建议配置"><a href="#三、建议配置" class="headerlink" title="三、建议配置"></a>三、建议配置</h2><p>操作系统版本要求<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a63364c0d7ce6b57aec8b82a97e413a0.png" alt="在这里插入图片描述"><br>服务器建议配置<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f79fc9a1eedcf017df037dc5f505b9f1.png" alt="在这里插入图片描述"><br>网络要求</p><p>DolphinScheduler正常运行提供如下的网络端口配置：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b25fc9467c53696dd2c590c3496515dc.png" alt="在这里插入图片描述"><br>客户端Web浏览器要求</p><p>DolphinScheduler 推荐 Chrome 以及使用 Chromium 内核的较新版本浏览器访问前端可视化操作界面</p><h2 id="四、名词解释"><a href="#四、名词解释" class="headerlink" title="四、名词解释"></a>四、名词解释</h2><p>DAG： 全称 Directed Acyclic Graph，简称 DAG。<a href="https://so.csdn.net/so/search?q=%E5%B7%A5%E4%BD%9C%E6%B5%81&amp;spm=1001.2101.3001.7020">工作流</a>中的 Task 任务以有向无环图的形式组装起来，从入度为零的节点进行拓扑遍历，直到无后继节点为止。举例如下图：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1ff881c1ab13d5a1a91a75dae9e04c4f.png" alt="在这里插入图片描述"><br>流程定义：通过拖拽任务节点并建立任务节点的关联所形成的可视化DAG</p><p>流程实例：流程实例是流程定义的实例化，可以通过手动启动或定时调度生成。每运行一次流程定义，产生一个流程实例</p><p>任务实例：任务实例是流程定义中任务节点的实例化，标识着某个具体的任务</p><p>任务类型：目前支持有 SHELL、SQL、SUB_PROCESS(子流程)、PROCEDURE、MR、<a href="https://so.csdn.net/so/search?q=SPARK&amp;spm=1001.2101.3001.7020">SPARK</a>、PYTHON、DEPENDENT(依赖)，同时计划支持动态插件扩展，注意：其中 SUB_PROCESS类型的任务需要关联另外一个流程定义，被关联的流程定义是可以单独启动执行的</p><p>调度方式：系统支持基于 cron 表达式的定时调度和手动调度。命令类型支持：启动工作流、从当前节点开始执行、恢复被容错的工作流、恢复暂停流程、从失败节点开始执行、补数、定时、重跑、暂停、停止、恢复等待线程。 其中 恢复被容错的工作流 和 恢复等待线程 两种命令类型是由调度内部控制使用，外部无法调用</p><p>定时调度：系统采用 quartz 分布式调度器，并同时支持cron表达式可视化的生成</p><p>依赖：系统不单单支持 DAG 简单的前驱和后继节点之间的依赖，同时还提供任务依赖节点，支持流程间的自定义任务依赖</p><p>优先级 ：支持流程实例和任务实例的优先级，如果流程实例和任务实例的优先级不设置，则默认是先进先出</p><p>邮件告警：支持 SQL任务 查询结果邮件发送，流程实例运行结果邮件告警及容错告警通知</p><p>失败策略：对于并行运行的任务，如果有任务失败，提供两种失败策略处理方式，继续是指不管并行运行任务的状态，直到流程失败结束。结束是指一旦发现失败任务，则同时Kill掉正在运行的并行任务，流程失败结束</p><p>补数：补历史数据，支持区间并行和串行两种补数方式，其日期选择方式包括日期范围和日期枚举两种</p><h2 id="五、模块介绍"><a href="#五、模块介绍" class="headerlink" title="五、模块介绍"></a>五、模块介绍</h2><ul><li>dolphinscheduler-master master模块，提供工作流管理和编排服务。</li><li>dolphinscheduler-worker worker模块，提供任务执行管理服务。</li><li>dolphinscheduler-alert 告警模块，提供 AlertServer 服务。</li><li>dolphinscheduler-api web应用模块，提供 ApiServer 服务。</li><li>dolphinscheduler-common 通用的常量枚举、工具类、数据结构或者基类</li><li>dolphinscheduler-dao 提供数据库访问等操作。</li><li>dolphinscheduler-remote 基于 netty 的客户端、服务端</li><li>dolphinscheduler-service service模块，包含Quartz、Zookeeper、日志客户端访问服务，便于server模块和api模块调用</li><li>dolphinscheduler-ui 前端模块</li></ul><h2 id="六、功能介绍"><a href="#六、功能介绍" class="headerlink" title="六、功能介绍"></a>六、功能介绍</h2><h3 id="1-项目首页"><a href="#1-项目首页" class="headerlink" title="1.项目首页"></a>1.项目首页</h3><p>在项目管理页面点击项目名称链接，进入项目首页，如下图所示，项目首页包含该项目的任务状态统计、流程状态统计、工作流定义统计。这几个指标的说明如下</p><ul><li>任务状态统计：在指定时间范围内，统计任务实例中状态为提交成功、正在运行、准备暂停、暂停、准备停止、停止、失败、成功、需要容错、kill、等待线程的个数</li><li>流程状态统计：在指定时间范围内，统计工作流实例中状态为提交成功、正在运行、准备暂停、暂停、准备停止、停止、失败、成功、需要容错、kill、等待线程的个数</li><li>工作流定义统计：统计用户创建的工作流定义及管理员授予该用户的工作流定义</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c18db12576bdc1a0cece387cc776255a.png" alt="在这里插入图片描述"></p><h3 id="2-工作流定义"><a href="#2-工作流定义" class="headerlink" title="2.工作流定义"></a>2.工作流定义</h3><p>创建工作流定义</p><ul><li>点击项目管理-&gt;工作流-&gt;工作流定义，进入工作流定义页面，点击“创建工作流”按钮，进入工作流DAG编辑页面，如下图所示：</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6b40c0e149548e5274cab43195eebeb2.png" alt="在这里插入图片描述"><br>工具栏中拖拽 到画板中，新增一个Shell任务,如下图所示：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f3aa45d95e6adb290236c68339556645.png" alt="在这里插入图片描述"><br>添加Shell任务的参数设置：</p><ul><li>填写“节点名称”，“描述”，“脚本”字段；</li><li>“运行标志”勾选“正常”，若勾选“禁止执行”，运行工作流不会执行该任务；</li><li>选择“任务优先级”：当 worker 线程数不足时，级别高的任务在执行队列中会优先执行，相同优先级的任务按照先进先出的顺序执行；</li><li>超时告警（非必选）：勾选超时告警、超时失败，填写“超时时长”，当任务执行时间超过超时时长，会发送告警邮件并且任务超时失败；</li><li>资源（非必选）：资源文件是资源中心-&gt;文件管理页面创建或上传的文件，如文件名为 test.sh，脚本中调用资源命令为 sh test.sh。注意调用需要使用资源的全路径；</li><li>自定义参数（非必填）；</li><li>点击”确认添加”按钮，保存任务设置。</li></ul><p>配置任务之间的依赖关系：</p><ul><li>点击任务节点的右侧加号连接任务；如下图所示，任务 Node_B 和任务 Node_C 并行执行，当任务 Node_A 执行完，任务 Node_B、Node_C 会同时执行。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c5410926e46f484530dc8c131fddd3d3.png" alt="在这里插入图片描述"></p><p>实时任务的依赖关系：</p><ul><li>若DAG中包含了实时任务的组件，则实时任务的关联关系显示为虚线，在执行工作流实例的时候会跳过实时任务的执行</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/04bb4f801f41ecef68ea47ecb5565cd9.png" alt="在这里插入图片描述"><br>删除依赖关系：点击右上角”箭头”图标，选中连接线，点击右上角”删除”图标，删除任务间的依赖关系。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8f7f20f86a06c3e87c5e4b98caaa0209.png" alt="在这里插入图片描述"></p><p>保存工作流定义： 点击”保存“按钮，弹出”设置DAG图名称”弹框，如下图所示，输入工作流定义名称，工作流定义描述，设置全局参数（选填，参考全局参数），点击”添加”按钮，工作流定义创建成功。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/cb25b08d8234bfc06dc8a83b7f922e88.png" alt="在这里插入图片描述"><br>执行策略：</p><ul><li>并行：如果对于同一个工作流定义，同时有多个工作流实例，则并行执行工作流实例。</li><li>串行等待：如果对于同一个工作流定义，同时有多个工作流实例，则并行执行工作流实例。</li><li>串行抛弃：如果对于同一个工作流定义，同时有多个工作流实例，则抛弃后生成的工作流实例并杀掉正在跑的实例。</li><li>串行优先：如果对于同一个工作流定义，同时有多个工作流实例，则按照优先级串行执行工作流实例。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/508b4ede2ea714ed1d159f824d028511.png" alt="在这里插入图片描述"></p><p>工作流定义操作功能</p><p>点击项目管理-&gt;工作流-&gt;工作流定义，进入工作流定义页面，如下图所示:</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8bfa891f2cbd8723eee53f842d6adb04.png" alt="在这里插入图片描述"><br>工作流定义列表的操作功能如下：</p><ul><li>编辑： 只能编辑”下线”的工作流定义。工作流DAG编辑同创建工作流定义。</li><li>上线： 工作流状态为”下线”时，上线工作流，只有”上线”状态的工作流能运行，但不能编辑。</li><li>下线： 工作流状态为”上线”时，下线工作流，下线状态的工作流可以编辑，但不能运行。</li><li>运行： 只有上线的工作流能运行。运行操作步骤见运行工作流</li><li>定时： 只有上线的工作流能设置定时，系统自动定时调度工作流运行。创建定时后的状态为”下线”，需在定时管理页面上线定时才生效。定时操作步骤见工作流定时</li><li>定时管理： 定时管理页面可编辑、上线/下线、删除定时。</li><li>删除： 删除工作流定义。在同一个项目中，只能删除自己创建的工作流定义，其他用户的工作流定义不能进行删除，如果需要删除请联系创建用户或者管理员。</li><li>下载： 下载工作流定义到本地。</li><li>树形图： 以树形结构展示任务节点的类型及任务状态，如下图所示：</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/98640faeb8da88b262e8d2f0ebeda82c.png" alt="在这里插入图片描述"></p><p>运行工作流：</p><ul><li>点击项目管理-&gt;工作流-&gt;工作流定义，进入工作流定义页面，如下图所示，点击”上线”按钮，上线工作流。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/de06e961905ac28806773416aec2672c.png" alt="在这里插入图片描述"></p><ul><li>点击”运行“按钮，弹出启动参数设置弹框，如下图所示，设置启动参数，点击弹框中的”运行”按钮，工作流开始运行，工作流实例页面生成一条工作流实例。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4c2504423f5bcedb8259c07cdb8c6acd.png" alt="在这里插入图片描述"></p><p>工作流运行参数说明：</p><ul><li><p>失败策略：当某一个任务节点执行失败时，其他并行的任务节点需要执行的策略。”继续“表示：某一任务失败后，其他任务节点正常执行；”结束“表示：终止所有正在执行的任务，并终止整个流程。</p></li><li><p>通知策略：当流程结束，根据流程状态发送流程执行信息通知邮件，包含任何状态都不发，成功发，失败发，成功或失败都发。</p></li><li><p>流程优先级：流程运行的优先级，分五个等级：最高（HIGHEST），高(HIGH),中（MEDIUM）,低（LOW），最低（LOWEST）。当 master 线程数不足时，级别高的流程在执行队列中会优先执行，相同优先级的流程按照先进先出的顺序执行。</p></li><li><p>Worker 分组：该流程只能在指定的 worker 机器组里执行。默认是 Default，可以在任一 worker 上执行。</p></li><li><p>通知组：选择通知策略||超时报警||发生容错时，会发送流程信息或邮件到通知组里的所有成员。</p></li><li><p>启动参数: 在启动新的流程实例时，设置或覆盖全局参数的值。</p></li><li><p>补数：指运行指定日期范围内的工作流定义，根据补数策略生成对应的工作流实例，补数策略包括串行补数、并行补数 2 种模式。</p></li><li><p>日期可以通过页面选择或者手动输入，日期范围是左关右关区间(startDate &lt;= N &lt;= endDate)</p></li><li><p>串行补数：指定时间范围内，从开始日期至结束日期依次执行补数，依次生成多条流程实例；点击运行工作流，选择串行补数模式：例如从7月 9号到7月10号依次执行，依次在流程实例页面生成两条流程实例。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/af5298d4e4ec2e5aa78dd4866db177a0.png" alt="在这里插入图片描述"></p><ul><li>并行补数： 指定时间范围内，同时进行多天的补数，同时生成多条流程实例。手动输入日期：手动输入以逗号分割日期格式为 yyyy-MM-dd HH:mm:ss 的日期。点击运行工作流，选择并行补数模式：例如同时执行7月9号到7月10号的工作流定义，同时在流程实例页面生成两条流程实例(执行策略为串行时流程实例按照策略执行)。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/fd291e4f6189ecf1f051b45cc16146a0.png" alt="在这里插入图片描述"></li><li>并行度：是指在并行补数的模式下，最多并行执行的实例数。例如同时执行7月6号到7月10号的工作流定义，并行度为2，那么流程实例为：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f765c18656c1a2cb231d3f275d137c64.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/8fa0c4f1eb010479f3ef07e3fe3d0ea3.png" alt="在这里插入图片描述"></li><li>依赖模式：是否触发下游依赖节点依赖到当前工作流的工作流实例的补数（要求当前补数的工作流实例的定时状态为已上线，只会触发下游直接依赖到当前工作流的补数）。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/92aa2ae85252db22d081e0dff1e9ba18.png" alt="在这里插入图片描述"></p><p>日期选择：</p><ul><li><p>通过页面选择日期：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0247e869592b889fa9ac451a310f38d8.png" alt="在这里插入图片描述"></p></li><li><p>手动输入<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a9e3fb04b93e1220f0dba2f857c52cdd.png" alt="在这里插入图片描述"></p></li><li><p>补数与定时配置的关系：</p></li><li><p>未配置定时或已配置定时并定时状态下线：根据所选的时间范围结合定时默认配置(每天0点)进行补数，比如该工作流调度日期为7月7号到7月10号，流程实例为：</p></li><li><p>已配置定时并定时状态上线：根据所选的时间范围结合定时配置进行补数，比如该工作流调度日期为7月7号到7月10号，配置了定时（每日凌晨5点运行），流程实例为：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5067a3274cd10c11eb5940c8057038c4.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/d144802258237a78e2d31fc4d88620e1.png" alt="在这里插入图片描述"><br>单独运行任务</p></li><li><p>右键选中任务，点击”启动”按钮(只有已上线的任务才能点击运行)</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e4c73883c23f7a4647813561bf02ed51.png" alt="在这里插入图片描述"></p><ul><li>弹出启动参数设置弹框，参数说明同运行工作流</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1551907ad14f4dbb17baf6b34ab88fa4.png" alt="在这里插入图片描述"></p><p>工作流定时</p><ul><li>创建定时：点击项目管理-&gt;工作流-&gt;工作流定义，进入工作流定义页面，上线工作流，点击”定时”按钮,弹出定时参数设置弹框，如下图所示：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/74ec52771f4eb9f63a437963e3b1926c.png" alt="在这里插入图片描述"></li><li>选择起止时间。在起止时间范围内，定时运行工作流；不在起止时间范围内，不再产生定时工作流实例。</li><li>添加一个每隔 5 分钟执行一次的定时，如下图所示：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/26ee3005a6434d0a1a05b91e43b91c78.png" alt="在这里插入图片描述"></li><li>失败策略、通知策略、流程优先级、Worker 分组、通知组、收件人、抄送人同工作流运行参数。</li><li>点击”创建”按钮，创建定时成功，此时定时状态为”下线”，定时需上线才生效。</li><li>定时上线：点击”定时管理”按钮，进入定时管理页面，点击”上线”按钮，定时状态变为”上线”，如下图所示，工作流定时生效。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e5527f05e164c00154da1d47ccba83e6.png" alt="在这里插入图片描述"></p><p>导入工作流<br>点击项目管理-&gt;工作流-&gt;工作流定义，进入工作流定义页面，点击”导入工作流”按钮，导入本地工作流文件，工作流定义列表显示导入的工作流，状态为下线。</p><h3 id="3-工作流实例"><a href="#3-工作流实例" class="headerlink" title="3.工作流实例"></a>3.工作流实例</h3><p>查看工作流实例</p><ul><li>点击项目管理-&gt;工作流-&gt;工作流实例，进入工作流实例页面，如下图所示：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/96847a2b1034ddcba80c65500ef74f7f.png" alt="在这里插入图片描述"></li><li>点击工作流名称，进入DAG查看页面，查看任务执行状态，如下图所示。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c36f16d4849019282cb92593a1342b77.png" alt="在这里插入图片描述"></p><p>查看任务日志</p><ul><li>进入工作流实例页面，点击工作流名称，进入DAG查看页面，双击任务节点，如下图所示：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d919c6bf110f146b5b730e3d0b34ddfc.png" alt="在这里插入图片描述"></li><li>点击”查看日志”，弹出日志弹框，如下图所示,任务实例页面也可查看任务日志。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/40473f8a4be87fc7ae3d0e88f66b57bd.png" alt="在这里插入图片描述"></li></ul><p>查看任务历史记录</p><ul><li>点击项目管理-&gt;工作流-&gt;工作流实例，进入工作流实例页面，点击工作流名称，进入工作流 DAG 页面;</li><li>双击任务节点，如下图所示，点击”查看历史”，跳转到任务实例页面，并展示该工作流实例运行的任务实例列表</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e3c3bb852df23493bcbc33f24cb67d61.png" alt="在这里插入图片描述"><br>查看运行参数</p><ul><li>点击项目管理-&gt;工作流-&gt;工作流实例，进入工作流实例页面，点击工作流名称，进入工作流 DAG 页面;</li><li>点击左上角图标，查看工作流实例的启动参数；点击图标，查看工作流实例的全局参数和局部参数，如下图所示：</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/67742e4e8d8928d01e0ec07d5b89c789.png" alt="在这里插入图片描述"><br>工作流实例操作功能</p><ul><li>点击项目管理-&gt;工作流-&gt;工作流实例，进入工作流实例页面，如下图所示：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3448b062a28e1124d13f13f4d77a92d6.png" alt="在这里插入图片描述"></li><li>编辑： 只能编辑 成功/失败/停止 状态的流程。点击”编辑”按钮或工作流实例名称进入 DAG 编辑页面，编辑后点击”保存”按钮，弹出保存 DAG 弹框，如下图所示，修改流程定义信息，在弹框中勾选”是否更新工作流定义”，保存后则将实例修改的信息更新到工作流定义；若不勾选，则不更新工作流定义。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/db636feb857e7593a8bca33c46215991.png" alt="在这里插入图片描述"></p><ul><li>重跑： 重新执行已经终止的流程。</li><li>恢复失败： 针对失败的流程，可以执行恢复失败操作，从失败的节点开始执行。</li><li>停止： 对正在运行的流程进行停止操作，后台会先 kill worker 进程,再执行 kill -9 操作</li><li>暂停： 对正在运行的流程进行暂停操作，系统状态变为等待执行，会等待正在执行的任务结束，暂停下一个要执行的任务。</li><li>恢复暂停： 对暂停的流程恢复，直接从暂停的节点开始运行</li><li>删除： 删除工作流实例及工作流实例下的任务实例</li><li>甘特图： Gantt 图纵轴是某个工作流实例下的任务实例的拓扑排序，横轴是任务实例的运行时间,如图示：</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/24fa4cba21eaa9911fb2cdaf420ef103.png" alt="在这里插入图片描述"></p><h3 id="4-任务实例"><a href="#4-任务实例" class="headerlink" title="4.任务实例"></a>4.任务实例</h3><p>批量任务实例</p><ul><li>点击项目管理-&gt;工作流-&gt;任务实例，进入任务实例页面，如下图所示，点击工作流实例名称，可跳转到工作流实例DAG图查看任务状态。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b045cf720f20292a419ee2e16675e156.png" alt="在这里插入图片描述"></p><ul><li>查看日志：点击操作列中的“查看日志”按钮，可以查看任务执行的日志情况。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c425e7e595c4000d7b4bff52b7b48a0.png" alt="在这里插入图片描述"></p><p>实时任务实例</p><ul><li>切换到实时任务实例页面，如下图所示：</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f40ede7c8cdb7b66b7d603821ddd161a.png" alt="在这里插入图片描述"></p><ul><li>SavePoint：点击操作列中的SavePoint按钮，可以进行实时任务的SavePoint。</li><li>Stop：点击操作列中的Stop按钮，可以停止该实时任务。</li></ul><h3 id="5-任务定义"><a href="#5-任务定义" class="headerlink" title="5.任务定义"></a>5.任务定义</h3><p>批量任务定义</p><ul><li>批量任务定义允许您在基于任务级别而不是在工作流中操作修改任务。再此之前，我们已经有了工作流级别的任务编辑器，你可以在工作流定义 单击特定的工作流，然后编辑任务的定义。当您想编辑特定的任务定义但不记得它属于哪个工作流时，这是令人沮丧的。所以我们决定在 任务 菜单下添加 任务定义视图。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a3ebd5567b66d4e06b8d7f2c091293e1.png" alt="在这里插入图片描述"><br>在该视图中，您可以通过单击 操作 列中的相关按钮来进行创建、查询、更新、删除任务定义。最令人兴奋的是您可以通过通配符进行全部任务查询，当您只 记得任务名称但忘记它属于哪个工作流时是非常有用的。也支持通过任务名称结合使用 任务类型 或 工作流程名称 进行查询。</li></ul><p>实时任务定义</p><ul><li>实时任务定义在工作流定义中创建，在任务定义页面可以进行修改和执行。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/42166f7ae23da914104e764f69eee79f.png" alt="在这里插入图片描述"><br>点击实时任务执行，检查执行参数后点击确认，即可提交实时任务。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/100802dd50ac90f2af87ef184d70af2f.png" alt="在这里插入图片描述"></p><h2 id="七、任务类型"><a href="#七、任务类型" class="headerlink" title="七、任务类型"></a>七、任务类型</h2><h3 id="1-SQL"><a href="#1-SQL" class="headerlink" title="1.SQL"></a>1.SQL</h3><p>SQL任务类型，用于连接数据库并执行相应SQL。</p><p>创建数据源：</p><ul><li>数据源中心支持MySQL、POSTGRESQL、HIVE/IMPALA、SPARK、CLICKHOUSE、ORACLE、SQLSERVER等数据源。</li><li>点击”数据源中心-&gt;创建数据源”，根据需求创建不同类型的数据源<br>点击”测试连接”，测试数据源是否可以连接成功（只有当数据源通过连接性测试后才能保存数据源）。</li></ul><p>创建任务：</p><ul><li>点击项目管理-项目名称-工作流定义，点击”创建工作流”按钮，进入DAG编辑页面。</li><li>工具栏中拖动 到画板中，选择需要连接的数据源，即可完成创建。</li></ul><p>任务参数：</p><ul><li>sql类型：支持查询和非查询两种。<br>查询：支持 DML select 类型的命令，是有结果集返回的，可以指定邮件通知为表格、附件或表格附件三种模板；<br>非查询：支持 DDL全部命令 和 DML update、delete、insert 三种类型的命令；<br>分段执行符号：提供在数据源不支持一次执行多段SQL语句时，拆分SQL语句的符号来进行多次调用数据源执行方法。 例子：1.当数据源选择Hive数据源时，不需要填写此参数。因为Hive数据源本身支持一次执行多段SQL语句； 2.当数据源选择MySQL数据源时，并且要执行多段SQL语句时，需要填写此参数为分号 ;。因为MySQL数据源不支持一次执行多段SQL语句；</li><li>sql参数：输入参数格式为key1=value1;key2=value2…</li><li>sql语句：SQL语句</li><li>UDF函数：对于HIVE类型的数据源，可以引用资源中心中创建的UDF函数，其他类型的数据源暂不支持UDF函数。</li><li>自定义参数：SQL任务类型，而存储过程是自定义参数顺序，给方法设置值自定义参数类型和数据类型，同存储过程任务类型一样。区别在于SQL任务类型自定义参数会替换sql语句中${变量}。</li><li>前置sql:前置sql在sql语句之前执行。</li><li>后置sql:后置sql在sql语句之后执行。</li></ul><p>任务样例<br>Hive表创建示例<br>在hive中创建临时表并写入数据</p><p>该样例向hive中创建临时表tmp_hello_world并写入一行数据。选择SQL类型为非查询，在创建临时表之前需要确保该表不存在，所以我们使用自定义参数，在每次运行时获取当天时间作为表名后缀，这样这个任务就可以每天运行。创建的表名格式为：tmp_hello_world_{yyyyMMdd}。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c7832a1e451a571aaa3cd924f0e19e0.png" alt="在这里插入图片描述"><br>运行该任务成功之后在hive中查询结果<br>登录集群使用hive命令或使用beeline、JDBC等方式连接apache hive进行查询，查询SQL为select * from tmp_hello_world_{yyyyMMdd}，请将{yyyyMMdd}替换为运行当天的日期，查询截图如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/85a380b5671333d264e0a6e6fd88b8c8.png" alt="在这里插入图片描述"><br>使用前置sql和后置sql示例<br>在前置sql中执行建表操作，在sql语句中执行操作，在后置sql中执行清理操作<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f19a9a1340c461d2e378d62ec71442cb.png" alt="在这里插入图片描述"></p><h3 id="2-SPARK节点"><a href="#2-SPARK节点" class="headerlink" title="2.SPARK节点"></a>2.SPARK节点</h3><p>Spark 任务类型用于执行 Spark 应用。对于 Spark 节点，worker 支持两个不同类型的 spark 命令提交任务：</p><p>(1) spark submit 方式提交任务。</p><p>(2) spark sql 方式提交任务。</p><p>创建任务：</p><ul><li>点击项目管理 -&gt; 项目名称 -&gt; 工作流定义，点击”创建工作流”按钮，进入 DAG 编辑页面：</li><li>拖动工具栏的 任务节点到画板中。</li></ul><p>任务参数：</p><ul><li>默认参数说明请参考DolphinScheduler任务参数附录。</li><li>程序类型：支持 Java、Scala、Python 和 SQL 四种语言。</li><li>Spark 版本：支持 Spark1 和 Spark2。</li><li>主函数的 Class：Spark 程序的入口 Main class 的全路径。</li><li>主程序包：执行 Spark 程序的 jar 包（通过资源中心上传）。</li><li>SQL脚本：Spark sql 运行的 .sql 文件中的 SQL 语句。</li><li>部署方式：(1) spark submit 支持 yarn-clusetr、yarn-client 和 local 三种模式。 (2) spark sql 支持 yarn-client 和 local 两种模式。</li><li>任务名称（可选）：Spark 程序的名称。</li><li>Driver 核心数：用于设置 Driver 内核数，可根据实际生产环境设置对应的核心数。</li><li>Driver 内存数：用于设置 Driver 内存数，可根据实际生产环境设置对应的内存数。</li><li>Executor 数量：用于设置 Executor 的数量，可根据实际生产环境设置对应的内存数。</li><li>Executor 内存数：用于设置 Executor 内存数，可根据实际生产环境设置对应的内存数。</li><li>主程序参数：设置 Spark 程序的输入参数，支持自定义参数变量的替换。</li><li>选项参数：支持 —jar、–files、–archives、–conf 格式。</li><li>资源：如果其他参数中引用了资源文件，需要在资源中选择指定。</li><li>自定义参数：是 Spark 局部的用户自定义参数，会替换脚本中以 ${变量} 的内容。</li></ul><p>任务样例</p><p>spark submit<br>执行 WordCount 程序<br>本案例为大数据生态中常见的入门案例，常应用于 MapReduce、Flink、Spark 等计算框架。主要为统计输入的文本中，相同的单词的数量有多少。</p><p>在 DolphinScheduler 中配置 Spark 环境<br>若生产环境中要是使用到 Spark 任务类型，则需要先配置好所需的环境。配置文件如下：bin/env/dolphinscheduler_env.sh。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dab6ce119c0bb6c2ae212cbf656615c7.png" alt="在这里插入图片描述"><br>上传主程序包<br>在使用 Spark 任务节点时，需要利用资源中心上传执行程序的 jar 包。<br>当配置完成资源中心之后，直接使用拖拽的方式，即可上传所需目标文件。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/64a51d1576d5b0ca4f1ee016db487c34.png" alt="在这里插入图片描述"><br>配置 Spark 节点<br>根据上述参数说明，配置所需的内容即可。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ba0f1cc703fd187feac53bcfe9f6c796.png" alt="在这里插入图片描述"><br>spark sql<br>执行 DDL 和 DML 语句<br>本案例为创建一个视图表 terms 并写入三行数据和一个格式为 parquet 的表 wc 并判断该表是否存在。程序类型为 SQL。将视图表 terms 的数据插入到格式为 parquet 的表 wc。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e3372a1a95ae39ddffa5886e62e08402.png" alt="在这里插入图片描述"><br>注意：</p><p>JAVA 和 Scala 只用于标识，使用 Spark 任务时没有区别。如果应用程序是由 Python 开发的，那么可以忽略表单中的参数Main Class。参数SQL脚本仅适用于 SQL 类型，在 JAVA、Scala 和 Python 中可以忽略。</p><p>SQL 目前不支持 cluster 模式。</p><h3 id="3-Apache-Zeppelin"><a href="#3-Apache-Zeppelin" class="headerlink" title="3.Apache Zeppelin"></a>3.Apache Zeppelin</h3><p>Zeppelin任务类型，用于创建并执行Zeppelin类型任务。worker 执行该任务的时候，会通过Zeppelin Cient API触发Zeppelin Notebook Paragraph。</p><p>创建任务</p><ul><li>点击项目管理-项目名称-工作流定义，点击”创建工作流”按钮，进入DAG编辑页面。</li><li>工具栏中拖动 到画板中，即可完成创建。</li></ul><p>任务参数</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fb88a86059b5767fa7ff3cecba6ba2f9.png" alt="在这里插入图片描述"><br>生产（克隆）模式</p><ul><li>填上Zeppelin Production Note Directory参数以启动生产模式。</li><li>在生产模式下，目标note会被克隆到您所填的Zeppelin Production Note Directory目录下。 Zeppelin任务插件将会执行克隆出来的note并在执行成功后自动清除它。 因为在此模式下，如果您不小心修改了正在被Dolphin Scheduler调度的note，也不会影响到生产任务的执行， 从而提高了稳定性。</li><li>如果您选择不填Zeppelin Production Note Directory这个参数，Zeppelin任务插件将会执行您的原始note。 ‘Zeppelin Production Note Directory’参数在格式上应该以斜杠开头和结尾，例如 /production_note_directory/。</li></ul><p>任务样例<br>Zeppelin Paragraph 任务样例<br>这个示例展示了如何创建Zeppelin Paragraph任务节点：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b2015a9e32e4bb0016184a7fae020cc7.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9cedee2f23000e81f1cbcb610421eeb5.png" alt="在这里插入图片描述"></p><h2 id="八、集群部署"><a href="#八、集群部署" class="headerlink" title="八、集群部署"></a>八、集群部署</h2><p>集群部署目的是在多台机器部署 DolphinScheduler 服务，用于运行大量任务情况。</p><p>集群部署(Cluster)使用的脚本和配置文件与伪集群部署中的配置一样，所以所需要的步骤也与伪集群部署大致一样。区别就是伪集群部署针对的是一台机器，而集群部署(Cluster)需要针对多台机器，且两者“修改相关配置”步骤区别较大</p><h3 id="1-前置准备工作"><a href="#1-前置准备工作" class="headerlink" title="1.前置准备工作"></a>1.前置准备工作</h3><ul><li><p>JDK：下载JDK (1.8+)，安装并配置 JAVA_HOME 环境变量，并将其下的 bin 目录追加到 PATH 环境变量中。如果你的环境中已存在，可以跳过这步。</p></li><li><p>二进制包：在下载页面下载 DolphinScheduler 二进制包</p></li><li><p>数据库：PostgreSQL (8.2.15+) 或者 MySQL (5.7+)，两者任选其一即可，如 MySQL 则需要 JDBC Driver 8.0.16</p></li><li><p>注册中心：ZooKeeper (3.4.6+)，下载地址</p></li><li><p>进程树分析</p></li><li><p>macOS安装pstree</p></li><li><p>Fedora/Red/Hat/CentOS/Ubuntu/Debian安装psmisc</p></li></ul><p>注意: DolphinScheduler 本身不依赖 Hadoop、Hive、Spark，但如果你运行的任务需要依赖他们，就需要有对应的环境支持</p><h3 id="2-准备-DolphinScheduler-启动环境"><a href="#2-准备-DolphinScheduler-启动环境" class="headerlink" title="2.准备 DolphinScheduler 启动环境"></a>2.准备 DolphinScheduler 启动环境</h3><p><strong>配置用户免密及权限</strong><br>创建部署用户，并且一定要配置 sudo 免密。以创建 dolphinscheduler 用户为例</p><pre><code># 创建用户需使用 root 登录useradd dolphinscheduler# 添加密码echo &quot;dolphinscheduler&quot; | passwd --stdin dolphinscheduler# 配置 sudo 免密sed -i &#39;$adolphinscheduler  ALL=(ALL)  NOPASSWD: NOPASSWD: ALL&#39; /etc/sudoerssed -i &#39;s/Defaults    requirett/#Defaults    requirett/g&#39; /etc/sudoers# 修改目录权限，使得部署用户对二进制包解压后的 apache-dolphinscheduler-*-bin 目录有操作权限chown -R dolphinscheduler:dolphinscheduler apache-dolphinscheduler-*-bin</code></pre><p><strong>配置机器SSH免密登陆</strong><br>由于安装的时候需要向不同机器发送资源，所以要求各台机器间能实现SSH免密登陆。配置免密登陆的步骤如下</p><pre><code>su dolphinschedulerssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsacat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 600 ~/.ssh/authorized_keys</code></pre><p>注意: 配置完成后，可以通过运行命令 ssh localhost 判断是否成功，如果不需要输入密码就能ssh登陆则证明成功</p><p><strong>启动zookeeper</strong><br>进入 zookeeper 的安装目录，将 zoo_sample.cfg 配置文件复制到 conf/zoo.cfg，并将 conf/zoo.cfg 中 dataDir 中的值改成 dataDir=./tmp/zookeeper</p><pre><code># 启动 zookeeper./bin/zkServer.sh start</code></pre><h3 id="3-修改相关配置"><a href="#3-修改相关配置" class="headerlink" title="3.修改相关配置"></a>3.修改相关配置</h3><p>完成基础环境的准备后，需要根据你的机器环境修改配置文件。配置文件可以在目录 bin/env 中找到，他们分别是 并命名为 install_env.sh 和 dolphinscheduler_env.sh。</p><p><strong>修改 install_env.sh 文件</strong><br>文件 install_env.sh 描述了哪些机器将被安装 DolphinScheduler 以及每台机器对应安装哪些服务。您可以在路径 bin/env/install_env.sh 中找到此文件，可通过以下方式更改env变量,export <ENV\_NAME>=，配置详情如下。</p><pre><code># ---------------------------------------------------------# INSTALL MACHINE# ---------------------------------------------------------# Due to the master, worker, and API server being deployed on a single node, the IP of the server is the machine IP or localhostips=&quot;localhost&quot;sshPort=&quot;22&quot;masters=&quot;localhost&quot;workers=&quot;localhost:default&quot;alertServer=&quot;localhost&quot;apiServers=&quot;localhost&quot;# DolphinScheduler installation path, it will auto-create if not existsinstallPath=~/dolphinscheduler# Deploy user, use the user you create in section **Configure machine SSH password-free login**deployUser=&quot;dolphinscheduler&quot;</code></pre><p><strong>修改 dolphinscheduler_env.sh 文件</strong><br>文件 ./bin/env/dolphinscheduler_env.sh 描述了下列配置：</p><ul><li>DolphinScheduler 的数据库配置，详细配置方法见初始化数据库</li><li>一些任务类型外部依赖路径或库文件，如 JAVA_HOME 和 SPARK_HOME都是在这里定义的</li><li>注册中心zookeeper</li><li>服务端相关配置，比如缓存，时区设置等</li></ul><p>如果您不使用某些任务类型，您可以忽略任务外部依赖项，但您必须根据您的环境更改 JAVA_HOME、注册中心和数据库相关配置。</p><pre><code># JAVA_HOME, will use it to start DolphinScheduler serverexport JAVA_HOME=$&#123;JAVA_HOME:-/opt/soft/java&#125;# Database related configuration, set database type, username and passwordexport DATABASE=$&#123;DATABASE:-postgresql&#125;export SPRING_PROFILES_ACTIVE=$&#123;DATABASE&#125;export SPRING_DATASOURCE_URL=&quot;jdbc:postgresql://127.0.0.1:5432/dolphinscheduler&quot;export SPRING_DATASOURCE_USERNAME=&#123;user&#125;export SPRING_DATASOURCE_PASSWORD=&#123;password&#125;# DolphinScheduler server related configurationexport SPRING_CACHE_TYPE=$&#123;SPRING_CACHE_TYPE:-none&#125;export SPRING_JACKSON_TIME_ZONE=$&#123;SPRING_JACKSON_TIME_ZONE:-UTC&#125;export MASTER_FETCH_COMMAND_NUM=$&#123;MASTER_FETCH_COMMAND_NUM:-10&#125;# Registry center configuration, determines the type and link of the registry centerexport REGISTRY_TYPE=$&#123;REGISTRY_TYPE:-zookeeper&#125;export REGISTRY_ZOOKEEPER_CONNECT_STRING=$&#123;REGISTRY_ZOOKEEPER_CONNECT_STRING:-localhost:2181&#125;# Tasks related configurations, need to change the configuration if you use the related tasks.export HADOOP_HOME=$&#123;HADOOP_HOME:-/opt/soft/hadoop&#125;export HADOOP_CONF_DIR=$&#123;HADOOP_CONF_DIR:-/opt/soft/hadoop/etc/hadoop&#125;export SPARK_HOME1=$&#123;SPARK_HOME1:-/opt/soft/spark1&#125;export SPARK_HOME2=$&#123;SPARK_HOME2:-/opt/soft/spark2&#125;export PYTHON_HOME=$&#123;PYTHON_HOME:-/opt/soft/python&#125;export HIVE_HOME=$&#123;HIVE_HOME:-/opt/soft/hive&#125;export FLINK_HOME=$&#123;FLINK_HOME:-/opt/soft/flink&#125;export DATAX_HOME=$&#123;DATAX_HOME:-/opt/soft/datax&#125;export PATH=$HADOOP_HOME/bin:$SPARK_HOME1/bin:$SPARK_HOME2/bin:$PYTHON_HOME/bin:$JAVA_HOME/bin:$HIVE_HOME/bin:$FLINK_HOME/bin:$DATAX_HOME/bin:$PATH</code></pre><p>这个是与伪集群部署差异较大的一步，因为部署脚本会通过 scp 的方式将安装需要的资源传输到各个机器上，所以这一步我们仅需要修改运行install.sh脚本的所在机器的配置即可。配置文件在路径在bin/env/install_env.sh下，此处我们仅需修改INSTALL MACHINE，DolphinScheduler ENV、Database、Registry Server与伪集群部署保持一致，下面对必须修改参数进行说明</p><pre><code># ---------------------------------------------------------# INSTALL MACHINE# ---------------------------------------------------------# 需要配置master、worker、API server，所在服务器的IP均为机器IP或者localhost# 如果是配置hostname的话，需要保证机器间可以通过hostname相互链接# 如下图所示，部署 DolphinScheduler 机器的 hostname 为 ds1,ds2,ds3,ds4,ds5，其中 ds1,ds2 安装 master 服务，ds3,ds4,ds5安装 worker 服务，alert server安装在ds4中，api server 安装在ds5中ips=&quot;ds1,ds2,ds3,ds4,ds5&quot;masters=&quot;ds1,ds2&quot;workers=&quot;ds3:default,ds4:default,ds5:default&quot;alertServer=&quot;ds4&quot;apiServers=&quot;ds5&quot;</code></pre><h3 id="4-初始化数据库"><a href="#4-初始化数据库" class="headerlink" title="4.初始化数据库"></a>4.初始化数据库</h3><p>启动 DolphinScheduler<br>使用上面创建的部署用户运行以下命令完成部署，部署后的运行日志将存放在 logs 文件夹内</p><pre><code>bash ./bin/install.sh</code></pre><h3 id="5-登陆DolphinScheduler"><a href="#5-登陆DolphinScheduler" class="headerlink" title="5.登陆DolphinScheduler"></a>5.登陆DolphinScheduler</h3><p>启停服务</p><pre><code># 一键停止集群所有服务bash ./bin/stop-all.sh# 一键开启集群所有服务bash ./bin/start-all.sh# 启停 Masterbash ./bin/dolphinscheduler-daemon.sh stop master-serverbash ./bin/dolphinscheduler-daemon.sh start master-server# 启停 Workerbash ./bin/dolphinscheduler-daemon.sh start worker-serverbash ./bin/dolphinscheduler-daemon.sh stop worker-server# 启停 Apibash ./bin/dolphinscheduler-daemon.sh start api-serverbash ./bin/dolphinscheduler-daemon.sh stop api-server# 启停 Alertbash ./bin/dolphinscheduler-daemon.sh start alert-serverbash ./bin/dolphinscheduler-daemon.sh stop alert-server</code></pre><p>注意1:: 每个服务在路径 /conf/dolphinscheduler_env.sh 中都有 dolphinscheduler_env.sh 文件，这是可以为微 服务需求提供便利。意味着您可以基于不同的环境变量来启动各个服务，只需要在对应服务中配置 /conf/dolphinscheduler_env.sh 然后通过 /bin/start.sh 命令启动即可。但是如果您使用命令 /bin/dolphinscheduler-daemon.sh start 启动服务器，它将会用文件 bin/env/dolphinscheduler_env.sh 覆盖 /conf/dolphinscheduler_env.sh 然后启动服务，目的是为了减少用户修改配置的成本.</p><p>注意2:：服务用途请具体参见《系统架构设计》小节。Python gateway service 默认与 api-server 一起启动，如果您不想启动 Python gateway service 请通过更改 api-server 配置文件 api-server/conf/application.yaml 中的 python-gateway.enabled : false 来禁用它。</p><h2 id="九、架构设计"><a href="#九、架构设计" class="headerlink" title="九、架构设计"></a>九、架构设计</h2><h3 id="1-DolphinScheduler-元数据文档"><a href="#1-DolphinScheduler-元数据文档" class="headerlink" title="1.DolphinScheduler 元数据文档"></a>1.DolphinScheduler 元数据文档</h3><ul><li>一个租户下可以有多个用户；</li><li>一个用户可以有多个项目</li><li>一个项目可以有多个工作流定义，每个工作流定义只属于一个项目；</li><li>一个租户可以被多个工作流定义使用，每个工作流定义必须且只能选择一个租户；</li><li>一个工作流定义可以有一个或多个定时的配置；</li><li>一个工作流定义对应多个任务定义</li><li>一个工作流定义可以有多个工作流实例，一个工作流实例对应一个或多个任务实例</li></ul><h3 id="2-架构设计"><a href="#2-架构设计" class="headerlink" title="2.架构设计"></a>2.架构设计</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/000b9fca165c97ff932fec9c13c3fb10.png" alt="在这里插入图片描述"><br>架构说明</p><p>MasterServer</p><ul><li>MasterServer采用分布式无中心设计理念，MasterServer主要负责 DAG 任务切分、任务提交监控，并同时监听其它MasterServer和WorkerServer的健康状态。 MasterServer服务启动时向Zookeeper注册临时节点，通过监听Zookeeper临时节点变化来进行容错处理。 MasterServer基于netty提供监听服务。</li></ul><p>该服务内主要包含:</p><ul><li>DistributedQuartz分布式调度组件，主要负责定时任务的启停操作，当quartz调起任务后，Master内部会有线程池具体负责处理任务的后续操作；</li><li>MasterSchedulerService是一个扫描线程，定时扫描数据库中的t_ds_command表，根据不同的命令类型进行不同的业务操作；</li><li>WorkflowExecuteRunnable主要是负责DAG任务切分、任务提交监控、各种不同事件类型的逻辑处理；</li><li>TaskExecuteRunnable主要负责任务的处理和持久化，并生成任务事件提交到工作流的事件队列；</li><li>EventExecuteService主要负责工作流实例的事件队列的轮询；</li><li>StateWheelExecuteThread主要负责工作流和任务超时、任务重试、任务依赖的轮询，并生成对应的工作流或任务事件提交到工作流的事件队列；</li><li>FailoverExecuteThread主要负责Master容错和Worker容错的相关逻辑；</li></ul><p>WorkerServer：<br>WorkerServer也采用分布式无中心设计理念，WorkerServer主要负责任务的执行和提供日志服务。 WorkerServer服务启动时向Zookeeper注册临时节点，并维持心跳。 WorkerServer基于netty提供监听服务。</p><p>该服务包含：</p><ul><li>WorkerManagerThread主要负责任务队列的提交，不断从任务队列中领取任务，提交到线程池处理；</li><li>TaskExecuteThread主要负责任务执行的流程，根据不同的任务类型进行任务的实际处理；</li><li>RetryReportTaskStatusThread主要负责定时轮询向Master汇报任务的状态，直到Master回复状态的ack，避免任务状态丢失；</li></ul><p>ZooKeeper：</p><ul><li>ZooKeeper服务，系统中的MasterServer和WorkerServer节点都通过ZooKeeper来进行集群管理和容错。另外系统还基于ZooKeeper进行事件监听和分布式锁。 我们也曾经基于Redis实现过队列，不过我们希望DolphinScheduler依赖到的组件尽量地少，所以最后还是去掉了Redis实现。</li></ul><p>AlertServer：</p><ul><li>提供告警服务，通过告警插件的方式实现丰富的告警手段。</li></ul><p>ApiServer：</p><ul><li>API接口层，主要负责处理前端UI层的请求。该服务统一提供RESTful api向外部提供请求服务。</li></ul><p>UI：</p><ul><li>系统的前端页面，提供系统的各种可视化操作界面。</li></ul><h3 id="3-架构设计思想"><a href="#3-架构设计思想" class="headerlink" title="3.架构设计思想"></a>3.架构设计思想</h3><p>去中心化vs中心化</p><p>中心化思想<br>中心化的设计理念比较简单，分布式集群中的节点按照角色分工，大体上分为两种角色：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a24c780569caaf75d2c181bb5bf65f96.png" alt="在这里插入图片描述"></p><ul><li>Master的角色主要负责任务分发并监督Slave的健康状态，可以动态的将任务均衡到Slave上，以致Slave节点不至于“忙死”或”闲死”的状态。</li><li>Worker的角色主要负责任务的执行工作并维护和Master的心跳，以便Master可以分配任务给Slave。</li></ul><p>中心化思想设计存在的问题：</p><ul><li>一旦Master出现了问题，则群龙无首，整个集群就会崩溃。为了解决这个问题，大多数Master/Slave架构模式都采用了主备Master的设计方案，可以是热备或者冷备，也可以是自动切换或手动切换，而且越来越多的新系统都开始具备自动选举切换Master的能力,以提升系统的可用性。</li><li>另外一个问题是如果Scheduler在Master上，虽然可以支持一个DAG中不同的任务运行在不同的机器上，但是会产生Master的过负载。如果Scheduler在Slave上，则一个DAG中所有的任务都只能在某一台机器上进行作业提交，则并行任务比较多的时候，Slave的压力可能会比较大。</li></ul><p>去中心化：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/bda39c6cbff5bb081d50995e2f6d5227.png" alt="在这里插入图片描述"></p><ul><li>在去中心化设计里，通常没有Master/Slave的概念，所有的角色都是一样的，地位是平等的，全球互联网就是一个典型的去中心化的分布式系统，联网的任意节点设备down机，都只会影响很小范围的功能。</li><li>去中心化设计的核心设计在于整个分布式系统中不存在一个区别于其他节点的”管理者”，因此不存在单点故障问题。但由于不存在” 管理者”节点所以每个节点都需要跟其他节点通信才得到必须要的机器信息，而分布式系统通信的不可靠性，则大大增加了上述功能的实现难度。</li><li>实际上，真正去中心化的分布式系统并不多见。反而动态中心化分布式系统正在不断涌出。在这种架构下，集群中的管理者是被动态选择出来的，而不是预置的，并且集群在发生故障的时候，集群的节点会自发的举行”会议”来选举新的”管理者”去主持工作。最典型的案例就是ZooKeeper及Go语言实现的Etcd。</li><li>DolphinScheduler的去中心化是Master/Worker注册心跳到Zookeeper中，Master基于slot处理各自的Command，通过selector分发任务给worker，实现Master集群和Worker集群无中心。</li></ul><h3 id="4-容错设计"><a href="#4-容错设计" class="headerlink" title="4.容错设计"></a>4.容错设计</h3><p>容错分为服务宕机容错和任务重试，服务宕机容错又分为Master容错和Worker容错两种情况</p><p>宕机容错<br>服务容错设计依赖于ZooKeeper的Watcher机制，实现原理如图：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d109a4a9def753845c2879410f17ac0d.png" alt="在这里插入图片描述"><br>其中Master监控其他Master和Worker的目录，如果监听到remove事件，则会根据具体的业务逻辑进行流程实例容错或者任务实例容错。</p><ul><li>Master容错流程：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c84335efdfbb0bb210d2ae7fa7d64cd8.png" alt="在这里插入图片描述"><br>容错范围：从host的维度来看，Master的容错范围包括：自身host+注册中心上不存在的节点host，容错的整个过程会加锁；</li></ul><p>容错内容：Master的容错内容包括：容错工作流实例和任务实例，在容错前会比较实例的开始时间和服务节点的启动时间，在服务启动时间之后的则跳过容错；</p><p>容错后处理：ZooKeeper Master容错完成之后则重新由DolphinScheduler中Scheduler线程调度，遍历 DAG 找到”正在运行”和“提交成功”的任务，对”正在运行”的任务监控其任务实例的状态，对”提交成功”的任务需要判断Task Queue中是否已经存在，如果存在则同样监控任务实例的状态，如果不存在则重新提交任务实例。</p><ul><li>Worker容错流程：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4d84245039802b097b9b0b9958d59a9d.png" alt="在这里插入图片描述"></li><li>容错范围：从工作流实例的维度看，每个Master只负责容错自己的工作流实例；只有在handleDeadServer时会加锁；</li><li>容错内容：当发送Worker节点的remove事件时，Master只容错任务实例，在容错前会比较实例的开始时间和服务节点的启动时间，在服务启动时间之后的则跳过容错；</li><li>容错后处理：Master Scheduler线程一旦发现任务实例为” 需要容错”状态，则接管任务并进行重新提交。</li><li>注意：由于” 网络抖动”可能会使得节点短时间内失去和ZooKeeper的心跳，从而发生节点的remove事件。对于这种情况，我们使用最简单的方式，那就是节点一旦和ZooKeeper发生超时连接，则直接将Master或Worker服务停掉。</li></ul><h3 id="5-任务失败重试"><a href="#5-任务失败重试" class="headerlink" title="5.任务失败重试"></a>5.任务失败重试</h3><p>这里首先要区分任务失败重试、流程失败恢复、流程失败重跑的概念：</p><ul><li>任务失败重试是任务级别的，是调度系统自动进行的，比如一个Shell任务设置重试次数为3次，那么在Shell任务运行失败后会自己再最多尝试运行3次</li><li>流程失败恢复是流程级别的，是手动进行的，恢复是从只能从失败的节点开始执行或从当前节点开始执行</li><li>流程失败重跑也是流程级别的，是手动进行的，重跑是从开始节点进行</li></ul><p>接下来说正题，我们将工作流中的任务节点分了两种类型。</p><ul><li>一种是业务节点，这种节点都对应一个实际的脚本或者处理语句，比如Shell节点、SQL节点、Spark节点等。</li><li>还有一种是逻辑节点，这种节点不做实际的脚本或语句处理，只是整个流程流转的逻辑处理，比如依赖节点、子流程节点等。</li></ul><p>业务节点都可以配置失败重试的次数，当该任务节点失败，会自动重试，直到成功或者超过配置的重试次数。逻辑节点不支持失败重试。</p><p>如果工作流中有任务失败达到最大重试次数，工作流就会失败停止，失败的工作流可以手动进行重跑操作或者流程恢复操作。</p><h3 id="6-任务优先级设计"><a href="#6-任务优先级设计" class="headerlink" title="6.任务优先级设计"></a>6.任务优先级设计</h3><p>在早期调度设计中，如果没有优先级设计，采用公平调度设计的话，会遇到先行提交的任务可能会和后继提交的任务同时完成的情况，而不能做到设置流程或者任务的优先级，因此我们对此进行了重新设计，目前我们设计如下：</p><ul><li>按照不同流程实例优先级优先于同一个流程实例优先级优先于同一流程内任务优先级优先于同一流程内任务提交顺序依次从高到低进行任务处理。</li><li>具体实现是根据任务实例的json解析优先级，然后把流程实例优先级_流程实例id_任务优先级_任务id信息保存在ZooKeeper任务队列中，当从任务队列获取的时候，通过字符串比较即可得出最需要优先执行的任务</li><li>其中流程定义的优先级是考虑到有些流程需要先于其他流程进行处理，这个可以在流程启动或者定时启动时配置，共有5级，依次为HIGHEST、HIGH、MEDIUM、LOW、LOWEST。如下图<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3090be360fc811cd0d75f7b991360704.png" alt="在这里插入图片描述"></li><li>任务的优先级也分为5级，依次为HIGHEST、HIGH、MEDIUM、LOW、LOWEST。如下图</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9068563bd7c6dffe8f86985a2dc00ee8.png" alt="在这里插入图片描述"></p><h3 id="7-Logback和netty实现日志访问"><a href="#7-Logback和netty实现日志访问" class="headerlink" title="7.Logback和netty实现日志访问"></a>7.Logback和netty实现日志访问</h3><ul><li>由于Web(UI)和Worker不一定在同一台机器上，所以查看日志不能像查询本地文件那样。有两种方案：</li><li>将日志放到ES搜索引擎上</li><li>通过netty通信获取远程日志信息</li><li>介于考虑到尽可能的DolphinScheduler的轻量级性，所以选择了gRPC实现远程访问日志信息。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/82f55cda92a79366043309e77d90d48a.png" alt="在这里插入图片描述"><br>详情可参考Master和Worker的logback配置，如下示例：</p><pre><code>&lt;conversionRule conversionWord=&quot;messsage&quot; converterClass=&quot;org.apache.dolphinscheduler.service.log.SensitiveDataConverter&quot;/&gt;&lt;appender name=&quot;TASKLOGFILE&quot; class=&quot;ch.qos.logback.classic.sift.SiftingAppender&quot;&gt;    &lt;filter class=&quot;org.apache.dolphinscheduler.service.log.TaskLogFilter&quot;/&gt;    &lt;Discriminator class=&quot;org.apache.dolphinscheduler.service.log.TaskLogDiscriminator&quot;&gt;        &lt;key&gt;taskAppId&lt;/key&gt;        &lt;logBase&gt;$&#123;log.base&#125;&lt;/logBase&gt;    &lt;/Discriminator&gt;    &lt;sift&gt;        &lt;appender name=&quot;FILE-$&#123;taskAppId&#125;&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;            &lt;file&gt;$&#123;log.base&#125;/$&#123;taskAppId&#125;.log&lt;/file&gt;            &lt;encoder&gt;                &lt;pattern&gt;                            [%level] %date&#123;yyyy-MM-dd HH:mm:ss.SSS Z&#125; [%thread] %logger&#123;96&#125;:[%line] - %messsage%n                &lt;/pattern&gt;                &lt;charset&gt;UTF-8&lt;/charset&gt;            &lt;/encoder&gt;            &lt;append&gt;true&lt;/append&gt;        &lt;/appender&gt;    &lt;/sift&gt;&lt;/appender&gt;</code></pre><h3 id="8-配置文件详解"><a href="#8-配置文件详解" class="headerlink" title="8.配置文件详解"></a>8.配置文件详解</h3><p>dolphinscheduler-daemon.sh [启动/关闭DolphinScheduler服务脚本]</p><p>dolphinscheduler-daemon.sh脚本负责DolphinScheduler的启动&amp;关闭. start-all.sh/stop-all.sh最终也是通过dolphinscheduler-daemon.sh对集群进行启动/关闭操作. 目前DolphinScheduler只是做了一个基本的设置,JVM参数请根据各自资源的实际情况自行设置。</p><p>默认简化参数如下:</p><pre><code>export DOLPHINSCHEDULER_OPTS=&quot;-server-Xmx16g-Xms1g-Xss512k-XX:+UseConcMarkSweepGC-XX:+CMSParallelRemarkEnabled-XX:+UseFastAccessorMethods-XX:+UseCMSInitiatingOccupancyOnly-XX:CMSInitiatingOccupancyFraction=70&quot;</code></pre><h3 id="9-负载均衡"><a href="#9-负载均衡" class="headerlink" title="9.负载均衡"></a>9.负载均衡</h3><p>负载均衡即通过路由算法（通常是集群环境），合理的分摊服务器压力，达到服务器性能的最大优化。</p><p><strong>DolphinScheduler-Worker 负载均衡算法</strong></p><p>DolphinScheduler-Master 分配任务至 worker,默认提供了三种算法:</p><ul><li>加权随机（random）</li><li>平滑轮询（roundrobin）</li><li>线性负载（lowerweight）</li><li>默认配置为线性加权负载。</li></ul><p>由于路由是在客户端做的，即 master 服务，因此你可以更改 master.properties 中的 master.host.selector 来配置你所想要的算法。</p><p>eg：master.host.selector=random（不区分大小写）</p><p><strong>Worker 负载均衡配置</strong></p><p>配置文件 worker.properties</p><p>权重<br>上述所有的负载算法都是基于权重来进行加权分配的，权重影响分流结果。你可以在 修改 worker.weight 的值来给不同的机器设置不同的权重。</p><p>预热<br>考虑到 JIT 优化，我们会让 worker 在启动后低功率的运行一段时间，使其逐渐达到最佳状态，这段过程我们称之为预热。感兴趣的同学可以去阅读 JIT 相关的文章。</p><p>因此 worker 在启动后，他的权重会随着时间逐渐达到最大（默认十分钟）。</p><p><strong>负载均衡算法细述</strong></p><p><strong>随机（加权）</strong></p><ul><li>该算法比较简单，即在符合的 worker 中随机选取一台（权重会影响他的比重）。</li></ul><p><strong>平滑轮询（加权）</strong></p><ul><li>加权轮询算法一个明显的缺陷。即在某些特殊的权重下，加权轮询调度会生成不均匀的实例序列，这种不平滑的负载可能会使某些实例出现瞬时高负载的现象，导致系统存在宕机的风险。为了解决这个调度缺陷，我们提供了平滑加权轮询算法。</li></ul><p>每台 worker 都有两个权重，即 weight（预热完成后保持不变），current_weight（动态变化），每次路由。都会遍历所有的 worker，使其 current_weight+weight，同时累加所有 worker 的 weight，计为 total_weight，然后挑选 current_weight 最大的作为本次执行任务的 worker，与此同时，将这台 worker 的 current_weight-total_weight。</p><p><strong>线性加权(默认算法)</strong></p><ul><li>该算法每隔一段时间会向注册中心上报自己的负载信息。我们主要根据两个信息来进行判断</li><li>load 平均值（默认是 CPU 核数 *2）</li><li>可用物理内存（默认是 0.3，单位是 G）</li></ul><p>如果两者任何一个低于配置项，那么这台 worker 将不参与负载。（即不分配流量）</p><p>你可以在 worker.properties 修改下面的属性来自定义配置：</p><ul><li>worker.max.cpuload.avg=-1 (worker最大cpuload均值，只有高于系统cpuload均值时，worker服务才能被派发任务. 默认值为-1: cpu cores * 2)</li><li>worker.reserved.memory=0.3 (worker预留内存，只有低于系统可用内存时，worker服务才能被派发任务，单位为G)</li></ul><h3 id="10-缓存"><a href="#10-缓存" class="headerlink" title="10.缓存"></a>10.缓存</h3><p><strong>缓存目的</strong></p><p>由于在master-server调度过程中，会产生大量的数据库读取操作，如tenant，user，processDefinition等，一方面对DB产生很大的读压力，另一方面则会使整个核心调度流程变得缓慢；</p><p>考虑到这部分业务数据是读多写少的场景，故引入了缓存模块，以减少DB读压力，加快核心调度流程；</p><p>缓存设置</p><pre><code>spring:  cache:    # default enable cache, you can disable by `type: none`    type: none    cache-names:      - tenant      - user      - processDefinition      - processTaskRelation      - taskDefinition    caffeine:      spec: maximumSize=100,expireAfterWrite=300s,recordStats</code></pre><p>缓存模块采用spring-cache机制，可直接在spring配置文件中配置是否开启缓存（默认none关闭）, 缓存类型；</p><p>目前采用caffeine进行缓存管理，可自由设置缓存相关配置，如缓存大小、过期时间等；</p><p><strong>缓存读取</strong><br>缓存采用spring-cache的注解，配置在相关的mapper层，可参考如：TenantMapper.</p><p><strong>缓存更新</strong></p><p>业务数据的更新来自于api-server, 而缓存端在master-server, 故需要对api-server的数据更新做监听(aspect切面拦截@CacheEvict)，当需要进行缓存驱逐时会通知master-server，master-server接收到cacheEvictCommand后进行缓存驱逐；</p><h2 id="十、API调用"><a href="#十、API调用" class="headerlink" title="十、API调用"></a>十、API调用</h2><p>一般都是通过页面来创建项目、流程等，但是与第三方系统集成就需要通过调用 API 来管理项目、流程。</p><p>创建 token</p><ul><li>登录调度系统，点击 “安全中心”，再点击左侧的 “令牌管理”，点击 “令牌管理” 创建令牌。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9f261c82a3738bb6bb0a34cee078f802.png" alt="在这里插入图片描述"></p><ul><li>选择 “失效时间” (Token 有效期)，选择 “用户” (以指定的用户执行接口操作)，点击 “生成令牌” ，拷贝 Token 字符串，然后点击 “提交” 。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0597b16c482360c022cd44ef57cc66e6.png" alt="在这里插入图片描述"></li></ul><p>使用案例</p><p>查询项目列表信息</p><ul><li>打开 API 文档页面<br>地址：<a href="http://{api">http://{api</a> server ip}:12345/dolphinscheduler/swagger-ui/index.html?language=zh_CN&amp;lang=cn</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f598f368abc9998f0317b3309ff8bc25.png" alt="在这里插入图片描述"></p><ul><li><p>选一个测试的接口，本次测试选取的接口是：查询所有项目</p><p>projects/list</p></li></ul><ul><li><p>打开 Postman，填写接口地址，并在 Headers 中填写 Token，发送请求后即可查看结果</p><p>token: 刚刚生成的 Token</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d0007e2242df4c04589bcd8b3cff838d.png" alt="在这里插入图片描述"><br>创建项目<br>这里演示如何使用调用 api 来创建对应的项目。</p><p>通过查阅 api 文档，在 Postman 的 Headers 中配置 KEY 为 Accept，VALUE 为 application/json 的参数。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/71029297ff6f8f6659ec4377bd6a2410.png" alt="在这里插入图片描述"><br>然后再 Body 中配置所需的 projectName 和 description 参数。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9907e161b3075e2d4d2072b8f72c7424.png" alt="在这里插入图片描述"><br>检查 post 请求结果。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/00165645c6e3c14e297b9cf248050d10.png" alt="在这里插入图片描述"><br>返回 msg 信息为 “success”，说明我们已经成功通过 API 的方式创建了项目。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;深入了解海豚调度DolphinScheduler&quot;&gt;&lt;a href=&quot;#深入了解海豚调度DolphinScheduler&quot; class=&quot;headerlink&quot; title=&quot;深入了解海豚调度DolphinScheduler&quot;&gt;&lt;/a&gt;深入了解海豚调度&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>10分钟入门Flink--了解Flink</title>
    <link href="https://amirokd.dpdns.org/posts/26fd1f6.html"/>
    <id>https://amirokd.dpdns.org/posts/26fd1f6.html</id>
    <published>2025-05-27T04:14:17.000Z</published>
    <updated>2025-05-27T04:16:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Flink入门系列文章主要是为了给想学习Flink的你建立一个大体上的框架，助力快速上手Flink。学习Flink最有效的方式是先入门了解框架和概念，然后边写代码边实践，然后再把官网看一遍。</p><p><a href="https://zhuanlan.zhihu.com/p/642671403">https://zhuanlan.zhihu.com/p/642671403</a></p><p>Flink入门分为四篇，第一篇是《了解Flink》，第二篇《架构和原理》，第三篇是《DataStream》，第四篇是《Table Api &amp; SQL》。</p><p>官网地址<a href="https://nightlies.apache.org/flink/flink-docs-release-1.15/zh/">https://nightlies.apache.org/flink/flink-docs-release-1.15/zh/</a>。</p><h3 id="1、友情提示"><a href="#1、友情提示" class="headerlink" title="1、友情提示"></a>1、友情提示</h3><p>前期入门Flink时，可以直接编写通过idea编写Flink程序，然后直接运行main方法，无需搭建环境。我碰到许多初次接触Flink的同学，被各种环境搭建、提交作业、复杂概念给劝退了。前期最好的入门方式就是直接上手写代码，main方法跑demo，快速了解概念，等入门之后再去实践集群环境、各种作业提交、各种复杂概念。接下来正式进入主题。</p><h3 id="2、大白话"><a href="#2、大白话" class="headerlink" title="2、大白话"></a>2、大白话</h3><p>说白了，Flink就是个实时处理数据任务的框架，这个框架帮助开发者执行数据处理的任务，让开发者无需关心高可用、性能等问题。如果你有一些数据任务需要执行，比如数据监控、数据分析、数据同步，那就可以考虑使用Flink。所谓流计算就是对源源不断的数据进行计算，中间的计算结果存放在内存或者外部存储，这就是有状态计算。</p><h3 id="3、示例代码"><a href="#3、示例代码" class="headerlink" title="3、示例代码"></a>3、示例代码</h3><p>通过2段简单的代码，也能清晰的看到Flink已经做到了流批统一，同样的功能，使用同样的API和算子，大大减少了开发者的工作量。</p><p>本文示例采用的Flink版本是15.4，代码地址：<a href="https://github.com/yclxiao/flink-blog.git">https://github.com/yclxiao/flink-blog.git</a></p><p><strong>3.1、词频统计-批数据</strong></p><pre><code>// 1. 创建执行环境StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();// 2. 读取数据源DataStream&lt;String&gt; textStream = env.fromCollection(Arrays.asList(        &quot;java,c++,php,java,spring&quot;,        &quot;hadoop,scala&quot;,        &quot;c++,jvm,html,php&quot;));// 3. 数据转换DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; wordCountStream = textStream        // 对数据源的单词进行拆分，每个单词记为1，然后通过out.collect将数据发射到下游算子        .flatMap(new FlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;                     @Override                     public void flatMap(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out) throws Exception &#123;                         for (String word : value.split(&quot;,&quot;)) &#123;                             out.collect(new Tuple2&lt;&gt;(word, 1));                         &#125;                     &#125;                 &#125;        )        // 对单词进行分组        .keyBy(value -&gt; value.f0)        // 对某个组里的单词的数量进行滚动相加统计        .reduce((a, b) -&gt; new Tuple2&lt;&gt;(a.f0, a.f1 + b.f1));// 4. 数据输出。字节输出到控制台wordCountStream.print(&quot;WordCountBatch========&quot;).setParallelism(1);// 5. 启动任务env.execute(WordCountBatch.class.getSimpleName());</code></pre><p><strong>3.2、词频统计-流数据</strong></p><pre><code>// 1. 创建执行环境StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();// 2. 读取数据源DataStream&lt;String&gt; textStream = env.socketTextStream(&quot;localhost&quot;, 9999, &quot;\n&quot;);// 3. 数据转换DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; wordCountStream = textStream        // 对数据源的单词进行拆分，每个单词记为1，然后通过out.collect将数据发射到下游算子        .flatMap(new FlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;                     @Override                     public void flatMap(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out) throws Exception &#123;                         for (String word : value.split(&quot;\\s&quot;)) &#123;                             out.collect(new Tuple2&lt;&gt;(word, 1));                         &#125;                     &#125;                 &#125;        )        // 对单词进行分组        .keyBy(value -&gt; value.f0)        // 对某个组里的单词的数量进行滚动相加统计        .reduce((a, b) -&gt; new Tuple2&lt;&gt;(a.f0, a.f1 + b.f1));// 4. 数据输出。字节输出到控制台wordCountStream.print(&quot;WordCountStream=======&quot;).setParallelism(1);// 5. 启动任务env.execute(WordCountStream.class.getSimpleName());</code></pre><h3 id="4、什么是Flink"><a href="#4、什么是Flink" class="headerlink" title="4、什么是Flink"></a>4、什么是Flink</h3><p><strong>Flink是一个框架和分布式处理引擎，用于对无边界和有边界的数据流进行有状态的计算</strong>。Flink是原生的流处理系统，但也提供了批处理API，用于基于流式计算引擎处理批量数据的计算能力，真正实现了批流统一。</p><p><strong>Flink支持有状态的计算</strong>。在流式计算过程中将算子的中间结果保存在内存或者文件系统中，等下一个事件进入算子后可以从之前的状态中获取中间结果，以便计算当前的结果，从而无需每次都基于全部的原始数据来统计结果，极大地提升了系统性能。每一个具有一定复杂度的流计算应用都是有状态的，任何运行基本业务逻辑的流处理应用都需要在一定时间内存储所接受的事件或者中间结果。</p><p><img src="https://pic2.zhimg.com/v2-d8c08908b2cb4d01867ae51aba07c867_1440w.jpg" alt=""></p><p><strong>Flink支持事件时间</strong>。Flink除了支持处理时间外，还支持事件时间（Event Time），根据事件本身自带的时间戳（事件的产生时间）进行结果的计算。这种基于事件驱动的机制使得事件即使乱序到达，Flink也能够计算出精确的结果，保证了结果的准确性和一致性。</p><p><strong>Flink支持高可用性</strong>。Flink可以实现快速故障恢复、动态扩容、7×24小时运行流式应用等作业。Flink还支持在不丢失应用状态的前提下更新作业的程序代码。Flink可以将任务执行的快照保存在存储介质上，当需要停机运维等操作时，下次启动可以直接从事先保存的快照恢复原有的计算状态，使得任务继续按照停机之前的状态运行。</p><p><strong>Flink吞吐量高</strong>。较高的吞吐量可以提高资源利用率，减小系统开销。</p><p><strong>Flink容错性好</strong>。Flink的容错机制是基于分布式快照实现的，通过CheckPoint机制保存流处理作业某些时刻的状态，当任务异常结束时，默认从最近一次保存的完整快照处恢复任务。</p><p><strong>Flink提供了不同层级的API</strong>。Flink为流处理和批处理提供了不同层级的API，每一种API在简洁性和表达力上有着不同的侧重，并且针对不同的应用场景，不同层级的API降低了系统耦合度。</p><p><img src="https://pic4.zhimg.com/v2-7679e039b4c7d7fd8ba682ee4bc48891_1440w.jpg" alt=""></p><h3 id="5、应用场景"><a href="#5、应用场景" class="headerlink" title="5、应用场景"></a>5、应用场景</h3><p><strong>事件驱动</strong>：根据到来的事件流触发计算、状态更新或其他外部动作。主要应用实例有反欺诈、异常检测、基于规则的报警、业务流程监控等。</p><p><strong>数据分析</strong>：从原始数据中提取有价值的信息和指标，这些信息和指标数据可以写入外部数据库系统或以内部状态的形式维护。</p><p><strong>数据管道</strong>：数据管道和ETL（Extract-Transform-Load，提取-转换-加载）作业的用途相似，都可以转换、丰富数据，并将其从某个存储系统移动到另一个。与传统的ETL不同的是，传统的ETL是周期性的，而Flink是以持续流模式运行的。</p><h3 id="6、主要组件"><a href="#6、主要组件" class="headerlink" title="6、主要组件"></a>6、主要组件</h3><p><strong>存储层</strong>：Flink本身并没有提供分布式文件系统，因此Flink的分析大多依赖外部存储。</p><p><strong>调度层</strong>：Flink自带一个简易的资源调度器，称为独立调度器（Standalone）。若集群中没有任何资源管理器，则可以使用自带的独立调度器。当然，Flink也支持在其他的集群管理器上运行，包括Hadoop YARN、Apache Mesos等。</p><p><strong>计算层</strong>：Flink的核心是一个对由很多计算任务组成的、运行在多个工作机器或者一个计算集群上的应用进行调度、分发以及监控的计算引擎，为API工具层提供基础服务。</p><p><strong>工具层</strong>：在Flink Runtime的基础上，Flink提供了面向流处理（DataStream API）和批处理（DataSetAPI）的不同计算接口，并在此接口上抽象出了不同的应用类型组件库，例如基于流处理的CEP（复杂事件处理库）、Table&amp;SQL（结构化表处理库）和基于批处理的Gelly（图计算库）、FlinkML（机器学习库）、Table&amp;SQL（结构化表处理库）。</p><h3 id="7、Flink编程模型"><a href="#7、Flink编程模型" class="headerlink" title="7、Flink编程模型"></a>7、Flink编程模型</h3><p>Flink的编程套路是固定的，他其实就是帮助开发者去执行一些列任务，开发者无需关注性能、高可用等棘手问题。</p><p><strong>有界数据集</strong>：定义一个数据流的开始，也定义数据流的结束，就会产生有界数据集。</p><p><strong>批处理</strong>：有界数据集的处理通常称为批处理</p><p><strong>无界数据集</strong>：定义一个数据流的开始，但没有定义数据流的结束，就会产生无界数据集。无界数据集会无休止地产生新数据，是没有边界的。</p><p><strong>流处理</strong>：对无界数据集的处理被称为流处理。</p><p><strong>有界和无界转换</strong>：有界数据集与无界数据集其实是一个相对的概念。如果每间隔一分钟、一小时、一天对数据进行一次计算，那么认为这一段时间的数据相对是有界的。有界的流数据又可以一条一条地按照顺序发送给计算引擎进行处理，在这种情况下可以认为数据是相对无界的。有界数据集与无界数据集可以相互转换。Flink正是使用这种方式将有界数据集与无界数据集进行统一处理，从而将批处理和流处理统一在一套流式引擎中，能够同时实现批处理与流处理任务。</p><h3 id="8、Flink程序结构"><a href="#8、Flink程序结构" class="headerlink" title="8、Flink程序结构"></a>8、Flink程序结构</h3><p><strong>构成</strong>：一个Flink应用程序由3部分构成，分别为Source、Transformation和Sink。</p><p><img src="https://pic2.zhimg.com/v2-2fbf97edc3b171fddd55d326109d74df_1440w.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/v2-00636128f90a51581fd4fa5067a5ee93_1440w.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/v2-e2d7b6f93b49a5dc760b4236685ccd81_1440w.jpg" alt=""></p><p><strong>编程固定套路</strong>：</p><ol><li>创建执行环境</li><li>读取源数据</li><li>转换数据</li><li>输出转换结果</li><li>触发任务执行</li></ol><h3 id="9、补充概念"><a href="#9、补充概念" class="headerlink" title="9、补充概念"></a>9、补充概念</h3><p><strong>9.1、什么是算子</strong></p><p>Flink提供了丰富的用于数据处理的函数，这些函数称为算子。说白了就是Flink提供了一系列处理数据的函数给你调用。至于函数内部如何处理交换数据，使用者无需关心。</p><p><strong>9.2、原生流处理和微批次区别</strong></p><p>原生流处理：</p><p><img src="https://pic4.zhimg.com/v2-33c016e410740ba65ba894f51fb12f2d_1440w.jpg" alt=""></p><p>微批次处理：</p><p><img src="https://pic1.zhimg.com/v2-a8f3840e1513c02a5549bfe8a01212fa_1440w.jpg" alt=""></p><p><strong>9.3、处理次数</strong></p><p>处理次数分为：At-Most-Once、At-Least-Once、Exactly-Once。</p><p>At-Most-Once：每条数据最多被处理一次，会有丢失数据的可能。</p><p>At-Least-Once：每条数据至少被处理一次，保证数据不会丢失，但数据可能会被重复处理。</p><p>Exactly-Once：每条数据仅被处理一次，不会丢失数据，也不会重复处理。</p><p>Storm实现了At-Least-Once，可以对数据至少处理一次，但不能保证仅处理一次，这样就会导致数据重复处理的问题，因此针对计数类的需求可能会产生一些误差；</p><p>Spark Streaming和Flink都实现了Exactly-Once，可以保证对数据仅处理一次，即每个记录将被精确处理一次，数据不会丢失，并且不会重复处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Flink入门系列文章主要是为了给想学习Flink的你建立一个大体上的框架，助力快速上手Flink。学习Flink最有效的方式是先入门了解框架和概念，然后边写代码边实践，然后再把官网看一遍。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.co</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Flyway详解（使用说明及避坑指南、一文搞懂flyway）</title>
    <link href="https://amirokd.dpdns.org/posts/fb7d18b1.html"/>
    <id>https://amirokd.dpdns.org/posts/fb7d18b1.html</id>
    <published>2025-05-26T11:45:33.000Z</published>
    <updated>2025-05-26T11:46:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-1-Flyway是什么？"><a href="#1-1-Flyway是什么？" class="headerlink" title="1.1 Flyway是什么？"></a>1.1 <a href="https://so.csdn.net/so/search?q=Flyway&amp;spm=1001.2101.3001.7020">Flyway</a>是什么？</h3><p>Flyway是一款开源的数据库版本管理工具，可以实现管理并跟踪数据库变更，支持数据库版本自动升级，而且不需要复杂的配置，能够帮助团队更加方便、合理的管理数据库变更。<br>例：创建两个sql变更文件，项目启动后会将两个文件中的sql语句全部执行。</p><h3 id="1-2-为什么使用Flyway？"><a href="#1-2-为什么使用Flyway？" class="headerlink" title="1.2 为什么使用Flyway？"></a>1.2 为什么使用Flyway？</h3><p>简单举个例子：开发时，如果A开发和B开发都对同一数据库进行了修改，那么如何进行数据同步呢？假如多个开发人员都修改了<a href="https://so.csdn.net/so/search?q=sql%E8%84%9A%E6%9C%AC&amp;spm=1001.2101.3001.7020">sql脚本</a>，怎么同步到测试环境和生产环境？<br>类似于以上的情况在日常开发中不胜枚举，在最开始的单体架构中，我们公司采用了通过校验数据库版本号来实现sql的变更，这虽然能够解决大部分问题，但每次都需要维护变更sql的代码和数据库版本号，且对于后续服务上云也是十分不便的。因此我们需要对数据库校验的方案进行调整，就去调研了目前市面上比较流行的Flyway和<a href="https://so.csdn.net/so/search?q=Liquibase&amp;spm=1001.2101.3001.7020">Liquibase</a>，综合对比下来，最终选择了Flyway作为后续的数据库版本管理工具，具体差异如下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/93d7ab2859dd8fa0c65c2f12a6129919.png" alt="在这里插入图片描述"></p><h3 id="1-3-Flyway的工作原理"><a href="#1-3-Flyway的工作原理" class="headerlink" title="1.3 Flyway的工作原理"></a>1.3 Flyway的工作原理</h3><p>Flyway在第一次执行时，会创建一个默认名为flyway_schema_history的历史记录表，这张表会用来跟踪或记录数据库的状态，然后每次项目启动时都会自动扫描在resources/db/migration下的文件的版本号并且通过查询flyway_schema_history来判断是否有新增文件，从而判断是否进行迁移。<br>默认的查找 migration 的路径为 classpath:db/migration ，对应 SQL 文件可放置在src/main/resources/db/migration 下，Java 类可放置在 src/main/java/db/migration 下。<br>Flyway在第一次执行时，会创建一个默认名为flyway_schema_history的历史记录表，这张表会用来跟<br>踪或记录数据库的状态，然后每次启动时都会自动扫描在resources/db/migration下的文件并且通过查<br>询flyway_schema_history来判断是否为新增文件，从而判断是否进行迁移。<br>默认的查找 migration 的路径为 classpath:db/migration ，对应 SQL 文件可放置在<br>src/main/resources/db/migration 下，Java 类可放置在 src/main/java/db/migration 下</p><h3 id="1-3-1-Flyway的校验版本号算法"><a href="#1-3-1-Flyway的校验版本号算法" class="headerlink" title="1.3.1 Flyway的校验版本号算法"></a>1.3.1 Flyway的校验版本号算法</h3><p>flyway在升级数据库时会先计算之前已经升级过的脚本的checksum值和数据库的checkSum值进行比对，如果老脚本发生了变化后checkSum校验就会失败，从而抛出异常，checkSum计算算法为(CRC32 (循环冗余校验码)算法)。<br>新增的脚本则会和数据库中的版本号进行比较，如果小于数据库存储的最后一个版本号，也不会继续执行。</p><h3 id="1-3-2-Flyway的锁机制"><a href="#1-3-2-Flyway的锁机制" class="headerlink" title="1.3.2 Flyway的锁机制"></a>1.3.2 Flyway的锁机制</h3><p>Flyway使用数据库锁机制（locking technology of your database）来协调多个节点，从而保证多套应用程序可同时执migration，而且集群控制也可做配置。基于数据库锁机制实现分布式锁有两种，基于数据库表和基于数据库排他锁，Flyway采用的是基于数据库排他锁。</p><pre><code>排他锁（Exclusive Locks，简称X锁），又称为写锁、独占锁，在数据库管理上，是锁的基本类型之一。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A</code></pre><p>源码如下：</p><pre><code>@Overridepublic &lt;T&gt; T lock(Table table, Callable&lt;T&gt; callable) &#123;        if (database.isPxcStrict()) &#123;        return super.lock(table, callable);&#125;    return new MySQLNamedLockTemplate(jdbcTemplate,table.toString().hashCode()).execute(callable);&#125;@Overrideprotected void doLock() throws SQLException &#123;        jdbcTemplate.execute(&quot;SELECT * FROM &quot; + this + &quot; FOR UPDATE&quot;);&#125;private boolean tryLock() throws SQLException &#123;        return jdbcTemplate.queryForInt(&quot;SELECT GET_LOCK(?,10)&quot;, lockName) == 1;&#125;</code></pre><h3 id="1-3-3-Flyway连接数据库"><a href="#1-3-3-Flyway连接数据库" class="headerlink" title="1.3.3 Flyway连接数据库"></a>1.3.3 Flyway连接数据库</h3><p>flyway使用JDBC连接数据库</p><pre><code>private boolean hasUserVariableResetCapability() &#123;    try &#123;        jdbcTemplate.queryForStringList(userVariablesQuery);        return true;    &#125; catch (SQLException e) &#123;        LOG.debug(&quot;Disabled user variable reset as &quot; + (database.isMariaDB() ? USER_VARIABLES_TABLE_MARIADB :USER_VARIABLES_TABLE_MYSQL)+ &quot;cannot be queried (SQL State: &quot; + e.getSQLState() + &quot;,Error Code: &quot; + e.getErrorCode() + &quot;)&quot;);    return false;&#125;&#125;</code></pre><h3 id="1-3-4-Flyway的启动速度"><a href="#1-3-4-Flyway的启动速度" class="headerlink" title="1.3.4 Flyway的启动速度"></a>1.3.4 Flyway的启动速度</h3><p>耗时主要来源两个方面<br>(1).Flyway依次读取脚本中内容时的IO开销<br>(2).Flyway计算脚本checksum值的算法开销<br>对于IO开销而言，每个脚本如果不是涉及大量的数据变更,只是表结构的变更,脚本的大小都非常小,可以不考虑。</p><h2 id="二、Flyway的使用"><a href="#二、Flyway的使用" class="headerlink" title="二、Flyway的使用"></a>二、Flyway的使用</h2><p>接下来就进入正题了，flyway该如何使用呢？<br>以下是Java的使用方式。</p><h3 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h3><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;    &lt;version&gt;6.5.7&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="2-2-添加配置"><a href="#2-2-添加配置" class="headerlink" title="2.2 添加配置"></a>2.2 添加配置</h3><pre><code>javaspring:  flyway:    #是否启用    enabled: true    # 可以支持多个location, 用&#39;,&#39;隔开    locations: classpath:db/migration    #是否创建元数据表    validate-on-migrate: true    # flyway 的 clean 命令会删除指定 schema 下的所有 table, 生产务必禁掉。这个默认值是    false 理论上作为默认配置是不科学的。    clean-disabled: true    # 如果数据库不是空表，需要设置成 true，否则启动报错    baseline-on-migrate: true    # 版本控制日志表，默认flyway_schema_history,不同系统建议修改数据    # table: flyway_schema_history</code></pre><h3 id="2-3-创建sql文件"><a href="#2-3-创建sql文件" class="headerlink" title="2.3 创建sql文件"></a>2.3 创建sql文件</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9c72a763078f32deb92a01d0c386ce06.png" alt="在这里插入图片描述"></p><h3 id="2-4-启动项目即可"><a href="#2-4-启动项目即可" class="headerlink" title="2.4 启动项目即可"></a>2.4 启动项目即可</h3><h2 id="三、Flyway详解"><a href="#三、Flyway详解" class="headerlink" title="三、Flyway详解"></a>三、Flyway详解</h2><h3 id="3-1-命令行"><a href="#3-1-命令行" class="headerlink" title="3.1 命令行"></a>3.1 命令行</h3><p>1.常用命令Migrate, Clean, Info, Validate, Baseline， Repair。</p><p>2.Migrate是指把数据库默认数据库迁移到最新版本。</p><p>3.Clean这个命令会清除指定库下所有的对象，包括table、view、triggers…，让数据库变成空的状态。</p><p>4.info用于打印所有Migrations的详细和状态信息。</p><p>5.Validate是指验证已经应用的Migrations是否有变更，Flyway是默认是开启验证的。</p><p>6.Baseline针对已经存在表结构的数据库的一种解决方案，即实现在非空数据库中新建Metadata表，并把Migrations应用到该数据库。</p><p>7.Repair操作能够修复Metadata表，该操作在Metadata表出现错误时是非常有用的。</p><p>8.Repair会修复Metadata表的错误，通常有两种用途：<br>①移除失败的Migration记录，该问题只是针对不支持DDL事务的数据库。<br>②重新调整已经应用的Migratons的Checksums值，比如：某个Migratinon已经被应用，但本地进行了修改，又期望重新应用并调整Checksum值，不过尽量不要这样操作，否则可能造成其它环境失败。</p><h3 id="3-2-配置行"><a href="#3-2-配置行" class="headerlink" title="3.2 配置行"></a>3.2 配置行</h3><p>flyway配置详解<br>flyway.baseline-description对执行迁移时基准版本的描述.<br>flyway.baseline-on-migrate当迁移时发现目标schema非空，而且带有没有元数据的表时，是否自动执<br>行基准迁移，默认false.<br>flyway.baseline-version开始执行基准迁移时对现有的schema的版本打标签，默认值为1.<br>flyway.check-location检查迁移脚本的位置是否存在，默认false.<br>flyway.clean-on-validation-error当发现校验错误时是否自动调用clean，默认false.<br>flyway.enabled是否开启flywary，默认true.<br>flyway.encoding设置迁移时的编码，默认UTF-8.<br>flyway.ignore-failed-future-migration当读取元数据表时是否忽略错误的迁移，默认false.<br>flyway.init-sqls当初始化好连接时要执行的SQL.<br>flyway.locations迁移脚本的位置，默认db/migration.<br>flyway.out-of-order是否允许无序的迁移，默认false.<br>flyway.password目标数据库的密码.<br>flyway.placeholder-prefix设置每个placeholder的前缀，默认${.<br>flyway.placeholder-replacementplaceholders是否要被替换，默认true.<br>flyway.placeholder-suffix设置每个placeholder的后缀，默认}.<br>flyway.placeholders.[placeholder name]设置placeholder的value<br>flyway.schemas设定需要flywary迁移的schema，大小写敏感，默认为连接默认的schema.<br>flyway.sql-migration-prefix迁移文件的前缀，默认为V.<br>flyway.sql-migration-separator迁移脚本的文件名分隔符，默认__<br>flyway.sql-migration-suffix迁移脚本的后缀，默认为.sql<br>flyway.tableflyway使用的元数据表名，默认为schema_version<br>flyway.target迁移时使用的目标版本，默认为latest version<br>flyway.url迁移时使用的JDBC URL，如果没有指定的话，将使用配置的主数据源<br>flyway.user迁移数据库的用户名<br>flyway.validate-on-migrate迁移时是否校验，默认为true.</p><h3 id="3-3-执行方式"><a href="#3-3-执行方式" class="headerlink" title="3.3 执行方式"></a>3.3 执行方式</h3><p>Flyway 的 migration 会在 Spring Boot 应用启动时自动执行，如果不想通过启动应用的方式执行，官方<br>提供了命令行、API、以及 Maven 和 Gradle 插件的方式，但总的来说都会麻烦一些，因为需要将已经<br>在 Spring Boot 中配置的参数，再到其他执行方式所各自要求的位置重新配置一遍，实用性一般。</p><h3 id="3-4-sql脚本命名规则"><a href="#3-4-sql脚本命名规则" class="headerlink" title="3.4 sql脚本命名规则"></a>3.4 sql脚本命名规则</h3><p>1.仅需要执行一次的，以大写“V”开头，V+版本后(版本号间的数字以“.” 或者“ _ ”分隔开，“ _ ”会自动编译<br>成 “ . ” )+” __“+文件描述+后缀名<br>2.需要执行多次的，以大写“R”开头，命名如R__clean.sql ，R的脚本只要改变了就会执行,R不带版本号<br>3.V开头的比R开头的优先级要高。</p><pre><code>前缀：用于版本控制（可配置）、撤消（可配置）和可重复迁移（可配置）VUR)版本：带有点或下划线的版本可根据需要分隔任意数量的部分（不适用于可重复的迁移）分隔符：（两个下划线）（可配置）__)说明：下划线或空格分隔单词后缀：（可配置.sql)（可选）版本控制 SQL 迁移还可以省略分隔符和说明</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/aed08df531886c236977a8f5998fb1a6.png" alt="在这里插入图片描述"></p><h2 id="四-开发时注意事项"><a href="#四-开发时注意事项" class="headerlink" title="四 开发时注意事项"></a>四 开发时注意事项</h2><p>1.报错后需要删除flyway_schema_history中记录，否则启动失败<br>2.V的优先级高于R，假如三个V迁移脚本和一个R(无论新建还是修改)一起执行，其中一个V报错，则V会<br>全部执行完成且记录到flyway_schema_history中，而R不执行且不记录，删除表中报错记录后，查询启<br>动，则执行原错误V和未执行的R<br>3.多个要执行的R中，如果出现了其中一个出现了错误，则在其后的R都不执行<br>4.R的执行顺序根据命名来进行排序<br>5.一个文件中ddl并不由一个事务管理，比如创建三个表，中间创建表语句报错，则第一个表还是会创建<br>成功并且提交事务<br>6.已经执行过的迁移文件(V)不能修改，否则报错。<br>7.同一个迁移文件下同表内DDL无法回滚，DML可回滚, 从报错点开始不往下执行，Flyway使用数据库锁<br>机制<br>8.版本号相同会报错（Found more than one migration with version 1.0.0.9）<br>9.同一个迁移文件下假设都是dml，那么如果中间出现错误，所有的dml语句都会回滚<br>10.删除sql文件后启动会报错，报错如下：</p><pre><code>If you removed this migration intentionally, run repair to mark the migration asdeleted.</code></pre><h2 id="五、部署上线时注意事项"><a href="#五、部署上线时注意事项" class="headerlink" title="五、部署上线时注意事项"></a>五、部署上线时注意事项</h2><ol><li>如果不手动创建元数据表，则需要进行以下配置，用于自动创建<br>validate-on-migrate: true<br>If you removed this migration intentionally, run repair to mark the migration as<br>deleted.</li><li>如果数据库不是空表，则需进行以下配置，否则启动报错<br>baseline-on-migrate: true</li><li>clean命令会删除数据库中所有表，包括数据，结构等，这是不合理的，所以需要进行以下配置<br>clean-disabled: true (该配置由于默认值不合理，所以在V9版本中修改默认值由false为true)</li><li>使用flyway要注意版本兼容问题，springboot与flyway，flyway与数据库版本，否则启动报错</li><li>如果启动的时候像忽略某些迁移文件，可进行以下参数配置<br>baseline-version=20210809，以忽略 20210809 版本以及之前的所有 migration</li><li>多人开发中，如果一个人提交V2一个人提交V1，而V2先入库执行了，那么V1入库就不会执行，如<br>果需要执行则需进行如下配置，但是不建议这么做<br>out-of-order=true</li></ol><h2 id="六、-支持的数据库版本"><a href="#六、-支持的数据库版本" class="headerlink" title="六、 支持的数据库版本"></a>六、 支持的数据库版本</h2><p>目前支持mysql5.7的社区版为7.15.0，支持mysql8.0的版本是8.2.0，8.2.1移除了mysql支持，如文档原<br>文：</p><pre><code>Extract MySQL code to plugin. This will need to be added as a new dependency.</code></pre><p>flyway的8.2.1版本移除mysql的解决方案，增加依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;    &lt;artifactId&gt;flyway-mysql&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Flyway的引用确实方便了后续我们团队的数据库版本管理，但各个团队使用场景皆有不同，所以本文只供想要学习Flyway的朋友借鉴，另：flyway的社区版同专业版相比也是有一些区别的，类似下面的两个方面，所以在选择Flyway时需考虑引入对整体架构的提升，本文分享到这里结束，感谢大家耐心观看。<br>①社区版目前不支持版本回退<br>②社区版本没有任务队列和异步任务的支持，所以在大量变更时略有风险，尽量拆分</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;h3 id=&quot;1-1-Flyway是什么？&quot;&gt;&lt;a href=&quot;#1-1-Flyway是什么？&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="数据库" scheme="https://amirokd.dpdns.org/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Flyway" scheme="https://amirokd.dpdns.org/tags/Flyway/"/>
    
  </entry>
  
  <entry>
    <title>一文快速入门 ClickHouse</title>
    <link href="https://amirokd.dpdns.org/posts/592dd913.html"/>
    <id>https://amirokd.dpdns.org/posts/592dd913.html</id>
    <published>2025-05-25T14:00:02.000Z</published>
    <updated>2025-05-25T14:00:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是clickhouse"><a href="#什么是clickhouse" class="headerlink" title="什么是clickhouse"></a><strong>什么是clickhouse</strong></h2><p>ClickHouse是一种OLAP类型的列式数据库管理系统，这里有两个概念：OLAP、列式数据库。这两个概念会在接下来做介绍，ClickHouse完美的实现了OLAP和列式数据库的优势，因此在大数据量的分析处理应用中Clickhouse表现很优秀。</p><p>国内阿里云在全托管服务上使用ck、思科在流量分析上使用ck、虎牙在视频流的分析上使用ck、腾讯在通讯的日志记录上和大数据的数据处理上使用ck、喜马拉雅在音频共享上使用ck，还有更多的国内外厂商开始使用ck。</p><p>clickhouse在官方文档<strong><a href="https://clickhouse.com/docs/en/intro/">https://clickhouse.com/docs/en/intro/</a></strong>上有一些教程文档。</p><h2 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a><strong>列式数据库</strong></h2><p>在传统的行式数据库中，数据在数据库中都会按行存储，常见的MySQL、Oracle、SQL Server等数据库都是行式数据库。行式数据库的存储方式如下</p><p><img src="https://pica.zhimg.com/v2-468a3d82ae6bc5a23245a99ba91a0d3e_1440w.jpg" alt=""></p><p>在列式数据库中，数据是以列进行存储的，列式数据库更适合于OLAP场景，常见的列式数据库有hbase、clickhouse、Vertica等。列式数据库的存储方式如下</p><p><img src="https://pic2.zhimg.com/v2-2403ca1e6a26c90550c9814f28620515_1440w.jpg" alt=""></p><p>不同的存储结构适用于不同的业务场景，列式数据库适合数据分析类型的场景，比如上面的例子中要统计成绩的中位数，在行数据库中，需要将四行数据都遍历出来，取出成绩；而在列式数据库中，只需要将成绩这一列的数据取出来就可以进行分析计算。</p><p>列式数据库的优势如下；</p><p>1、针对分析类查询，通常只需要读取表的一小部分列。在列式数据库中你可以只读取你需要的数据。例如，如果只需要读取100列中的5列，这将帮助你最少减少20倍的I/O消耗。</p><p>2、由于数据总是打包成批量读取的，所以压缩是非常容易的。同时数据按列分别存储这也更容易压缩。这进一步降低了I/O的体积。</p><p>3、由于I/O的降低，这将帮助更多的数据被系统缓存。</p><h2 id="OLAP和OATP"><a href="#OLAP和OATP" class="headerlink" title="OLAP和OATP"></a><strong>OLAP和OATP</strong></h2><p>OLAP和OLTP是针对不同场景的两种数据库实现。有关OLAP和OLTP的介绍可以讲好几个小时，简单来讲： OLTP全称是On-line Transaction Processing，是一种联机事务型数据库，典型的数据库就是关系型数据库，OLTP关注的是对业务数据的增删改查，面向用户的事务操作，追求效率的最优解。但是遇到需要对数据进行分析的场景，OLTP类型的数据库就不占优势了。</p><p>OLAP全称是On-Line Analytical Processing，是一种联机分析处理数据库，一般用于数据仓库或者大数据分析处理，这种类型的数据库在事务能力上很弱，但是在分析的场景下很强大。</p><p>OLAP型数据库有一些关键性的场景：</p><p>1、绝大多数是读请求</p><p>2、数据以相当大的批次(&gt; 1000行)更新，而不是单行更新;或者根本没有更新。</p><p>3、已添加到数据库的数据不能修改。</p><p>4、对于读取，从数据库中提取相当多的行，但只提取列的一小部分。</p><p>5、宽表，即每个表包含着大量的列</p><p>6、查询相对较少(通常每台服务器每秒查询数百次或更少)</p><p>7、对于简单查询，允许延迟大约50毫秒</p><p>8、列中的数据相对较小：数字和短字符串(例如，每个URL 60个字节)</p><p>9、处理单个查询时需要高吞吐量(每台服务器每秒可达数十亿行)</p><p>10、事务不是必须的</p><p>11、对数据一致性要求低</p><p>12、每个查询有一个大表。除了他以外，其他的都很小。</p><p>13、查询结果明显小于源数据。换句话说，数据经过过滤或聚合，因此结果适合于单个服务器的RAM中</p><h2 id="ClickHouse的特性"><a href="#ClickHouse的特性" class="headerlink" title="ClickHouse的特性"></a><strong>ClickHouse的特性</strong></h2><p>从官网中，我们可以整理出ClickHouse的特性，或者说ClickHouse的优点。</p><p>1、真正的列式数据库管理系统</p><p>2、优秀的数据压缩能力</p><p>3、数据的磁盘存储，降低设备预算</p><p>4、多核心并行处理，ClickHouse会使用服务器上一切可用的资源，从而以最自然的方式并行处理大型查询。</p><p>5、多服务器分布式处理</p><p>6、支持SQL，降低学习成本</p><p>7、向量引擎，数据不仅仅按列存储，同时还按向量(列的一部分)进行处理，这样可以更加高效地使用CPU。</p><p>8、实时的数据更新，数据可以持续不断地高效的写入到表中，并且写入的过程中不会存在任何加锁的行为。</p><p>9、索引，按照主键对数据进行排序，这将帮助ClickHouse在几十毫秒以内完成对数据特定值或范围的查找。</p><p>10、适合在线查询</p><p>11、支持近似计算</p><p>12、自适应的join算法，JOIN多个表，它更倾向于散列连接算法，如果有多个大表，则使用合并-连接算法。</p><p>13、支持数据复制和数据完整性</p><p>14、角色的访问控制。</p><p>ClickHouse的缺点在于：</p><p>1、没有完整的事务支持。</p><p>2、缺少高频率，低延迟的修改或删除已存在数据的能力。仅能用于批量删除或修改数据。</p><p>3、ClickHouse不适合通过检索单行的点查询。</p><h2 id="ClickHouse对应用侧的支持"><a href="#ClickHouse对应用侧的支持" class="headerlink" title="ClickHouse对应用侧的支持"></a><strong>ClickHouse对应用侧的支持</strong></h2><p>对于ClickHouse的使用，官方提供了命令行客户端、JDBC驱动、ODBC驱动、C++客户端。同时社区中还有很多第三方库可以使用，因此在应用上的会便利很多。</p><h2 id="ClickHouse的数据类型"><a href="#ClickHouse的数据类型" class="headerlink" title="ClickHouse的数据类型"></a><strong>ClickHouse的数据类型</strong></h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a><strong>整型</strong></h3><p>整型类型包含有符号整数型和无符号整数型，整型的范围会跟在数据类型之后。 有符号整型：</p><pre><code>Int8 — \[-128 : 127]Int16 — \[-32768 : 32767]Int32 — \[-2147483648 : 2147483647]Int64 — \[-9223372036854775808 : 9223372036854775807]Int128 — \[-170141183460469231731687303715884105728 : 170141183460469231731687303715884105727]Int256 — \[-57896044618658097711785492504343953926634992332820282019728792003956564819968 : 57896044618658097711785492504343953926634992332820282019728792003956564819967]</code></pre><p>无符号整型：</p><pre><code>UInt8 — \[0 : 255]UInt16 — \[0 : 65535]UInt32 — \[0 : 4294967295]UInt64 — \[0 : 18446744073709551615]UInt128 — \[0 : 340282366920938463463374607431768211455]UInt256 — \[0 : 115792089237316195423570985008687907853269984665640564039457584007913129639935]</code></pre><p>在ck中，也可以通过一些别名来代替整型</p><pre><code>Int8 — TINYINT, BOOL, BOOLEAN, INT1.Int16 — SMALLINT, INT2.Int32 — INT, INT4, INTEGER.Int64 — BIGINT.</code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h3><p>字符串可以任意长度的。它可以包含任意的字节集，包含空字节，在定义时，通过关键字String定义类型为字符串。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a><strong>浮点数</strong></h3><p>ClickHouse中浮点数有Float32和Float64两种，对应于C语言中的float和double。 ClickHouse在官网上建议尽可能以整数形式存储数据，对浮点数进行计算可能引起四舍五入的误差。</p><h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a><strong>时间类型</strong></h3><p>ClickHouse通过Date32和DateTime64存储时间，Date32只存储年月日，支持1900-01-01到2299-12-31，插入数据时可传入’2100-01-01’的格式，也可传入单位为秒的时间戳。比如：</p><pre><code>INSERT INTO test VALUES (4102444800, 1), (&#39;2100-01-01&#39;, 2);</code></pre><h2 id="ClickHouse的增删改查"><a href="#ClickHouse的增删改查" class="headerlink" title="ClickHouse的增删改查"></a><strong>ClickHouse的增删改查</strong></h2><h2 id="Database"><a href="#Database" class="headerlink" title="Database"></a><strong>Database</strong></h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a><strong>创建数据库</strong></h3><p>数据库在ck中是用于存放表的目录，创建方式和传统的SQL语法一样</p><pre><code>CREATE DATABASE [IF NOT EXISTS] db_name;</code></pre><p>其中IF NOT EXISTS属于可选项，比如创建一个名为ck_test的数据库</p><pre><code>CREATE database if not exists ck_test;</code></pre><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a><strong>删除数据库</strong></h3><p>ck中使用drop删除指定的数据库，drop会删除数据库中的所有表，然后删除数据库本身</p><pre><code>DROP DATABASE [IF EXISTS] db [ON CLUSTER cluster]</code></pre><p>ON CLUSTER cluster表示是否删除所有集群下的数据库</p><h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a><strong>Table</strong></h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a><strong>创建表</strong></h3><p>在ck中创建表的方式有很多，结构化语句建表是最常见的方式之一。</p><pre><code>CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster](    name1 [type1] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr1] [compression_codec] [TTL expr1],    name2 [type2] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr2] [compression_codec] [TTL expr2],    ...) ENGINE = engine</code></pre><p>在属性字段中：</p><ul><li>第一个字段name表示属性的名称</li><li>第二个字段[type]表示数据的类型</li><li>第三个字段[NULL|NOT NULL]定义该字段允许或不允许为Nullable</li><li><p>第四个字段[DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr1]表示该字段的默认值表达式，如果该字段为空，默认值为零（数字）、空字符串（字符串）、空数组（数组）等。其中最常用的是DEFAULT expr，比如Hits UInt32 DEFAULT 0。</p></li><li><p>DEFAULT expr</p></li><li><p>普通的默认值，如果INSERT中不包含指定的列，那么将通过表达式计算它的默认值并填充它。</p></li><li><p>MATERIALIZED expr</p></li><li><p>物化表达式，被该表达式指定的列不能包含在INSERT的列表中，因为它总是被计算出来的。 对于INSERT而 言，不需要考虑这些列。 另外，在SELECT查询中如果包含星号，此列不会被用来替换星号，这是因为考虑到数据转储，在使用SELECT *查询出的结果总能够被’INSERT’回表。</p></li><li><p>ALIAS expr</p></li><li><p>别名。这样的列不会存储在表中。 它的值不能够通过INSERT写入，同时使用SELECT查询星号时，这些列也不会被用来替换星号。 但是它们可以显示的用于SELECT中，在这种情况下，在查询分析中别名将被替换。</p></li><li><p>第五个字段[compression_codec]定义字段的压缩方法，默认采用lz4压缩方法，可以通过下面的方式<code>dt Date CODEC(ZSTD)</code>指定压缩方法。</p></li><li>第六个字段[TTL expr1]代表值的存储时间，只能为 MergeTree 系列表指定。</li></ul><p>通过ENGINE可以指定表所用到的引擎，比如最常用的MergeTree。 通过<code>PRIMARY KEY(expr1[, expr2,...])]</code>可以定义表的主键。 例子：</p><pre><code>create table user(    id UInt32,    name String,    grade UInt32,    address String)ENGINE = MergeTree PRIMARY KEY(id)ORDER BY id</code></pre><p>除了结构化方式建表之外，ck还提供了更多创建表的方式 从另一张表中创建表：</p><pre><code>CREATE TABLE [IF NOT EXISTS] [db.]table_name AS [db2.]name2 [ENGINE = engine]</code></pre><p>例子：</p><pre><code>CREATE TABLE user2 AS user</code></pre><p>通过select语句建表：</p><pre><code>CREATE TABLE [IF NOT EXISTS] [db.]table_name[(name1 [type1], name2 [type2], ...)] ENGINE = engine AS SELECT ...</code></pre><p>例子：</p><pre><code>CREATE TABLE user3 ENGINE = MergeTree PRIMARY KEY(id)AS select * from user;</code></pre><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a><strong>修改表</strong></h3><p>ck中使用ALTER对表结构进行修改</p><pre><code>ALTER TABLE [db].name [ON CLUSTER cluster] ADD|DROP|RENAME|CLEAR|COMMENT|&#123;MODIFY|ALTER&#125;|MATERIALIZE COLUMN ...</code></pre><p>例子：</p><pre><code>ALTER table user add column sex String;</code></pre><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a><strong>删除表</strong></h3><p>使用drop命令删除表</p><pre><code>DROP [TEMPORARY] TABLE [IF EXISTS] [db.]name [ON CLUSTER cluster]</code></pre><p>例子：</p><pre><code>drop table user3</code></pre><h2 id="基本查询语法"><a href="#基本查询语法" class="headerlink" title="基本查询语法"></a><strong>基本查询语法</strong></h2><p>OLAP型数据库的一种特性是数据以相当大的批次(&gt; 1000行)更新，而不是单行更新;或者根本没有更新；绝大多数是读请求。因此查询操作是ck最主要的应用。 ck中的查询方法和使用MySQL基本一致，ck支持用 SQL 语法查询执行各种操作。 首先插入一些测试数据：</p><pre><code>INSERT into user values(1,&#39;张三&#39;,88,&#39;hz&#39;,&#39;男&#39;),(2,&#39;李四&#39;,90,&#39;hz&#39;,&#39;男&#39;),(3,&#39;王五&#39;,93,&#39;nb&#39;,&#39;女&#39;)</code></pre><p>查询所有的数据</p><pre><code>select * from user</code></pre><p>还可以对列名进行查询，比如查询所有列名中带a的数据</p><pre><code>select columns(&#39;a&#39;) from user</code></pre><p><img src="https://pic2.zhimg.com/v2-4c01a914dcd270570ad147236329983b_1440w.jpg" alt=""></p><p>按地区进行聚合，统计每个地区的平均分</p><pre><code>select address,AVG(grade) from user group by address</code></pre><p><img src="https://pic1.zhimg.com/v2-2271b165d118652f77b50c85c0a3ecd0_1440w.jpg" alt=""></p><p>image.png</p><p>更多的SQL语法操作看<strong><a href="https://clickhouse.com/docs/zh/sql-reference/statements/">https://clickhouse.com/docs/zh/</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是clickhouse&quot;&gt;&lt;a href=&quot;#什么是clickhouse&quot; class=&quot;headerlink&quot; title=&quot;什么是clickhouse&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是clickhouse&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;ClickHous</summary>
      
    
    
    
    
    <category term="ClickHouse" scheme="https://amirokd.dpdns.org/tags/ClickHouse/"/>
    
    <category term="数据库" scheme="https://amirokd.dpdns.org/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关于dpdns.org绑定vercel失败问题</title>
    <link href="https://amirokd.dpdns.org/posts/7385849b.html"/>
    <id>https://amirokd.dpdns.org/posts/7385849b.html</id>
    <published>2025-05-07T14:06:03.000Z</published>
    <updated>2025-05-07T14:14:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于dpdns-org绑定vercel失败问题"><a href="#关于dpdns-org绑定vercel失败问题" class="headerlink" title="关于dpdns.org绑定vercel失败问题"></a>关于dpdns.org绑定vercel失败问题</h1><p><strong>当Vercel出现三级域名认证出现问题的时候</strong></p><p><img src="https://zhangweiluo.dpdns.org/img/image-20250507221111270.png" alt="image-20250507221111270"></p><p><strong>在cloud flare中填写_vercel和 _vercel.xxx两个txt类型的信息</strong></p><p><img src="https://zhangweiluo.dpdns.org/img/image-20250507221022851.png" alt="image-20250507221022851"></p><p><strong>即可通过验证</strong></p><p><img src="https://zhangweiluo.dpdns.org/img/image-20250507221252448.png" alt="image-20250507221252448"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于dpdns-org绑定vercel失败问题&quot;&gt;&lt;a href=&quot;#关于dpdns-org绑定vercel失败问题&quot; class=&quot;headerlink&quot; title=&quot;关于dpdns.org绑定vercel失败问题&quot;&gt;&lt;/a&gt;关于dpdns.org绑定verc</summary>
      
    
    
    
    <category term="域名" scheme="https://amirokd.dpdns.org/categories/%E5%9F%9F%E5%90%8D/"/>
    
    
    <category term="vercel" scheme="https://amirokd.dpdns.org/tags/vercel/"/>
    
  </entry>
  
  <entry>
    <title>认证授权</title>
    <link href="https://amirokd.dpdns.org/posts/11015d6e.html"/>
    <id>https://amirokd.dpdns.org/posts/11015d6e.html</id>
    <published>2025-03-13T12:08:34.000Z</published>
    <updated>2025-03-13T12:14:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-模块需求分析"><a href="#1-模块需求分析" class="headerlink" title="1 模块需求分析"></a>1 模块需求分析</h1><h2 id="1-1-什么是认证授权"><a href="#1-1-什么是认证授权" class="headerlink" title="1.1 什么是认证授权"></a>1.1 什么是认证授权</h2><p>截至目前，项目已经完成了课程发布功能，课程发布后用户通过在线学习页面点播视频进行学习。如何去记录学生的学习过程呢？要想掌握学生的学习情况就需要知道用户的身份信息，记录哪个用户在什么时间学习什么课程，如果用户要购买课程也需要知道用户的身份信息。所以，去管理学生的学习过程最基本的要实现用户的身份认证。</p><p>认证授权模块实现平台所有用户的身份认证与用户授权功能。</p><p>什么是用户身份认证？</p><p>​        用户身份认证即用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问。常见的用户身份认证的表现形式有：用户名密码登录，微信扫码等方式。</p><p>项目包括学生、学习机构的老师、平台运营人员三类用户，不管哪一类用户在访问项目受保护资源时都需要进行身份认证。比如：发布课程操作，需要学习机构的老师首先登录系统成功，然后再执行发布课程操作。创建订单，需要学生用户首先登录系统，才可以创建订单。如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjI4MmQ5NDQ4ZjFjNTNlOGQxODBiZDI0OGY3OGNmZGFfRU1MblR6cUpmWlBhd0RweHBzSUFqSjN0OXdUNGJXOUZfVG9rZW46R0xmdGJOUEM0b01QdW94NTNkS2NiM1FpblZkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>什么是用户授权？</p><p>​        用户认证通过后去访问系统的资源，系统会判断用户是否拥有访问资源的权限，只允许访问有权限的系统资源，没有权限的资源将无法访问，这个过程叫用户授权。比如：用户去发布课程，系统首先进行用户身份认证，认证通过后继续判断用户是否有发布课程的权限，如果没有权限则拒绝继续访问系统，如果有权限则继续发布课程。如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MDkzNDcxZTVkZDFjYjliNjBlN2YwOTBkYjlkMTNmMGFfeEFKc0E0WDBKUnA2eW9LUUQwajY4REtxQnc1ODNJR1VfVG9rZW46REZ5MWJYRkFmb05iMFh4aUdkYWNPeXkxblBlXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><h2 id="1-2-业务流程"><a href="#1-2-业务流程" class="headerlink" title="1.2 业务流程"></a>1.2 业务流程</h2><h3 id="1-2-1-统一认证"><a href="#1-2-1-统一认证" class="headerlink" title="1.2.1 统一认证"></a>1.2.1 统一认证</h3><p>项目包括学生、学习机构的老师、平台运营人员三类用户，三类用户将使用统一的认证入口，如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OTMzNDg4MzY4MmVkNGVhYjRjYjYyNzNkZTliMDY0MzJfM0RqbUJXdGJDMlI2Tk9jMThrYUNHQlRReE1vV1BvYUtfVG9rZW46QWVjZGI0Z211b1ZUUTB4ZjV4bGNEdFZxbk5iXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>用户输入账号和密码提交认证，认证通过则继续操作。</p><p>项目由统一认证服务受理用户的认证请求，如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OTdhNDUwYTc2NzEzMDczNDk3ZDRkYjA0NDQ3YTA4OGJfbmliMjl3eXNFbDRKQkZScGNuVzZYZHRUU0FpNnVlVHpfVG9rZW46SWNsWGJwRlVwbzZISGV4UU03TGNVekJvbkxkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>认证通过由认证服务向给用户颁发令牌，相当于访问系统的通行证，用户拿着令牌去访问系统的资源。</p><h3 id="1-2-2-单点登录"><a href="#1-2-2-单点登录" class="headerlink" title="1.2.2 单点登录"></a>1.2.2 单点登录</h3><p>本项目基于微服务架构构建，微服务包括：内容管理服务、媒资管理服务、学习中心服务、系统管理服务等，为了提高用户体验性，用户只需要认证一次便可以在多个拥有访问权限的系统中访问，这个功能叫做单点登录。</p><p>引用百度百科：单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p><p>如下图，用户只需要认证一次，便可以在多个拥有访问权限的系统中访问。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjc0NWM1N2I0YmFmMjE2MGNlZTJjMDgxNzQwNzdjMjFfOVJlR3ZQVHdGbGdGT200VzU3R011RmRRZEUxeGJJbU1fVG9rZW46R3VaMmJxT2ZBbzlIVVp4elJTNmNTNkNTbmhoXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><h3 id="1-2-3-第三方认证"><a href="#1-2-3-第三方认证" class="headerlink" title="1.2.3 第三方认证"></a>1.2.3 第三方认证</h3><p>为了提高用户体验，很多网站有扫码登录的功能，如：微信扫码登录、QQ扫码登录等。扫码登录的好处是用户不用输入账号和密码，操作简便，另外一个好处就是有利于用户信息的共享，互联网的优势就是资源共享，用户也是一种资源，对于一个新网站如果让用户去注册是很困难的，如果提供了微信扫码登录将省去用户注册的成本，是一种非常有效的推广手段。</p><p>微信扫码登录其中的原理正是使用了第三方认证，如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NjIzMzYxNTA4Nzg2MzkyNzMwODA5MGFmYTUzNTk5NjNfWTRUQzNmM0FPQWFRS3FFTDIzTzVDaWxWQ2dxQ2w2QXhfVG9rZW46R01mUWJrVFM3b1J1WVN4WjEyeWM5NHd6bmVlXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><h1 id="2-Spring-Security-认证研究"><a href="#2-Spring-Security-认证研究" class="headerlink" title="2 Spring Security 认证研究"></a>2 Spring Security 认证研究</h1><h2 id="2-1-Spring-Security介绍"><a href="#2-1-Spring-Security介绍" class="headerlink" title="2.1 Spring Security介绍"></a>2.1 Spring Security介绍</h2><p>认证功能几乎是每个项目都要具备的功能，并且它与业务无关，市面上有很多认证框架，如：Apache Shiro、CAS、Spring Security等。由于本项目基于Spring Cloud技术构建，Spring Security是spring家族的一份子且和Spring Cloud集成的很好，所以本项目选用Spring Security作为认证服务的技术框架。</p><p>Spring Security 是一个功能强大且高度可定制的身份验证和访问控制框架，它是一个专注于为 Java 应用程序提供身份验证和授权的框架。</p><p>项目主页：<a href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a></p><p>Spring cloud Security： <a href="https://spring.io/projects/spring-cloud-security">https://spring.io/projects/spring-cloud-security</a></p><h2 id="2-2-认证授权入门"><a href="#2-2-认证授权入门" class="headerlink" title="2.2 认证授权入门"></a>2.2 认证授权入门</h2><h3 id="2-2-1-创建认证服务工程"><a href="#2-2-1-创建认证服务工程" class="headerlink" title="2.2.1 创建认证服务工程"></a>2.2.1 创建认证服务工程</h3><p>下边我们使用Spring Security框架快速构建认证授权功能体系。</p><p>1、部署认证服务工程</p><p>从课程资料中拷贝xuecheng-plus-auth工程到自己的工程目录下。</p><p>此工程是一个普通的spring boot工程，可以连接数据库。</p><p>此工程不具备认证授权的功能。</p><p>2、创建数据库</p><p>创建xc_users数据库</p><p>导入课程资料中的xcplus_users.sql脚本。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MTFmMmQzZjQ4MmY0NTZlYmM0OThkOGUxNzBhMDMyNjdfc1pIVTlQUDdyWVBrRGRabzRuZVhUaGhkOG1tYVVzRnlfVG9rZW46VzZwcGJGUGVWb3ljVU14MVIxTmMxT2Y4bnhnXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>在nacos中新增auth-service-dev.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/auth</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">63070</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.101.65:3306/xc1010_users?serverTimezone=UTC&amp;userUnicode=true&amp;useSSL=false&amp;</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><p>初始工程自带了一个Controller类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/27 17:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  XcUserMapper userMapper;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/login-success&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">loginSuccess</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> XcUser <span class="title function_">getuser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span>&#123;</span><br><span class="line">    <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> userMapper.selectById(id);</span><br><span class="line">    <span class="keyword">return</span> xcUser;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/r/r1&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">r1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;访问r1资源&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/r/r2&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">r2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;访问r2资源&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动工程，尝试访问<a href="http://localhost:63070/auth/r/r1">http://localhost:63070/auth/r/r1</a> :</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ODU1NGY3OGY0MTExNzY3MTVhZWI0ODU1MjM1ODJmYTBfYzBCR1RPMUJZSHd6aVFlVTdSTjRWZWFJaXVBSlZ5Z1ZfVG9rZW46QTM3dmJYcnc4b0ZpUHd4Zk1NSmNuT09ablVkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>访问用户信息：<a href="http://localhost:63070/auth/user/52">http://localhost:63070/auth/user/52</a> </p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=M2UyYjg0YzRkYmU4ZjY0YTZmMTY1NmNmZWQwMTVhNGZfM2MwU29wTFhySXY1c0Mzc2ptbkNuQmphdHBmSE5wUmJfVG9rZW46VnFIMmJreEpSb1htRW14dzJRa2NQOGtQbkxmXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>以上测试一切正常说明此工程部署成功。</p><h3 id="2-2-2-认证测试"><a href="#2-2-2-认证测试" class="headerlink" title="2.2.2 认证测试"></a>2.2.2 认证测试</h3><p>下边向auth认证工程集成Spring security，向pom.xml加入Spring Security所需要的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启工程，访问<a href="http://localhost:63070/auth/r/r1">http://localhost:63070/auth/r/r1</a></p><p>自动进入/login登录页面，/login是spring security提供的,此页面有几个css样式加载会稍微慢点，如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjA5NWU5NzgwZjBmODQ5YjQ3ODk3NjlmMjc4ZjI4M2ZfcjFkUjVnTkRjSm1icU1pa09UbWswMmlzaURnWlhyakZfVG9rZW46R0hwUmJVTG54b0k4TmN4MVJaVWNqeUZiblhiXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>账号和密码是多少呢？下一步需要进行安全配置。</p><p>拷贝课程资料下的WebSecurityConfig.java到config下需要三部分内容：</p><p>1、用户信息</p><p>在内存配置两个用户：zhangsan、lisi</p><p>zhangsan用户拥有的权限为p1</p><p>lisi用户拥有的权限为p2</p><p>2、密码方式</p><p>暂时采用明文方式</p><p>3、安全拦截机制</p><p>/r/**开头的请求需要认证</p><p>登录成功到成功页面</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置用户信息服务</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里配置用户信息,这里暂时使用这种方式将用户存储在内存中</span></span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">            manager.createUser(User.withUsername(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;123&quot;</span>).authorities(<span class="string">&quot;p1&quot;</span>).build());</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;456&quot;</span>).authorities(<span class="string">&quot;p2&quot;</span>).build());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//密码为明文方式</span></span><br><span class="line">        <span class="keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置安全拦截机制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/r/**&quot;</span>).authenticated()<span class="comment">//访问/r开始的请求需要认证通过</span></span><br><span class="line">                .anyRequest().permitAll()<span class="comment">//其它请求全部放行</span></span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().successForwardUrl(<span class="string">&quot;/login-success&quot;</span>);<span class="comment">//登录成功跳转到/login-success</span></span><br><span class="line">                http.logout().logoutUrl(<span class="string">&quot;/logout&quot;</span>);<span class="comment">//退出地址</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重启工程</p><p>1、访问<a href="http://localhost:63070/auth/user/52">http://localhost:63070/auth/user/52</a>  可以正常访问</p><p>2、访问<a href="http://localhost:63070/auth/r/r1">http://localhost:63070/auth/r/r1</a> 显示登录页面</p><p>账号zhangsan，密码为123，如果输入的密码不正确会认证失败，输入正确显示登录成功。</p><p>为什么<a href="http://localhost:63070/auth/user/52">http://localhost:63070/auth/user/52</a>  可以正常访问，访问<a href="http://localhost:63070/auth/r/r1">http://localhost:63070/auth/r/r1</a> 显示登录页面？</p><p>http.logout().logoutUrl(“/logout”);配置了退出页面，认证成功后访问/logout可退出登录。</p><h3 id="2-2-3-授权测试"><a href="#2-2-3-授权测试" class="headerlink" title="2.2.3 授权测试"></a>2.2.3 授权测试</h3><p>用户认证通过去访问系统资源时spring security进行授权控制，判断用户是否有该资源的访问权限，如果有则继续访问，如果没有则拒绝访问。</p><p>下边测试授权功能：</p><p>1、配置用户拥有哪些权限。</p><p>在WebSecurityConfig类配置zhangsan拥有p1权限，lisi拥有p2权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里配置用户信息,这里暂时使用这种方式将用户存储在内存中</span></span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;123&quot;</span>).authorities(<span class="string">&quot;p1&quot;</span>).build());</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;456&quot;</span>).authorities(<span class="string">&quot;p2&quot;</span>).build());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、指定资源与权限的关系。</p><p>什么是系统的资源？</p><p>比如：查询一个用户的信息，用户信息就是系统的资源，要访问资源需要通过URL，所以我们在controller中定义的每个http的接口就是访问资源的接口。</p><p>下边在controller中配置/r/r1需要p1权限，/r/r2需要p2权限。</p><p>hasAuthority(‘p1’)表示拥有p1权限方可访问。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/r/r1&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;p1&#x27;)&quot;)</span><span class="comment">//拥有p1权限方可访问</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">r1</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;访问r1资源&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/r/r2&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;p2&#x27;)&quot;)</span><span class="comment">//拥有p2权限方可访问</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">r2</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;访问r2资源&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>现在重启工程。</p><p>当访问以/r/开头的url时会判断用户是否认证，如果没有认证则跳转到登录页面，如果已经认证则判断用户是否具有该URL的访问权限，如果具有该URL的访问权限则继续，否则拒绝访问。</p><p>例如：</p><p>访问/r/r1，使用zhangsan登录可以正常访问，因为在/r/r1的方法上指定了权限p1，zhangsan用户拥有权限p1,所以可以正常访问。</p><p>访问/r/r1，使用lisi登录则拒绝访问，由于lisi用户不具有权限p1需要拒绝访问</p><p>注意：如果访问上不加@PreAuthorize，此方法没有授权控制。</p><p>整理授权的过程见下图所示：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NGEzYTkyMTZkMzUwMzhmMDFiNTcwNTVlOWZlYzRjN2FfOTdKUmF0eW1sQjVsQVl3VGFFRDRuQXJGODBIeUFRMkRfVG9rZW46Vk5VWWIyZVNub3NtTGp4VlBxc2M3SG9ybkRlXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><h3 id="2-2-4-工作原理"><a href="#2-2-4-工作原理" class="headerlink" title="2.2.4 工作原理"></a>2.2.4 工作原理</h3><p>通过测试认证和授权两个功能，我们了解了Spring Security的基本使用方法，下边了解它的工作流程。</p><p>Spring Security所解决的问题就是<strong>安全访问控制</strong>，而安全访问控制功能其实就是对所有进入系统的请求进行拦截，校验每个请求是否能够访问它所期望的资源。根据前边知识的学习，可以通过Filter或AOP等技术来实现，Spring Security对Web资源的保护是靠Filter实现的，所以从这个Filter来入手，逐步深入Spring Security原理。</p><p>​        当初始化Spring Security时，会创建一个名为<code>SpringSecurityFilterChain</code>的Servlet过滤器，类型为 org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求会经过此类，下图是Spring Security过虑器链结构图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OGIxNTc5YzIyMDdkMTVjZjUxZDQ2ZWVjOWMwMjg5MTFfOGE3MW42S1gyR1hBR2phYkY2UmJoTlM3em16UEl3UFlfVG9rZW46SFZMbmJrTmVWbzdSMk94ZGxFamM4TERIbmtjXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>FilterChainProxy是一个代理，真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter，同时这些Filter作为Bean被Spring管理，它们是Spring Security核心，各有各的职责，但他们并不直接处理用户的<strong>认证</strong>，也不直接处理用户的<strong>授权</strong>，而是把它们交给了认证管理器（AuthenticationManager）和决策管理器（AccessDecisionManager）进行处理。</p><p>spring Security功能的实现主要是由一系列过滤器链相互配合完成。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YzFjYWEwOGRiM2UwMTgxMmI3YmNmOTFhN2U1MTkxY2FfNkRwTWpMT2xUbjdtbnZ0VVd6U2s5NEdSSXJxb2lxOFRfVG9rZW46R0ZKcWJvWm1Wb1ptNHZ4ZnVGbWNtdG5YbmViXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>下面介绍过滤器链中主要的几个过滤器及其作用：</p><p><strong>SecurityContextPersistenceFilter</strong> 这个Filter是整个拦截过程的入口和出口（也就是第一个和最后一个拦截器），会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext，然后把它设置给 SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository，同时清除 securityContextHolder 所持有的 SecurityContext；</p><p><strong>UsernamePasswordAuthenticationFilter</strong> 用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码，其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，这些都可以根据需求做相关改变；</p><p><strong>FilterSecurityInterceptor</strong> 是用于保护web资源的，使用AccessDecisionManager对当前用户进行授权访问，前面已经详细介绍过了；</p><p><strong>ExceptionTranslationFilter</strong> 能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常：AuthenticationException 和 AccessDeniedException，其它的异常它会继续抛出。</p><p>Spring Security的执行流程如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MTJkYjIzMDViNTk4YTNlMDZjNjQ5MmFkMDhlYTc5YmZfNDVsRnBaSnZieElBbVBsNkI5TE9IejBQYXkycG1lc0xfVG9rZW46TUFsaWJpZkJUb0xLZGV4b2F4TmNWR3QwbnNnXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><ol><li>用户提交用户名、密码被SecurityFilterChain中的<code>UsernamePasswordAuthenticationFilter</code>过滤器获取到，封装为请求Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。</li><li>然后过滤器将Authentication提交至认证管理器（AuthenticationManager）进行认证</li><li>认证成功后，<code>AuthenticationManager</code>身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）<code>Authentication</code>实例。</li><li><code>SecurityContextHolder</code>安全上下文容器将第3步填充了信息的<code>Authentication</code>，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。</li><li>​        可以看出AuthenticationManager接口（认证管理器）是认证相关的核心接口，也是发起认证的出发点，它的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护着一个<code>List&lt;AuthenticationProvider&gt;</code>列表，存放多种认证方式，最终实际的认证工作是由AuthenticationProvider完成的。咱们知道web表单的对应的AuthenticationProvider实现类为DaoAuthenticationProvider，它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终AuthenticationProvider将UserDetails填充至Authentication。</li></ol><h2 id="2-3-什么是OAuth2"><a href="#2-3-什么是OAuth2" class="headerlink" title="2.3 什么是OAuth2"></a>2.3 什么是OAuth2</h2><h3 id="2-3-1-OAuth2认证流程"><a href="#2-3-1-OAuth2认证流程" class="headerlink" title="2.3.1 OAuth2认证流程"></a>2.3.1 OAuth2认证流程</h3><p>在前边我们提到微信扫码认证，这是一种第三方认证的方式，这种认证方式是基于OAuth2协议实现，</p><p>OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。</p><p>​        Oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。</p><p>参考：<a href="https://baike.baidu.com/item/oAuth/7153134?fr=aladdin">https://baike.baidu.com/item/oAuth/7153134?fr=aladdin</a></p><p>Oauth协议：<a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></p><p>下边分析一个Oauth2认证的例子，黑马程序员网站使用微信认证扫码登录的过程：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OGM5ZGFiM2MwNzViZDY1YTMzOTY0ZDQ5NzM1MDZlOThfUmFDSXBNVmx4cFhHcFpvWFJtOVh4YzUydllDZHpab0ZfVG9rZW46Tm5aOGJPbFJ4bzFETWV4OWd2aWN2S1J4bjdmXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>具体流程如下：</p><p>1、用户点击微信扫码</p><p>用户进入黑马程序的登录页面，点击微信的图标开打微信扫码界面。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ODc3MjU4NmY2ZWQzM2Q3YTQxNTI3MWFmNzVhODk0MWNfbm02cFZIclV3Uk9FY0tiTUQ2MU84YzluaFhlTzVNQzJfVG9rZW46UHZUMmJDNHNvb0RBWWF4MklsYmNhMFVxbkNyXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YmFjMWE1OGU1MmU0NTIwYWZhOWZjYjkzMTNhOTA4OGZfWWhaYkdvMGZFTDdWMktuUWRDS0VpUjIwMkRDOUo0T0ZfVG9rZW46Q1pQWmJYQlVOb3dtWk94RVlaZ2NOVTdabkJjXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>微信扫码的目的是通过微信认证登录黑马程序员官网，黑马程序员网站需要从微信获取当前用户的身份信息才会让当前用户在黑马网站登录成功。</p><p>现在搞清楚几个概念：</p><p>资源：用户信息，在微信中存储。</p><p>资源拥有者：用户是用户信息资源的拥有者。</p><p>认证服务：微信负责认证当前用户的身份，负责为客户端颁发令牌。</p><p>客户端：客户端会携带令牌请求微信获取用户信息，黑马程序员网站即客户端，黑马网站需要在浏览器打开。</p><p>2、用户授权黑马网站访问用户信息</p><p>资源拥有者扫描二维码表示资源拥有者请求微信进行认证，微信认证通过向用户手机返回授权页面，如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTUzN2M5ZmVkZDI2NzljYWYwNTU0ODIyZDc5NDI4MWJfRnV0YmM1TUtvN1d6OTR6OXlQeVI0aklScExGTkQ3cWNfVG9rZW46V1JVM2JxYmtYb3Zwc0J4d052dGN6VVZqbnY1XzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>询问用户是否授权黑马程序员访问自己在微信的用户信息，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码给黑马程序员的网站。</p><p>只有资源拥有者同意微信才允许黑马网站访问资源。</p><p>3、黑马程序员的网站获取到授权码</p><p>4、携带授权码请求微信认证服务器申请令牌</p><p>此交互过程用户看不到。</p><p>5、微信认证服务器向黑马程序员的网站响应令牌</p><p>此交互过程用户看不到。</p><p>6、黑马程序员网站请求微信资源服务器获取资源即用户信息。</p><p>黑马程序员网站携带令牌请求访问微信服务器获取用户的基本信息。</p><p>7、资源服务器返回受保护资源即用户信息</p><p>8、黑马网站接收到用户信息，此时用户在黑马网站登录成功。</p><p>理解了微信扫码登录黑马网站的流程，接下来认识Oauth2.0的认证流程，如下：</p><p>引自Oauth2.0协议rfc6749 <a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2FiNjdjMmZjMDcyZTNiNmQ3NjE5ODgzMmI5ZTdhYmZfS3ZORkIzalprRU9MVndKV3RCblkwVk5CdEY3bHByaXBfVG9rZW46SDVlWWJmS3gwb1dyN0p4dzFHQ2NOc3hJbjViXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>Oauth2包括以下角色：</p><p>1、客户端</p><p>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：手机客户端、浏览器等。</p><p>上边示例中黑马网站即为客户端，它需要通过浏览器打开。</p><p>2、资源拥有者</p><p>通常为用户，也可以是应用程序，即该资源的拥有者。</p><p>A表示 客户端请求资源拥有者授权。</p><p>B表示 资源拥有者授权客户端即黑马网站访问自己的用户信息。</p><p>3、授权服务器（也称认证服务器）</p><p>认证服务器对资源拥有者进行认证，还会对客户端进行认证并颁发令牌。</p><p>C 客户端即黑马网站携带授权码请求认证。</p><p>D认证通过颁发令牌。</p><p>4、资源服务器</p><p>存储资源的服务器。</p><p>E表示客户端即黑马网站携带令牌请求资源服务器获取资源。</p><p>F表示资源服务器校验令牌通过后提供受保护资源。</p><h3 id="2-3-2-OAuth2在本项目的应用"><a href="#2-3-2-OAuth2在本项目的应用" class="headerlink" title="2.3.2 OAuth2在本项目的应用"></a>2.3.2 OAuth2在本项目的应用</h3><p>Oauth2是一个标准的开放的授权协议，应用程序可以根据自己的要求去使用Oauth2，本项目使用Oauth2实现如下目标：</p><p>1、学成在线访问第三方系统的资源。</p><p>本项目要接入微信扫码登录所以本项目要使用OAuth2协议访问微信中的用户信息。</p><p>2、外部系统访问学成在线的资源  。</p><p>同样当第三方系统想要访问学成在线网站的资源也可以基于OAuth2协议。</p><p>3、学成在线前端（客户端） 访问学成在线微服务的资源。</p><p>本项目是前后端分离架构，前端访问微服务资源也可以基于OAuth2协议进行认证。</p><h3 id="2-3-3-OAuth2的授权模式"><a href="#2-3-3-OAuth2的授权模式" class="headerlink" title="2.3.3 OAuth2的授权模式"></a>2.3.3 OAuth2的授权模式</h3><p>Spring Security支持OAuth2认证，OAuth2提供授权码模式、密码模式、简化模式、客户端模式等四种授权模式，前边举的微信扫码登录的例子就是基于授权码模式，这四种模式中授权码模式和密码模式应用较多，本节使用Spring Security演示授权码模式、密码模式，其余两种请自行查阅相关资料。</p><h4 id="2-3-3-1-授权码模式"><a href="#2-3-3-1-授权码模式" class="headerlink" title="2.3.3.1 授权码模式"></a>2.3.3.1 授权码模式</h4><p>OAuth2的几个授权模式是根据不同的应用场景以不同的方式去获取令牌，最终目的是要获取认证服务颁发的令牌，最终通过令牌去获取资源。</p><p>授权码模式简单理解是使用授权码去获取令牌，要想获取令牌先要获取授权码，授权码的获取需要资源拥有者亲自授权同意才可以获取。</p><p>下图是授权码模式的交互图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NzNkNmZmZmZmZmZiYTljNjhjZTg3NDVmMDQ5OWVhYTBfNW9TODZMUEJ5WmxGeUxXTExoekozRWRaSTZGODB4OGZfVG9rZW46SmdidmJPZlVab2NiZ0R4S2NUaGNHM1VqbmViXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>还以黑马网站微信扫码登录为例进行说明：</p><p>1、用户打开浏览器。</p><p>2、通过浏览器访问客户端即黑马网站。</p><p>3、用户通过浏览器向认证服务请求授权，请求授权时会携带客户端的URL，此URL为下发授权码的重定向地址。</p><p>4、认证服务向资源拥有者返回授权页面。</p><p>5、资源拥有者亲自授权同意。</p><p>6、通过浏览器向认证服务发送授权同意。</p><p>7、认证服务向客户端地址重定向并携带授权码。</p><p>8、客户端即黑马网站收到授权码。</p><p>9、客户端携带授权码向认证服务申请令牌。</p><p>10、认证服务向客户端颁发令牌。</p><h4 id="2-3-3-2授权码模式测试"><a href="#2-3-3-2授权码模式测试" class="headerlink" title="2.3.3.2授权码模式测试"></a>2.3.3.2授权码模式测试</h4><p>要想测试授权模式首先要配置授权服务器即上图中的认证服务器，需要配置授权服务及令牌策略。</p><p>1、从课程资料中拷贝 AuthorizationServer.java、TokenConfig.java到认证服务的config包下。</p><p>说明“：AuthorizationServer用 @EnableAuthorizationServer 注解标识并继承AuthorizationServerConfigurerAdapter来配置OAuth2.0 授权服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line">*/</span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"> <span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServer</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>AuthorizationServerConfigurerAdapter要求配置以下几个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title class_">AuthorizationServerConfigurer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthorizationServerConfigurerAdapter</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）**</strong>ClientDetailsServiceConfigurer**：用来配置客户端详情服务（ClientDetailsService），</p><p>随便一个客户端都可以随便接入到它的认证服务吗？答案是否定的，服务提供商会给批准接入的客户端一个身份，用于接入时的凭据，有客户端标识和客户端秘钥，在这里配置批准接入的客户端的详细信息。</p><p><strong>2）AuthorizationServerEndpointsConfigurer</strong>：用来配置令牌（token）的访问端点和令牌服务(token services)。</p><p><strong>3）AuthorizationServerSecurityConfigurer</strong>：用来配置令牌端点的安全约束.</p><p>2、TokenConfig为令牌策略配置类</p><p>暂时先使用InMemoryTokenStore在内存存储令牌，令牌的有效期等信息配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//令牌管理服务</span></span><br><span class="line"><span class="meta">@Bean(name=&quot;authorizationServerTokenServicesCustom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> AuthorizationServerTokenServices <span class="title function_">tokenService</span><span class="params">()</span> &#123;</span><br><span class="line">    DefaultTokenServices service=<span class="keyword">new</span> <span class="title class_">DefaultTokenServices</span>();</span><br><span class="line">    service.setSupportRefreshToken(<span class="literal">true</span>);<span class="comment">//支持刷新令牌</span></span><br><span class="line">    service.setTokenStore(tokenStore);<span class="comment">//令牌存储策略</span></span><br><span class="line">    service.setAccessTokenValiditySeconds(<span class="number">7200</span>); <span class="comment">// 令牌默认有效期2小时</span></span><br><span class="line">    service.setRefreshTokenValiditySeconds(<span class="number">259200</span>); <span class="comment">// 刷新令牌默认有效期3天</span></span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、配置认证管理bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>重启认证服务</p><p>1、get请求获取授权码</p><p>地址: <a href="http://localhost:63070/auth/oauth/authorize?client_id=XcWebApp&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://www.51xuecheng.cn">http://localhost:63070/auth/oauth/authorize?client_id=XcWebApp&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://www.51xuecheng.cn</a></p><p>参数列表如下：</p><ul><li>client_id：客户端准入标识。</li><li>response_type：授权码模式固定为code。</li><li>scope：客户端权限。</li><li>redirect_uri：跳转uri，当授权码申请成功后会跳转到此地址，并在后边带上code参数（授权码）。</li></ul><p>输入账号zhangsan、密码123登录成功，输入/oauth/authorize?client_id=XcWebApp&amp;response_type=code&amp;scope=all&amp;redirect_uri=<a href="http://www.51xuecheng.cn">http://www.51xuecheng.cn</a></p><p>显示授权页面</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YWY0NzkwMmQyZWI3NjUxNjZlZmJkMTI2OGYxNjNiM2NfYzlnUE5HS0VsaWJwYnhKWW1OWFMzMDdGdUdyRHlhR09fVG9rZW46T3pKb2JzVUxYb0szTk54TnVvWWM5NlNubnJiXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>授权“XcWebApp”访问自己的受保护资源?</p><p>选择同意。</p><p>2、请求成功，重定向至<a href="http://www.51xuecheng.cn/?code=授权码，比如：http://www.51xuecheng.cn/?code=Wqjb5H">http://www.51xuecheng.cn/?code=授权码，比如：http://www.51xuecheng.cn/?code=Wqjb5H</a></p><p>3、使用httpclient工具post申请令牌</p><p>/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=authorization_code&amp;code=授权码&amp;redirect_uri=<a href="http://www.51xuecheng.cn/">http://www.51xuecheng.cn/</a></p><p>参数列表如下</p><ul><li>client_id：客户端准入标识。</li><li>client_secret：客户端秘钥。</li><li>grant_type：授权类型，填写authorization_code，表示授权码模式</li><li>code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。</li><li>redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。</li></ul><p>httpclient脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### 授权码模式</span><br><span class="line">### 第一步申请授权码(浏览器请求)/oauth/authorize?client_id=c1&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://www.51xuecheng.cn</span><br><span class="line">### 第二步申请令牌</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=authorization_code&amp;code=CTvCrB&amp;redirect_uri=http://www.51xuecheng.cn</span><br></pre></td></tr></table></figure><p>申请令牌成功如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;368b1ee7-a9ee-4e9a-aae6-0fcab243aad2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3d56e139-0ee6-4ace-8cbe-1311dfaa991f&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">7199</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>说明：</p><p>1、access_token，访问令牌，用于访问资源使用。</p><p>2、token_type，bearer是在RFC6750中定义的一种token类型，在携带令牌访问资源时需要在head中加入bearer 空格 令牌内容</p><p>3、refresh_token，当令牌快过期时使用刷新令牌可以再次生成令牌。</p><p>4、expires_in：过期时间（秒）</p><p>5、scope，令牌的权限范围，服务端可以根据令牌的权限范围去对令牌授权。</p><h4 id="2-3-3-3-密码模式"><a href="#2-3-3-3-密码模式" class="headerlink" title="2.3.3.3 密码模式"></a>2.3.3.3 密码模式</h4><p>密码模式相对授权码模式简单，授权码模式需要借助浏览器供用户亲自授权，密码模式不用借助浏览器，如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MGE2ODU2MTk3ZTIxY2NkZmI1ZWY1MGE2MWUxZWVjNjVfUEFSeFFHUHcydFVNb01TODA3RVNncWZ3V2Q5TWhmNHpfVG9rZW46WDh6SWI0amI1b3ZGNUl4ZlMwR2NtSTA3blVnXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>1、资源拥有者提供账号和密码</p><p>2、客户端向认证服务申请令牌，请求中携带账号和密码</p><p>3、认证服务校验账号和密码正确颁发令牌。</p><p>开始测试：</p><p>1、POST请求获取令牌</p><p>/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=shangsan&amp;password=123</p><p>参数列表如下：</p><ul><li>client_id：客户端准入标识。</li><li>client_secret：客户端秘钥。</li><li>grant_type：授权类型，填写password表示密码模式</li><li>username：资源拥有者用户名。</li><li>password：资源拥有者密码。</li></ul><p>2、授权服务器将令牌（access_token）发送给client</p><p>使用httpclient进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 密码模式</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=zhangsan&amp;password=<span class="number">123</span></span><br></pre></td></tr></table></figure><p>返回示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;368b1ee7-a9ee-4e9a-aae6-0fcab243aad2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3d56e139-0ee6-4ace-8cbe-1311dfaa991f&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">6806</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>​        这种模式十分简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我们自己开发的情况下。</p><h4 id="2-3-3-4-本项目的应用方式"><a href="#2-3-3-4-本项目的应用方式" class="headerlink" title="2.3.3.4 本项目的应用方式"></a>2.3.3.4 本项目的应用方式</h4><p>通过演示授权码模式和密码模式，授权码模式适合客户端和认证服务非同一个系统的情况，所以本项目使用授权码模式完成微信扫码认证。本项目采用密码模式作为前端请求微服务的认证方式。</p><h2 id="2-4-JWT"><a href="#2-4-JWT" class="headerlink" title="2.4 JWT"></a>2.4 JWT</h2><h3 id="2-4-1-普通令牌的问题"><a href="#2-4-1-普通令牌的问题" class="headerlink" title="2.4.1 普通令牌的问题"></a>2.4.1 普通令牌的问题</h3><p>客户端申请到令牌，接下来客户端携带令牌去访问资源，到资源服务器将会校验令牌的合法性。</p><p>资源服务器如何校验令牌的合法性？</p><p>我们以OAuth2的密码模式为例进行说明：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MWE4YTcwMmU0OWMwOGI0MTRhOWY0Y2RjODc2ZTdjNTdfU254OWdKdHlZSG1kVFVsQ0FrZVdtSFppT2xBMFRGcUhfVG9rZW46SGNBdWI1UU5nbzJhME14ZEQxTmN2NHhpbnNmXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>从第4步开始说明：</p><p>1、客户端携带令牌访问资源服务获取资源。</p><p>2、资源服务远程请求认证服务校验令牌的合法性</p><p>3、如果令牌合法资源服务向客户端返回资源。</p><p>这里存在一个问题：</p><p>就是校验令牌需要远程请求认证服务，客户端的每次访问都会远程校验，执行性能低。</p><p>如果能够让资源服务自己校验令牌的合法性将省去远程请求认证服务的成本，提高了性能。如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTFlMjczN2VmMGExMjRkM2NmY2Q5ZjAxZWY3ZTYyNjBfTEtoczJ2dlE0OVk3T2luSFFNcGh1ZFFBTFU2V2ROcDRfVG9rZW46Sjk5eGJsVW9rbzV5UUN4TmNWNGNXTExlbkFiXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>如何解决上边的问题，实现资源服务自行校验令牌。</p><p>令牌采用JWT格式即可解决上边的问题，用户认证通过后会得到一个JWT令牌，JWT令牌中已经包括了用户相关的信息，客户端只需要携带JWT访问资源服务，资源服务根据事先约定的算法自行完成令牌校验，无需每次都请求认证服务完成授权。</p><h3 id="2-4-2-什么是JWT"><a href="#2-4-2-什么是JWT" class="headerlink" title="2.4.2 什么是JWT"></a>2.4.2 什么是JWT</h3><p>什么是JWT？</p><p>JSON Web Token（JWT）是一种使用JSON格式传递数据的网络令牌技术，它是一个开放的行业标准（RFC 7519），它定义了一种简洁的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任，它可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止内容篡改。官网：<a href="https://jwt.io/">https://jwt.io/</a></p><p>使用JWT可以实现无状态认证，什么是无状态认证？</p><p>传统的基于session的方式是有状态认证，用户登录成功将用户的身份信息存储在服务端，这样加大了服务端的存储压力，并且这种方式不适合在分布式系统中应用。</p><p>如下图，当用户访问应用服务，每个应用服务都会去服务器查看session信息，如果session中没有该用户则说明用户没有登录，此时就会重新认证，而解决这个问题的方法是Session复制、Session黏贴。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ODBmZDQxMTMzYmUxMTllNmU0ZWY3ZTdkNjJlMjU2MGFfODNPb3VsRHhQMThIS1BxMUtidWN2bDVXSm5pVzBhRVFfVG9rZW46RnFIVGJUWnZGb0w5cnl4b0c5Y2NWODJobmllXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>如果是基于令牌技术在分布式系统中实现认证则服务端不用存储session，可以将用户身份信息存储在令牌中，用户认证通过后认证服务颁发令牌给用户，用户将令牌存储在客户端，去访问应用服务时携带令牌去访问，服务端从jwt解析出用户信息。这个过程就是无状态认证。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NzIxNDhhMDc3YjViOWFhOTk4NmNmMjE3ZDY3NGU4OWVfWk5sSzVoc0pDZ2c4Z3dOZlJIdWU5WkxyQUs4OUZYRmhfVG9rZW46VktDNWJZZmdFb1R4WkR4ZkN4c2NUWFlabkxkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>JWT令牌的优点：</p><p>1、jwt基于json，非常方便解析。</p><p>2、可以在令牌中自定义丰富的内容，易扩展。</p><p>3、通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</p><p>4、资源服务使用JWT可不依赖认证服务即可完成授权。</p><p>缺点：</p><p>１、JWT令牌较长，占存储空间比较大。</p><p>下边是一个JWT令牌的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQyNTQ2NzIsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6Ijg4OTEyYjJkLTVkMDUtNGMxNC1iYmMzLWZkZTk5NzdmZWJjNiIsImNsaWVudF9pZCI6ImMxIn0.wkDBL7roLrvdBG2oGnXeoXq-zZRgE9IVV2nxd-ez_oA</span><br></pre></td></tr></table></figure><p>JWT令牌由三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz</p><ol><li><p>Header        </p><p>头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）</p><p>一个例子如下：</p><p>下边是Header部分的内容</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>  将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。</p><ol><li><p>Payload</p><p>第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的信息字段，比如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。</p><p>此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。</p><p>最后将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分。</p><p>一个例子：</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;456&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol><li><p>Signature</p><p>第三部分是签名，此部分用于防止jwt内容被篡改。</p><p>这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明的签名算法进行签名。</p><p>一个例子：</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>base64UrlEncode(header)：jwt令牌的第一部分。</p><p>base64UrlEncode(payload)：jwt令牌的第二部分。</p><p>secret：签名所使用的密钥。</p><p>为什么JWT可以防止篡改？</p><p>第三部分使用签名算法对第一部分和第二部分的内容进行签名，常用的签名算法是 HS256，常见的还有md5,sha 等，签名算法需要使用密钥进行签名，密钥不对外公开，并且签名是不可逆的，如果第三方更改了内容那么服务器验证签名就会失败，要想保证验证签名正确必须保证内容、密钥与签名前一致。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ODE0OGQwOWQzMDc5MTQ4MzYxMWU4NDJjZmIxOWJjZjNfbUR0QlBpd1NKSThVWkpTRm1SRXpTYTNmNW1zVkFvZFZfVG9rZW46SzQwWmJuWXgwb2FOSkR4dnBvdWNPM0Z6bjBmXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>从上图可以看出认证服务和资源服务使用相同的密钥，这叫对称加密，对称加密效率高，如果一旦密钥泄露可以伪造jwt令牌。</p><p>JWT还可以使用非对称加密，认证服务自己保留私钥，将公钥下发给受信任的客户端、资源服务，公钥和私钥是配对的，成对的公钥和私钥才可以正常加密和解密，非对称加密效率低但相比对称加密非对称加密更安全一些。</p><h3 id="2-4-3-测试生成JWT令牌"><a href="#2-4-3-测试生成JWT令牌" class="headerlink" title="2.4.3 测试生成JWT令牌"></a>2.4.3 测试生成JWT令牌</h3><p>在认证服务中配置jwt令牌服务，即可实现生成jwt格式的令牌,  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.AuthorizationServerTokenServices;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.DefaultTokenServices;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenEnhancerChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtTokenStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">SIGNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;mq123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public TokenStore tokenStore() &#123;</span></span><br><span class="line"><span class="comment">//        //使用内存存储令牌（普通令牌）</span></span><br><span class="line"><span class="comment">//        return new InMemoryTokenStore();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter accessTokenConverter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenStore <span class="title function_">tokenStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtTokenStore</span>(accessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtAccessTokenConverter <span class="title function_">accessTokenConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JwtAccessTokenConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtAccessTokenConverter</span>();</span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//令牌管理服务</span></span><br><span class="line">    <span class="meta">@Bean(name=&quot;authorizationServerTokenServicesCustom&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationServerTokenServices <span class="title function_">tokenService</span><span class="params">()</span> &#123;</span><br><span class="line">        DefaultTokenServices service=<span class="keyword">new</span> <span class="title class_">DefaultTokenServices</span>();</span><br><span class="line">        service.setSupportRefreshToken(<span class="literal">true</span>);<span class="comment">//支持刷新令牌</span></span><br><span class="line">        service.setTokenStore(tokenStore);<span class="comment">//令牌存储策略</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TokenEnhancerChain</span> <span class="variable">tokenEnhancerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenEnhancerChain</span>();</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter));</span><br><span class="line">        service.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line"></span><br><span class="line">        service.setAccessTokenValiditySeconds(<span class="number">7200</span>); <span class="comment">// 令牌默认有效期2小时</span></span><br><span class="line">        service.setRefreshTokenValiditySeconds(<span class="number">259200</span>); <span class="comment">// 刷新令牌默认有效期3天</span></span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启认证服务。</p><p>使用httpclient通过密码模式申请令牌</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 密码模式</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=zhangsan&amp;password=<span class="number">123</span></span><br></pre></td></tr></table></figure><p>生成jwt的示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQzMzE2OTUsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6ImU5ZDNkMGZkLTI0Y2ItNDRjOC04YzEwLTI1NmIzNGY4ZGZjYyIsImNsaWVudF9pZCI6ImMxIn0.-9SKI-qUqKhKcs8Gb80Rascx-JxqsNZxxXoPo82d8SM&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJhdGkiOiJlOWQzZDBmZC0yNGNiLTQ0YzgtOGMxMC0yNTZiMzRmOGRmY2MiLCJleHAiOjE2NjQ1ODM2OTUsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6ImRjNTRjNTRkLTA0YTMtNDIzNS04MmY3LTFkOWZkMmFjM2VmNSIsImNsaWVudF9pZCI6ImMxIn0.Wsw1Jc-Kd_GFqEugzdfoSsMY6inC8OQsraA21WjWtT8&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">7199</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;e9d3d0fd-24cb-44c8-8c10-256b34f8dfcc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>1、access_token，生成的jwt令牌，用于访问资源使用。</p><p>2、token_type，bearer是在RFC6750中定义的一种token类型，在携带jwt访问资源时需要在head中加入bearer jwt令牌内容</p><p>3、refresh_token，当jwt令牌快过期时使用刷新令牌可以再次生成jwt令牌。</p><p>4、expires_in：过期时间（秒）</p><p>5、scope，令牌的权限范围，服务端可以根据令牌的权限范围去对令牌授权。</p><p>6、jti：令牌的唯一标识。</p><p>我们可以通过check_token接口校验jwt令牌</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###校验jwt令牌</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/oauth/check_token?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJzdHUxIiwic2NvcGUiOlsiYWxsIl0sImV4cCI6MTY2NDM3MTc4MCwiYXV0aG9yaXRpZXMiOlsicDEiXSwianRpIjoiZjBhM2NkZWItMzk5ZC00OGYwLTg4MDQtZWNhNjM4YWQ4ODU3IiwiY2xpZW50X2lkIjoiYzEifQ.qy46CSCJsH3eXWTHgdcntZhzcSzfRQlBU0dxAjZcsUw</span><br></pre></td></tr></table></figure><p>响应示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;res1&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;user_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;all&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1664371780</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorities&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;p1&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f0a3cdeb-399d-48f0-8804-eca638ad8857&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;client_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-4-携带令牌访问资源服务"><a href="#2-4-4-携带令牌访问资源服务" class="headerlink" title="2.4.4 携带令牌访问资源服务"></a>2.4.4 携带令牌访问资源服务</h3><p>拿到了jwt令牌下一步就要携带令牌去访问资源服务中的资源，本项目各个微服务就是资源服务，比如：内容管理服务，客户端申请到jwt令牌，携带jwt去内容管理服务查询课程信息，此时内容管理服务要对jwt进行校验，只有jwt合法才可以继续访问。如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA5YTNlMWZjMDNjZjE3MjEyNzg4ZmFiM2IzMzgwZjVfNTZIZ3p4bHZkT29mRDJBRzN3SGwzRlhUdFQ2UHRoVlhfVG9rZW46UDZ1bWJIMFpxb2hsbFZ4REhucmNSaXhFbmNnXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>1、在内容管理服务的content-api工程中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--认证相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、从资料中拷贝 资源服务配置类 中的 TokenConfig和ResouceServerConfig 到内容管理的api工程的config包下。</p><p>可以在ResouceServerConfig类中配置需要认证的url。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> http.csrf().disable()</span><br><span class="line">         .authorizeRequests()</span><br><span class="line">               .antMatchers(<span class="string">&quot;/r/**&quot;</span>,<span class="string">&quot;/course/**&quot;</span>).authenticated()<span class="comment">//所有/r/**的请求必须认证通过</span></span><br><span class="line">         .anyRequest().permitAll()</span><br><span class="line"> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启内容管理服务</p><p>使用httpclient测试：</p><p>1、访问根据课程id查询课程接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 查询课程信息</span><br><span class="line">GET http://localhost:63040/content/course/2</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unauthorized&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error_description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Full authentication is required to access this resource&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>从返回信息可知当前没有认证。</p><p>下边携带JWT令牌访问接口：</p><p>1、申请jwt令牌</p><p>采用密码模式申请令牌。</p><p>2、携带jwt令牌访问资源服务地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### 携带token访问资源服务</span><br><span class="line">GET http://localhost:63040/content/course/2</span><br><span class="line">Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQzMzM0OTgsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6IjhhM2M2OTk1LWU1ZGEtNDQ1Yy05ZDAyLTEwNDFlYzk3NTkwOSIsImNsaWVudF9pZCI6ImMxIn0.73eNDxTX5ifttGCjwc7xrd-Sbp_mCfcIerI3lGetZto</span><br></pre></td></tr></table></figure><p>在请求头中添加Authorization，内容为Bearer 令牌，Bearer用于通过oauth2.0协议访问资源。</p><p>如果携带jwt令牌且jwt正确则正常访问资源服务的内容。</p><p>如果不正确则报令牌无效的错误：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;invalid_token&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error_description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Cannot convert access token to JSON&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-5-测试获取用户身份"><a href="#2-4-5-测试获取用户身份" class="headerlink" title="2.4.5 测试获取用户身份"></a>2.4.5 测试获取用户身份</h3><p>jwt令牌中记录了用户身份信息，当客户端携带jwt访问资源服务，资源服务验签通过后将前两部分的内容还原即可取出用户的身份信息，并将用户身份信息放在了SecurityContextHolder上下文，SecurityContext与当前线程进行绑定，方便获取用户身份。</p><p>还以查询课程接口为例，进入查询课程接口的代码中，添加获取用户身份的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;根据课程id查询课程基础信息&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/course/&#123;courseId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CourseBaseInfoDto <span class="title function_">getCourseBaseById</span><span class="params">(<span class="meta">@PathVariable(&quot;courseId&quot;)</span> Long courseId)</span>&#123;</span><br><span class="line">    <span class="comment">//取出当前用户身份</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">    System.out.println(principal);</span><br><span class="line">    <span class="keyword">return</span> courseBaseInfoService.getCourseBaseInfo(courseId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试时需要注意：</p><p>1、首先在资源服务配置中指定安全拦截机制 /course/开头的请求需要认证，即请求/course/{courseId}接口需要携带jwt令牌且签证通过。</p><p>2、认证服务生成jwt令牌将用户身份信息写入令牌，目前还是将用户信息硬编码并暂放在内存中。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里配置用户信息,这里暂时使用这种方式将用户存储在内存中</span></span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;123&quot;</span>).authorities(<span class="string">&quot;p1&quot;</span>).build());</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;456&quot;</span>).authorities(<span class="string">&quot;p2&quot;</span>).build());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、我们在使用密码模式生成jwt令牌时用的是zhangsan的信息，所以jwt令牌中存储了zhangsan的信息，那么在资源服务中应该取出zhangsan的信息才对。</p><p>清楚了以上内容，下边重启内容管理服务，跟踪取到的用户身份是否正确。</p><h2 id="2-5-网关认证"><a href="#2-5-网关认证" class="headerlink" title="2.5 网关认证"></a>2.5 网关认证</h2><h3 id="2-5-1-技术方案"><a href="#2-5-1-技术方案" class="headerlink" title="2.5.1 技术方案"></a>2.5.1 技术方案</h3><p>到目前为止，测试通过了认证服务颁发jwt令牌，客户端携带jwt访问资源服务，资源服务对jwt的合法性进行验证。如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NGM0MDk5ZGU4ZTFiY2M5YTg2OGE2MmI5MDdmYjAzZTFfUFZtbFpqVHB4OTc2bHNENkNrTTZHR1Q4WlZzQUFOU2hfVG9rZW46RVdPMmJmeDZTb3JlUkd4NDJnVGNsMmVObjdkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>仔细观察此图，遗漏了本项目架构中非常重要的组件：网关，加上网关并完善后如下图所示：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ODg3MjI2MGI2M2MwYjQ4M2Q5ZjgwNGY1NDQ0YzRiY2NfWlU4V3Y0cDBTVlAwd00ycDBZM1BxaElLZEVxT0JabEZfVG9rZW46UzJpRWJhRnRQbzl5Tll4cUpZRGMzSmJwbmJnXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>所有访问微服务的请求都要经过网关，在网关进行用户身份的认证可以将很多非法的请求拦截到微服务以外，这叫做网关认证。</p><p>下边需要明确网关的职责：</p><p>1、网站白名单维护</p><p>针对不用认证的URL全部放行。</p><p>2、校验jwt的合法性。</p><p>除了白名单剩下的就是需要认证的请求，网关需要验证jwt的合法性，jwt合法则说明用户身份合法，否则说明身份不合法则拒绝继续访问。</p><p>网关负责授权吗？</p><p>网关不负责授权，对请求的授权操作在各个微服务进行，因为微服务最清楚用户有哪些权限访问哪些接口。</p><h3 id="2-5-2-实现网关认证"><a href="#2-5-2-实现网关认证" class="headerlink" title="2.5.2 实现网关认证"></a>2.5.2 实现网关认证</h3><p>下边实现网关认证，实现以下职责：</p><p>1、网站白名单维护</p><p>针对不用认证的URL全部放行。</p><p>2、校验jwt的合法性。</p><p>除了白名单剩下的就是需要认证的请求，网关需要验证jwt的合法性，jwt合法则说明用户身份合法，否则说明身份不合法则拒绝继续访问。</p><p>1、在网关工程添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、拷贝课程资料下网关认证配置类到网关工程的config包下。</p><p>3、配置白名单文件security-whitelist.properties</p><p>内容如下（持续补充）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/auth/**=认证地址</span><br><span class="line">/content/open/**=内容管理公开访问接口</span><br><span class="line">/media/open/**=媒资管理公开访问接口</span><br></pre></td></tr></table></figure><p>重启网关工程，进行测试</p><p>1、申请令牌</p><p>2、通过网关访问资源服务</p><p>这里访问内容管理服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### 通过网关访问资源服务</span><br><span class="line">GET http://localhost:63010/content/course/2</span><br><span class="line">Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQzNjIzMTAsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6Ijc2OTkwMGNiLWM1ZjItNGRiNC1hZWJmLWY1MzgxZDQxZWMyZCIsImNsaWVudF9pZCI6ImMxIn0.lOITjUgYg2HCh5mDPK9EvJJqz-tIupKVfmP8yWJQIKs</span><br></pre></td></tr></table></figure><p>当token正确时可以正常访问资源服务，token验证失败返回token无效：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;errMessage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;认证令牌无效&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>注意：网关鉴权功能调试通过后，由于目前还没有开发认证功能，前端请求网关的URL不在白名单中间时会“没有认证”的错误，暂时在白名单中添加 全部放行配置，待认证功能开发完成再屏蔽全部放行配置，</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjUxZDYxNDg3YzFlNzAyOWExYTRkYWI1Zjk5OTlkY2RfN091UEczZzJuM2dramU4TUpJRjFOS0g1SUtnNnpHY1FfVG9rZW46U2hrdWIyVk1zb1phbTd4SmxsZGNWSk9MbkxkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>由于是在网关处进行令牌校验，所以在微服务处不再校验令牌的合法性，修改内容管理服务的ResouceServerConfig类，屏蔽authenticated()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  http.csrf().disable()</span><br><span class="line">          .authorizeRequests()</span><br><span class="line"><span class="comment">//          .antMatchers(&quot;/r/**&quot;,&quot;/course/**&quot;).authenticated()//所有/r/**的请求必须认证通过</span></span><br><span class="line">          .anyRequest().permitAll()</span><br><span class="line">  ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="3-用户认证"><a href="#3-用户认证" class="headerlink" title="3 用户认证"></a>3 用户认证</h1><h2 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h2><p>至此我们了解了使用Spring Security进行认证授权的过程，本节实现用户认证功能。</p><p>目前各大网站的认证方式非常丰富：账号密码认证、手机验证码认证、扫码登录等。</p><p>本项目也要支持多种认证试。</p><h2 id="3-2-连接用户中心数据库"><a href="#3-2-连接用户中心数据库" class="headerlink" title="3.2 连接用户中心数据库"></a>3.2 连接用户中心数据库</h2><h3 id="3-2-1-连接数据库认证"><a href="#3-2-1-连接数据库认证" class="headerlink" title="3.2.1 连接数据库认证"></a>3.2.1 连接数据库认证</h3><p>基于的认证流程在研究Spring Security过程中已经测试通过，到目前为止用户认证流程如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MjdjOTY1NTZmYjUzZTlkMTVjMzExNTVkMDU1MTJjOGJfTDd3SFVGaFpOV0RWTzE4WDRqdGUzcTFjZHRjOTRqQnJfVG9rZW46RzliNmJYVUFab2RBanl4RFZ5cGNXemdLbmxjXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>认证所需要的用户信息存储在用户中心数据库，现在需要将认证服务连接数据库查询用户信息。</p><p>在研究Spring Security的过程中是将用户信息硬编码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里配置用户信息,这里暂时使用这种方式将用户存储在内存中</span></span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;123&quot;</span>).authorities(<span class="string">&quot;p1&quot;</span>).build());</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;456&quot;</span>).authorities(<span class="string">&quot;p2&quot;</span>).build());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要认证服务中连接用户中心数据库查询用户信息。</p><p>如何使用Spring Security连接数据库认证吗？</p><p>前边学习Spring Security工作原理时有一张执行流程图，如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ4NDg1YzgzYzU1NTczNmI1YjI0NzQ2ZDFmZjZiMTlfRHVSMGJ4aG9SV1phemxWSklUSU80VENtNFZ0YVgxYTZfVG9rZW46VE5ET2JFSWJzb1BXZWJ4M2NsQmNFWURXbnRiXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>用户提交账号和密码由DaoAuthenticationProvider调用UserDetailsService的loadUserByUsername()方法获取UserDetails用户信息。</p><p>查询DaoAuthenticationProvider的源代码如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDRmMTAyMWY2OTg0NTgzMTY5NzJkOGY1YjMzYzA3ZTNfUzc0Mkg1NnZBdWdraUk5Z1NkVUo2NWRla1VtWkFaUEJfVG9rZW46VnY3ZWJlODJob1k3VDV4aVJ2M2N6OE0zbmZlXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>UserDetailsService是一个接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.security.core.userdetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String var1)</span> <span class="keyword">throws</span> UsernameNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDetails是用户信息接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只要实现UserDetailsService 接口查询数据库得到用户信息返回UserDetails 类型的用户信息即可,框架调用loadUserByUsername()方法拿到用户信息之后是如何执行的，见下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM2ZDFhYjg1MjQ1ODNjM2QyZjYwODk5YzA3NDdjYjdfQVo5b1k0QUJHclpuME5DMGZEREVxSEdJRkJSblZ2d2dfVG9rZW46QXRVZWJwM0pqb3Q1aE94OUo4WWNtWmtWbkloXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>首先屏蔽原来定义的UserDetailsService。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//配置用户信息服务</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public UserDetailsService userDetailsService() &#123;</span></span><br><span class="line"><span class="comment">//        //这里配置用户信息,这里暂时使用这种方式将用户存储在内存中</span></span><br><span class="line"><span class="comment">//        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();</span></span><br><span class="line"><span class="comment">//        manager.createUser(User.withUsername(&quot;zhangsan&quot;).password(&quot;123&quot;).authorities(&quot;p1&quot;).build());</span></span><br><span class="line"><span class="comment">//        manager.createUser(User.withUsername(&quot;lisi&quot;).password(&quot;456&quot;).authorities(&quot;p2&quot;).build());</span></span><br><span class="line"><span class="comment">//        return manager;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure><p>下边自定义UserDetailsService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 根据账号查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  账号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, s));</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出数据库存储的正确密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span>  <span class="operator">=</span>user.getPassword();</span><br><span class="line">        <span class="comment">//用户权限,如果不加报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">        String[] authorities= &#123;<span class="string">&quot;test&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建UserDetails对象,权限信息待实现授权功能时再向UserDetail中加入</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(user.getUsername()).password(password).authorities(authorities).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库中的密码加过密的，用户输入的密码是明文，我们需要修改密码格式器PasswordEncoder，原来使用的是NoOpPasswordEncoder，它是通过明文方式比较密码，现在我们修改为BCryptPasswordEncoder，它是将用户输入的密码编码为BCrypt格式与数据库中的密码进行比对。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        //密码为明文方式</span></span><br><span class="line"><span class="comment">//        return NoOpPasswordEncoder.getInstance();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们通过测试代码测试BCryptPasswordEncoder，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;111111&quot;</span>;</span><br><span class="line">    <span class="type">PasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        <span class="comment">//每个计算出的Hash值都不一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hashPass</span> <span class="operator">=</span> passwordEncoder.encode(password);</span><br><span class="line">        System.out.println(hashPass);</span><br><span class="line">        <span class="comment">//虽然每次计算的密码Hash值不一样但是校验是通过的</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">f</span> <span class="operator">=</span> passwordEncoder.matches(password, hashPass);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改数据库中的密码为Bcrypt格式，并且记录明文密码，稍后申请令牌时需要。</p><p>由于修改密码编码方式还需要将客户端的密钥更改为Bcrypt格式.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span></span><br><span class="line">          <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        clients.inMemory()<span class="comment">// 使用in-memory存储</span></span><br><span class="line">                .withClient(<span class="string">&quot;XcWebApp&quot;</span>)<span class="comment">// client_id</span></span><br><span class="line"><span class="comment">//                .secret(&quot;secret&quot;)//客户端密钥</span></span><br><span class="line">                .secret(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;XcWebApp&quot;</span>))<span class="comment">//客户端密钥</span></span><br><span class="line">                .resourceIds(<span class="string">&quot;xuecheng-plus&quot;</span>)<span class="comment">//资源列表</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>, <span class="string">&quot;password&quot;</span>,<span class="string">&quot;client_credentials&quot;</span>,<span class="string">&quot;implicit&quot;</span>,<span class="string">&quot;refresh_token&quot;</span>)<span class="comment">// 该client允许的授权类型authorization_code,password,refresh_token,implicit,client_credentials</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)<span class="comment">// 允许的授权范围</span></span><br><span class="line">                .autoApprove(<span class="literal">false</span>)<span class="comment">//false跳转到授权页面</span></span><br><span class="line">                <span class="comment">//客户端接收授权码的重定向地址</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.51xuecheng.cn&quot;</span>)</span><br><span class="line">   ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>现在重启认证服务。</p><p>下边使用httpclient进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 密码模式</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=stu1&amp;password=<span class="number">111111</span></span><br></pre></td></tr></table></figure><p>输入正确的账号和密码，申请令牌成功。</p><p>输入错误的密码，报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="string">&quot;invalid_grant&quot;</span>,</span><br><span class="line">  <span class="string">&quot;error_description&quot;</span>: <span class="string">&quot;用户名或密码错误&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入错误的账号，报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="string">&quot;unauthorized&quot;</span>,</span><br><span class="line">  <span class="string">&quot;error_description&quot;</span>: <span class="string">&quot;UserDetailsService returned null, which is an interface contract violation&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-扩展用户身份信息"><a href="#3-2-3-扩展用户身份信息" class="headerlink" title="3.2.3 扩展用户身份信息"></a>3.2.3 扩展用户身份信息</h3><p>用户表中存储了用户的账号、手机号、email，昵称、qq等信息，UserDetails接口只返回了username、密码等信息，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要扩展用户身份的信息，在jwt令牌中存储用户的昵称、头像、qq等信息。</p><p>如何扩展Spring Security的用户身份信息呢？</p><p>在认证阶段DaoAuthenticationProvider会调用UserDetailService查询用户的信息，这里是可以获取到齐全的用户信息的。由于JWT令牌中用户身份信息来源于UserDetails，UserDetails中仅定义了username为用户的身份信息，这里有两个思路：第一是可以扩展UserDetails，使之包括更多的自定义属性，第二也可以扩展username的内容 ，比如存入json数据内容作为username的内容。相比较而言，方案二比较简单还不用破坏UserDetails的结构，我们采用方案二。</p><p>修改UserServiceImpl如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 根据账号查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  账号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, s));</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出数据库存储的正确密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span>  <span class="operator">=</span>user.getPassword();</span><br><span class="line">        <span class="comment">//用户权限,如果不加报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">        String[] authorities = &#123;<span class="string">&quot;p1&quot;</span>&#125;;</span><br><span class="line">       <span class="comment">//为了安全在令牌中不放密码</span></span><br><span class="line">        user.setPassword(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//将user对象转json</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">        <span class="comment">//创建UserDetails对象</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(userString).password(password).authorities(authorities).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启认证服务，重新生成令牌，生成成功。</p><p>我们可以使用check_token查询jwt的内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###校验jwt令牌</span><br><span class="line">POST <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span>auth_host<span class="punctuation">&#125;</span><span class="punctuation">&#125;</span>/oauth/check_token?token=</span><br></pre></td></tr></table></figure><p>响应示例如下，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;res1&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;user_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;\&quot;birthday\&quot;:\&quot;2022-09-28T19:28:46\&quot;,\&quot;createTime\&quot;:\&quot;2022-09-28T08:32:03\&quot;,\&quot;id\&quot;:\&quot;50\&quot;,\&quot;name\&quot;:\&quot;学生1\&quot;,\&quot;nickname\&quot;:\&quot;大水牛\&quot;,\&quot;password\&quot;:\&quot;$2a$10$0pt7WlfTbnPDTcWtp/.2Mu5CTXvohnNQhR628qq4RoKSc0dGAdEgm\&quot;,\&quot;sex\&quot;:\&quot;1\&quot;,\&quot;status\&quot;:\&quot;1\&quot;,\&quot;username\&quot;:\&quot;stu1\&quot;,\&quot;userpic\&quot;:\&quot;http://file.51xuecheng.cn/dddf\&quot;,\&quot;utype\&quot;:\&quot;101001\&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;all&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1664372184</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorities&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;p1&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;73da9f7b-bd8c-45ac-9add-46b711d11fb8&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;client_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>user_name存储了用户信息的json格式，在资源服务中就可以取出该json格式的内容转为用户对象去使用。</p><h3 id="3-2-3-资源服务获取用户身份"><a href="#3-2-3-资源服务获取用户身份" class="headerlink" title="3.2.3 资源服务获取用户身份"></a>3.2.3 资源服务获取用户身份</h3><p>下边编写一个工具类在各个微服务中去使用，获取当前登录用户的对象。</p><p>在content-api中定义此类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.content.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 获取当前用户身份工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/18 18:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> XcUser <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">principalObj</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">            <span class="keyword">if</span> (principalObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="comment">//取出用户身份信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">principal</span> <span class="operator">=</span> principalObj.toString();</span><br><span class="line">                <span class="comment">//将json转成对象</span></span><br><span class="line">                <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(principal, XcUser.class);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;获取当前登录用户身份出错:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">XcUser</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String salt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String nickname;</span><br><span class="line">        <span class="keyword">private</span> String wxUnionid;</span><br><span class="line">        <span class="keyword">private</span> String companyId;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 头像</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String userpic;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String utype;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LocalDateTime birthday;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String cellphone;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String qq;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用户状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边在内容管理服务中测试此工具类，以查询课程信息接口为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;根据课程id查询课程基础信息&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/course/&#123;courseId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CourseBaseInfoDto <span class="title function_">getCourseBaseById</span><span class="params">(<span class="meta">@PathVariable(&quot;courseId&quot;)</span> Long courseId)</span>&#123;</span><br><span class="line">    <span class="comment">//取出当前用户身份</span></span><br><span class="line"><span class="comment">//    Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span></span><br><span class="line">   SecurityUtil.<span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> SecurityUtil.getUser();</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> courseBaseInfoService.getCourseBaseInfo(courseId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启内容管理服务：</p><p>1、启动认证服务、网关、内容管理服务</p><p>2、生成新的令牌</p><p>3、携带令牌访问内容管理服务的查询课程接口</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NjFhNTIzYjBiMzAzMTQ5MjMxNzUzNDBhNjU5MmRmNTdfNDVSdjZQdUNGZ2ZnV2tTajhtbFdNYnhPcks5eWRYQ1BfVG9rZW46QnVhQmJINHZjbzNvUGV4ckJJaWNKc2JYbkNlXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><h2 id="3-3-支持认证方式多样"><a href="#3-3-支持认证方式多样" class="headerlink" title="3.3 支持认证方式多样"></a>3.3 支持认证方式多样</h2><h3 id="3-3-1-统一认证入口"><a href="#3-3-1-统一认证入口" class="headerlink" title="3.3.1 统一认证入口"></a>3.3.1 统一认证入口</h3><p>目前各大网站的认证方式非常丰富：账号密码认证、手机验证码认证、扫码登录等。基于当前研究的Spring Security认证流程如何支持多样化的认证方式呢？</p><p>1、支持账号和密码认证</p><p>采用OAuth2协议的密码模式即可实现。</p><p>2、支持手机号加验证码认证</p><p>用户认证提交的是手机号和验证码，并不是账号和密码。</p><p>3、微信扫码认证</p><p>基于OAuth2协议与微信交互，学成在线网站向微信服务器申请到一个令牌，然后携带令牌去微信查询用户信息，查询成功则用户在学成在线项目认证通过。</p><p>目前我们测试通过OAuth2的密码模式，用户认证会提交账号和密码，由DaoAuthenticationProvider调用UserDetailsService的loadUserByUsername()方法获取UserDetails用户信息。</p><p>在前边我们自定义了UserDetailsService接口实现类，通过loadUserByUsername()方法根据账号查询用户信息。</p><p>而不同的认证方式提交的数据不一样，比如：手机加验证码方式会提交手机号和验证码，账号密码方式会提交账号、密码、验证码。</p><p>我们可以在loadUserByUsername()方法上作文章，将用户原来提交的账号数据改为提交json数据，json数据可以扩展不同认证方式所提交的各种参数。</p><p>首先创建一个DTO类表示认证的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.model.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 认证用户请求参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 10:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthParamsDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">//域  用于扩展</span></span><br><span class="line">    <span class="keyword">private</span> String cellphone;<span class="comment">//手机号</span></span><br><span class="line">    <span class="keyword">private</span> String checkcode;<span class="comment">//验证码</span></span><br><span class="line">    <span class="keyword">private</span> String checkcodekey;<span class="comment">//验证码key</span></span><br><span class="line">    <span class="keyword">private</span> String authType; <span class="comment">// 认证的类型   password:用户名密码模式类型    sms:短信模式类型</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; payload = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//附加数据，作为扩展，不同认证类型可拥有不同的附加数据。如认证类型为短信时包含smsKey : sms:3d21042d054548b08477142bbca95cfa; 所有情况下都包含clientId</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时loadUserByUsername()方法可以修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义UserDetailsService用来对接Spring Security</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 查询用户信息组成用户身份信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  AuthParamsDto类型的json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AuthParamsDto</span> <span class="variable">authParamsDto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将认证参数转为AuthParamsDto类型</span></span><br><span class="line">            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;认证请求不符合项目要求:&#123;&#125;&quot;</span>,s);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;认证请求数据格式不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//账号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authParamsDto.getUsername();</span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, username));</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出数据库存储的正确密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span>  <span class="operator">=</span>user.getPassword();</span><br><span class="line">        <span class="comment">//用户权限,如果不加报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">        String[] authorities = &#123;<span class="string">&quot;p1&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//将user对象转json</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">        <span class="comment">//创建UserDetails对象</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(userString).password(password).authorities(authorities).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来的DaoAuthenticationProvider 会进行密码校验，现在重新定义DaoAuthenticationProviderCustom类，重写类的additionalAuthenticationChecks方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.BadCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.dao.DaoAuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义DaoAuthenticationProvider</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 10:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoAuthenticationProviderCustom</span> <span class="keyword">extends</span> <span class="title class_">DaoAuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDetailsService</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.setUserDetailsService(userDetailsService);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//屏蔽密码对比</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改WebSecurityConfig类指定daoAuthenticationProviderCustom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DaoAuthenticationProviderCustom daoAuthenticationProviderCustom;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    auth.authenticationProvider(daoAuthenticationProviderCustom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时可以重启认证服务，测试申请令牌接口，传入的账号信息改为json数据，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">################扩展认证请求参数后######################</span><br><span class="line">###密码模式</span><br><span class="line">POST &#123;&#123;auth_host&#125;&#125;/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=&#123;&quot;username&quot;:&quot;stu1&quot;,&quot;authType&quot;:&quot;password&quot;,&quot;password&quot;:&quot;111111&quot;&#125;</span><br></pre></td></tr></table></figure><p>经过测试发现loadUserByUsername()方法可以正常接收到认证请求中的json数据。</p><p>有了这些认证参数我们可以定义一个认证Service接口去进行各种方式的认证。</p><p>定义用户信息，为了扩展性让它继承XcUser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XcUserExt</span> <span class="keyword">extends</span> <span class="title class_">XcUser</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义认证Service 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 认证service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@description</span> 认证方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> authParamsDto 认证参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> com.xuecheng.ucenter.model.po.XcUser 用户信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@date</span> 2022/9/29 12:11</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadUserByUsername()修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 查询用户信息组成用户身份信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  AuthParamsDto类型的json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AuthParamsDto</span> <span class="variable">authParamsDto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将认证参数转为AuthParamsDto类型</span></span><br><span class="line">            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;认证请求不符合项目要求:&#123;&#125;&quot;</span>,s);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;认证请求数据格式不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始认证</span></span><br><span class="line">        authService.execute(authParamsDto);</span><br><span class="line">        .....</span><br></pre></td></tr></table></figure><p>到此我们基于Spring Security认证流程修改为如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YmVjYTk5YzZlMTI3MWJhMmJiMDdhNmQ2ZWZiMGI5ODVfdjE4MTdmcDY4VFRSZlNiVmlaakIxa0RCRWszdHlvOXpfVG9rZW46TFVFQWJzQW9Lb1FDOVF4c2t5T2NtdktDbm9kXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><h3 id="3-3-2-实现账号密码认证"><a href="#3-3-2-实现账号密码认证" class="headerlink" title="3.3.2 实现账号密码认证"></a>3.3.2 实现账号密码认证</h3><p>上节定义了AuthService认证接口，下边实现该接口实现账号密码认证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.service.AuthService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 账号密码认证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Service(&quot;password_authservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//账号</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authParamsDto.getUsername();</span><br><span class="line">  <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, username));</span><br><span class="line">  <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">   <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号不存在&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">XcUserExt</span> <span class="variable">xcUserExt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUserExt</span>();</span><br><span class="line">  BeanUtils.copyProperties(user,xcUserExt);</span><br><span class="line">  <span class="comment">//校验密码</span></span><br><span class="line">  <span class="comment">//取出数据库存储的正确密码</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">passwordDb</span>  <span class="operator">=</span>user.getPassword();</span><br><span class="line">  <span class="type">String</span> <span class="variable">passwordForm</span> <span class="operator">=</span> authParamsDto.getPassword();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> passwordEncoder.matches(passwordForm, passwordDb);</span><br><span class="line">  <span class="keyword">if</span>(!matches)&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号或密码错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xcUserExt;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改UserServiceImpl类，根据认证方式使用不同的认证bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.service.AuthService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义UserDetailsService用来对接Spring Security</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    AuthService authService;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 查询用户信息组成用户身份信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s  AuthParamsDto类型的json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.security.core.userdetails.UserDetails</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/28 18:30</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AuthParamsDto</span> <span class="variable">authParamsDto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将认证参数转为AuthParamsDto类型</span></span><br><span class="line">            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;认证请求不符合项目要求:&#123;&#125;&quot;</span>,s);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;认证请求数据格式不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authType</span> <span class="operator">=</span> authParamsDto.getAuthType();</span><br><span class="line">        <span class="type">AuthService</span> <span class="variable">authService</span> <span class="operator">=</span>  applicationContext.getBean(authType + <span class="string">&quot;_authservice&quot;</span>,AuthService.class);</span><br><span class="line">        <span class="type">XcUserExt</span> <span class="variable">user</span> <span class="operator">=</span> authService.execute(authParamsDto);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getUserPrincipal(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user  用户id，主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> com.xuecheng.ucenter.model.po.XcUser 用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/9/29 12:19</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">getUserPrincipal</span><span class="params">(XcUserExt user)</span>&#123;</span><br><span class="line">        <span class="comment">//用户权限,如果不加报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">        String[] authorities = &#123;<span class="string">&quot;p1&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">        <span class="comment">//为了安全在令牌中不放密码</span></span><br><span class="line">        user.setPassword(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//将user对象转json</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">        <span class="comment">//创建UserDetails对象</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(userString).password(password ).authorities(authorities).build();</span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启认证服务，测试申请令牌接口。</p><p>1、测试账号和密码都正确的情况是否可以申请令牌成功。</p><p>2、测试密码错误的情况。</p><p>3、测试账号不存在情况。</p><h2 id="3-4-验证码服务"><a href="#3-4-验证码服务" class="headerlink" title="3.4 验证码服务"></a>3.4 验证码服务</h2><h3 id="3-4-1-部署验证码服务工程"><a href="#3-4-1-部署验证码服务工程" class="headerlink" title="3.4.1 部署验证码服务工程"></a>3.4.1 部署验证码服务工程</h3><p>在认证时一般都需要输入验证码，验证码有什么用？</p><p>验证码可以防止恶性攻击，比如：XSS跨站脚本攻击、CSRF跨站请求伪造攻击，一些比较复杂的图形验证码可以有效的防止恶性攻击。</p><p>为了保护系统的安全在一些比较重要的操作都需要验证码。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MzNmM2RjNzNjZTk5OTRjMDQ0MjhmZDJjNWY4YzZiMzNfVGcyM01pMFJlaVVETGpteUY5THZNVmhkU3lEZ1ZxNU1fVG9rZW46TjJJZGJmVzFFb3VtOUp4T2RDcmNLRjZkbmNiXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>验证码的类型也有很多：图片、语音、手机短信验证码等。</p><p>本项目创建单独的验证码服务为各业务提供验证码的生成、校验等服务。</p><p>拷贝课程资料目录xuecheng-plus-checkcode验证码服务工程到自己的工程目录。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjI1OWNhNzI3YjQ2Mjk4MTdmNDU0YjBiNDQ4ZTBjMDBfdlIyQnpwWjZsUllhWkdZTGdTYWVIdVJEMjBIQ2RuZGhfVG9rZW46UzdGM2J4TzN4b2FtTjl4VnVQVGN0VTM3bklkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>定义nacos配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/checkcode</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">63075</span></span><br></pre></td></tr></table></figure><p>注意修改bootstrap.yml中的命名空间为自己定义的命名空间。</p><p>配置redis-dev.yaml，保存redis服务启动</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OTc0YTgwZWMxYTFmODM5MzhiZGQwOWQ4NmNkYmEyNDRfa1dEVkh1VXdsVUl3RHExMXlhQUloT1lrczJOck1xdUlfVG9rZW46VkNCNWIyVWllb3RybWt4bmVhVWM1ek5UblVlXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  redis:</span><br><span class="line">    host: 192.168.101.65</span><br><span class="line">    port: 6379</span><br><span class="line">    password: redis</span><br><span class="line">    database: 0</span><br><span class="line">    lettuce:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 20</span><br><span class="line">        max-idle: 10</span><br><span class="line">        min-idle: 0</span><br><span class="line">    timeout: 10000</span><br><span class="line">    #redisson:</span><br><span class="line">      #配置文件目录</span><br><span class="line">      #config: classpath:singleServerConfig.yaml</span><br></pre></td></tr></table></figure><h3 id="3-4-2-验证码接口测试"><a href="#3-4-2-验证码接口测试" class="headerlink" title="3.4.2 验证码接口测试"></a>3.4.2 验证码接口测试</h3><p>验证码服务对外提供的接口有：</p><p>1、生成验证码</p><p>2、校验验证码。</p><p>如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NTUzNjg0NTlhODk1NDdkOTExN2EzZmRhNGE1OWRlOGRfV1lBME9KRzRHVEhUZjRtMUh5aTdIZWQ3UFBjTExXTldfVG9rZW46TExYd2JjVVJnb3NsQUx4UU1qbGNVQ21WblVjXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>验证码服务如何生成并校验验证码？</p><p>拿图片验证码举例：</p><p>1、先生成一个指定位数的验证码，根据需要可能是数字、数字字母组合或文字。</p><p>2、根据生成的验证码生成一个图片并返回给页面</p><p>3、给生成的验证码分配一个key，将key和验证码一同存入缓存。这个key和图片一同返回给页面。</p><p>4、用户输入验证码，连同key一同提交至认证服务。</p><p>5、认证服务拿key和输入的验证码请求验证码服务去校验</p><p>6、验证码服务根据key从缓存取出正确的验证码和用户输入的验证码进行比对，如果相同则校验通过，否则不通过。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MDEzZmFhZDMzOTNmNzVlYjQzMzM3YzU5MTc4YTYzMDVfdkdRRlVUSWFrU1FSejBKVHVsOEFsSjFDTm1Sb0pRUWhfVG9rZW46V1BVZGJ1bnZCb0dabER4clAwSWNUVmlNbmVlXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>根据接口分析，验证码服务接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.checkcode.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xuecheng.base.model.RestResponse;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.checkcode.model.CheckCodeParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.checkcode.model.CheckCodeResultDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.checkcode.service.CheckCodeService;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParam;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParams;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 验证码服务接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 18:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Api(value = &quot;验证码服务接口&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckCodeController</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;生成验证信息&quot;, notes=&quot;生成验证信息&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/pic&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CheckCodeResultDto <span class="title function_">generatePicCheckCode</span><span class="params">(CheckCodeParamsDto checkCodeParamsDto)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;校验&quot;, notes=&quot;校验&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;name&quot;, value = &quot;业务名称&quot;, required = true, dataType = &quot;String&quot;, paramType=&quot;query&quot;),</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;key&quot;, value = &quot;验证key&quot;, required = true, dataType = &quot;String&quot;, paramType=&quot;query&quot;),</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;code&quot;, value = &quot;验证码&quot;, required = true, dataType = &quot;String&quot;, paramType=&quot;query&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/verify&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">verify</span><span class="params">(String key, String code)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、生成验证码接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 申请验证码</span><br><span class="line">POST &#123;&#123;checkcode_host&#125;&#125;/checkcode/pic</span><br></pre></td></tr></table></figure><p>2、校验验证码接口</p><p>根据生成验证码返回的key以及日志中输出正确的验证码去测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 校验验证码</span></span><br><span class="line">POST &#123;&#123;checkcode_host&#125;&#125;/checkcode/verify?key=checkcode4506b95bddbe46cdb0d56810b747db1b&amp;code=70dl</span><br></pre></td></tr></table></figure><h2 id="3-5-账号密码认证"><a href="#3-5-账号密码认证" class="headerlink" title="3.5 账号密码认证"></a>3.5 账号密码认证</h2><h3 id="3-5-1-需求分析"><a href="#3-5-1-需求分析" class="headerlink" title="3.5.1 需求分析"></a>3.5.1 需求分析</h3><p>到目前为止账号和密码认证所需要的技术、组件都已开发完毕，下边实现账号密码认证，输出如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDUxMGNjZDlhYjY1ZWNmODdlMWQ5MDM1NWZlZjhhZGRfeDE2Q1IxT2NQdzlGYTljdzhJYXJ3WEtaWUNxVEJzeWtfVG9rZW46TklmRGI5S1lEbzJ3clV4SzdjR2NOd25vbkFkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>执行流程如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDBkYjkzZWYwM2Q1YTc2YjBhNjM4ZWE4ZmRmZjE2MTJfS1ZrZkFaWDVXMVBDOUYzcm5BMEVLaEJ3WFBPM1FsM1NfVG9rZW46UVRsR2IzNHJmb0RuelN4bTYydGNiRVBobjdmXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><h3 id="3-5-2-账号密码认证开发"><a href="#3-5-2-账号密码认证开发" class="headerlink" title="3.5.2 账号密码认证开发"></a>3.5.2 账号密码认证开发</h3><p>1、在认证服务定义远程调用验证码服务的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.feignclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/20 20:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@FeignClient(value = &quot;checkcode&quot;,fallbackFactory = CheckCodeClientFactory.class)</span></span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/checkcode&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CheckCodeClient</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@PostMapping(value = &quot;/verify&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> Boolean <span class="title function_">verify</span><span class="params">(<span class="meta">@RequestParam(&quot;key&quot;)</span> String key,<span class="meta">@RequestParam(&quot;code&quot;)</span> String code)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CheckCodeClientFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckCodeClientFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;CheckCodeClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CheckCodeClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CheckCodeClient</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Boolean <span class="title function_">verify</span><span class="params">(String key, String code)</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;调用验证码服务熔断异常:&#123;&#125;&quot;</span>, throwable.getMessage());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages=&#123;&quot;com.xuecheng.*.feignclient&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p>配置文件引入feign-dev.yaml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- data-id: feign-$&#123;spring.profiles.active&#125;.yaml</span><br><span class="line">  group: xuecheng-plus-common</span><br><span class="line">  refresh: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>2、完善PasswordAuthServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.feignclient.CheckCodeClient;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.mapper.XcUserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.dto.AuthParamsDto;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.model.po.XcUser;</span><br><span class="line"><span class="keyword">import</span> com.xuecheng.ucenter.service.AuthService;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 账号密码认证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Service(&quot;password_authservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> PasswordEncoder passwordEncoder;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> CheckCodeClient checkCodeClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> XcUser <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//校验验证码</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">checkcode</span> <span class="operator">=</span> authParamsDto.getCheckcode();</span><br><span class="line">  <span class="type">String</span> <span class="variable">checkcodekey</span> <span class="operator">=</span> authParamsDto.getCheckcodekey();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(StringUtils.isBlank(checkcodekey) || StringUtils.isBlank(checkcode))&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;验证码为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">Boolean</span> <span class="variable">verify</span> <span class="operator">=</span> checkCodeClient.verify(checkcodekey, checkcode);</span><br><span class="line">  <span class="keyword">if</span>(!verify)&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;验证码输入错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//账号</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authParamsDto.getUsername();</span><br><span class="line">  <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, username));</span><br><span class="line">  <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">   <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号不存在&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//校验密码</span></span><br><span class="line">  <span class="comment">//取出数据库存储的正确密码</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">passwordDb</span>  <span class="operator">=</span>user.getPassword();</span><br><span class="line">  <span class="type">String</span> <span class="variable">passwordForm</span> <span class="operator">=</span> authParamsDto.getPassword();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> passwordEncoder.matches(passwordForm, passwordDb);</span><br><span class="line">  <span class="keyword">if</span>(!matches)&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号或密码错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小技巧：目前账号密码方式添加了验证码校验，为了后期获取令牌方便可以重新定义一个不需要验证码校验的认证类AuthService ，AuthService 中去掉验证码的校验，方便生成令牌。</p><h3 id="3-5-3-账号密码认证测试"><a href="#3-5-3-账号密码认证测试" class="headerlink" title="3.5.3 账号密码认证测试"></a>3.5.3 账号密码认证测试</h3><p>1、使用浏览器访问 <a href="http://www.51xuecheng.cn/sign.html">http://www.51xuecheng.cn/sign.html</a></p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MTUxNzQ1YTc5YmI1MWY3NTdmNDliZDg5YjI0NzcxNGJfYng3RVg1b3lkTHBqZWpiblA1QTlrZ3FzWGc3aWhQMWlfVG9rZW46WGx5RWJVeVg2b1Q4dHd4eEFDMGNIZ01Obm5oXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>2、首先测试验证码，分别输入正确的验证码和错误的验证码进行测试</p><p>3、输入正确的账号密码和错误的账号密码进行测试</p><p>登录成功将jwt令牌存储cookie.</p><p>4、测试自动登录</p><p>勾选自动登录cookie生成时间为30天，不勾选自动登录关闭浏览器窗口后自动删除cookie。</p><h1 id="4-微信扫码登录"><a href="#4-微信扫码登录" class="headerlink" title="4 微信扫码登录"></a>4 微信扫码登录</h1><h2 id="4-1-接入规范"><a href="#4-1-接入规范" class="headerlink" title="4.1 接入规范"></a>4.1 接入规范</h2><h3 id="4-1-1-接入流程"><a href="#4-1-1-接入流程" class="headerlink" title="4.1.1 接入流程"></a>4.1.1 接入流程</h3><p>微信扫码登录基于OAuth2协议的授权码模式，</p><p>接口文档：</p><p><a href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html">https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html</a></p><p>流程如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQyZWFjZWZmZTg1MDYyMmRjMTMwNTNhODg2MDIyMTRfc1lselljdGhSaURxendsREJmQngxQjBoc3FWWmlvZmZfVG9rZW46TTZYR2JGaWt5b2ppWmN4ZzVUNWNBakNqbnFiXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>第三方应用获取access_token令牌后即可请求微信获取用户的信息，成功获取到用户的信息表示用户在第三方应用认证成功。</p><h3 id="4-1-2-请求获取授权码"><a href="#4-1-2-请求获取授权码" class="headerlink" title="4.1.2 请求获取授权码"></a>4.1.2 请求获取授权码</h3><p>第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope=snsapi_login），则可以通过在 PC 端打开以下链接： <a href="https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect">https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a> 若提示“该链接无法访问”，请检查参数是否填写错误，如redirect_uri的域名与审核时填写的授权域名不一致或 scope 不为snsapi_login。</p><p><strong>参数说明</strong></p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTkyMWNmODUzYWI3YjNhZTJlNWViOWE3MDA2OTExMGFfM0NqNG44YXVnVEp0dUhsRG5xVGpLTkZSZENJMjN4M2tfVG9rZW46R3BMd2JYRElXbzVOUVV4RUh4RGMxbTJHbklLXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p><strong>返回说明</strong></p><p>用户允许授权后，将会重定向到redirect_uri的网址上，并且带上 code 和state参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect_uri?code=CODE&amp;state=STATE</span><br></pre></td></tr></table></figure><p>若用户禁止授权，则不会发生重定向。</p><p>登录一号店网站应用 <a href="https://test.yhd.com/wechat/login.do">https://test.yhd.com/wechat/login.do</a> 打开后，一号店会生成 state 参数，跳转到 <a href="https://open.weixin.qq.com/connect/qrconnect?appid=wxbdc5610cc59c1631&amp;redirect_uri=https%3A%2F%2Fpassport.yhd.com%2Fwechat%2Fcallback.do&amp;response_type=code&amp;scope=snsapi_login&amp;state=3d6be0a4035d839573b04816624a415e#wechat_redirect">https://open.weixin.qq.com/connect/qrconnect?appid=wxbdc5610cc59c1631&amp;redirect_uri=https%3A%2F%2Fpassport.yhd.com%2Fwechat%2Fcallback.do&amp;response_type=code&amp;scope=snsapi_login&amp;state=3d6be0a4035d839573b04816624a415e#wechat_redirect</a> 微信用户使用微信扫描二维码并且确认登录后，PC端会跳转到 <a href="https://test.yhd.com/wechat/callback.do?code=CODE&amp;state=3d6be0a40sssssxxxxx6624a415e">https://test.yhd.com/wechat/callback.do?code=CODE&amp;state=3d6be0a40sssssxxxxx6624a415e</a> 为了满足网站更定制化的需求，我们还提供了第二种获取 code 的方式，支持网站将微信登录二维码内嵌到自己页面中，用户使用微信扫码授权后通过 JS 将code返回给网站。 JS微信登录主要用途：网站希望用户在网站内就能完成登录，无需跳转到微信域下登录后再返回，提升微信登录的流畅性与成功率。 网站内嵌二维码微信登录 JS 实现办法：</p><p>步骤1：在页面中先引入如下 JS 文件（支持https）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js</span><br></pre></td></tr></table></figure><p>步骤2：在需要使用微信登录的地方实例以下 JS 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = new WxLogin(&#123;</span><br><span class="line">self_redirect:true,</span><br><span class="line">id:&quot;login_container&quot;, </span><br><span class="line">appid: &quot;&quot;, </span><br><span class="line">scope: &quot;&quot;, </span><br><span class="line">redirect_uri: &quot;&quot;,</span><br><span class="line"> state: &quot;&quot;,</span><br><span class="line">style: &quot;&quot;,</span><br><span class="line">href: &quot;&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZmY2Y4ZGE2ZTQwY2E4ZDE3YmQxZjAxZjAyMjcyYTZfMVhiU3V1VkZ5cnlSMTUwV3hmQnRhOWkycnFWWkdZTDJfVG9rZW46UnVCZWJRM1BNb3RMRnB4bXl5MWNEZmExblVlXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY2NTlkNTRkOWY1MDdkYjkxMDVjYjQzNzlhYjY2OGFfT0NkNmJuMmZZNjRuQWpXV0RaZXVsY0JQaXlPd0YwaGdfVG9rZW46VjZ2NWJ2NTQ1b1pNcHJ4OWtaR2NrQmRnbnRkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><h3 id="4-1-3-通过-code-获取access-token"><a href="#4-1-3-通过-code-获取access-token" class="headerlink" title="4.1.3 通过 code 获取access_token"></a>4.1.3 <strong>通过 code 获取access_token</strong></h3><p>通过 code 获取access_token</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</span><br></pre></td></tr></table></figure><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzg4ZTUzOTRkNWJmMTFlZjNmMzQ5ZjU0ZmU1ZDRlNThfZ2U4VEhhOGczTjlyd0NkWmRHVHdJNURjaEpqR3ZRWm5fVG9rZW46SkhTMmJQeE11b1ByOGR4akRxN2NMZWpmbkFkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p><strong>返回说明</strong></p><p>正确的返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, </span><br><span class="line">&quot;expires_in&quot;:7200, </span><br><span class="line">&quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">&quot;openid&quot;:&quot;OPENID&quot;, </span><br><span class="line">&quot;scope&quot;:&quot;SCOPE&quot;,</span><br><span class="line">&quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>参数说明</strong></p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OTYxYzg2NzNlNzA0ZDMwMGUxNDlkZmUyY2JhMTkwNjZfMDlNdURtcjl3R1NONHdoNzNyY0tWdElvR0FyZXlvblRfVG9rZW46SUNoa2J2VlJib0FZaUZ4RUloT2NMWWNibnRoXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>错误返回样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;errcode&quot;:40029,&quot;errmsg&quot;:&quot;invalid code&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-4-通过access-token调用接口"><a href="#4-1-4-通过access-token调用接口" class="headerlink" title="4.1.4 通过access_token调用接口"></a>4.1.4 <strong>通过access_token调用接口</strong></h3><p>获取access_token后，进行接口调用，有以下前提：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">access_token有效且未超时；</span><br><span class="line">微信用户已授权给第三方应用帐号相应接口作用域（scope）。</span><br></pre></td></tr></table></figure><p>对于接口作用域（scope），能调用的接口有以下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NjRiNWE3ZTNmZGNmOTQ2YmQ0ZDhmZWYwZWY4YzZhNGRfRTJUUDNZTnd5eHlQTm9YMmJkWGMwSk5jc1ZlbEpnQ2dfVG9rZW46TWw0d2JSbmppb2ZaanB4VFlEOWNiY2hHblRiXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p> 其中snsapi_base属于基础接口，若应用已拥有其它 scope 权限，则默认拥有snsapi_base的权限。使用snsapi_base可以让移动端网页授权绕过跳转授权登录页请求用户授权的动作，直接跳转第三方网页带上授权临时票据（code），但会使得用户已授权作用域（scope）仅为snsapi_base，从而导致无法获取到需要用户授权才允许获得的数据和基础功能。 接口调用方法可查阅<a href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Authorized_Interface_Calling_UnionID.html">《微信授权关系接口调用指南》</a></p><p>获取用户信息接口文档：<a href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Authorized_Interface_Calling_UnionID.html">https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Authorized_Interface_Calling_UnionID.html</a></p><p>接口地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http请求方式: GET</span><br><span class="line">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID</span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFkYjhmNzRiMGE5OTkxZjcyMmY0ZjkyOTBlN2VlMmZfWFZQemNDRnZHREFKbWxGMkZrYTFOY3dJUzZUMkVZenVfVG9rZW46QTU4amI3ckJXbzFEN2t4Ynp2c2NPYVBGbkhjXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;openid&quot;</span>:<span class="string">&quot;OPENID&quot;</span>,</span><br><span class="line"><span class="string">&quot;nickname&quot;</span>:<span class="string">&quot;NICKNAME&quot;</span>,</span><br><span class="line"><span class="string">&quot;sex&quot;</span>:<span class="number">1</span>,</span><br><span class="line"><span class="string">&quot;province&quot;</span>:<span class="string">&quot;PROVINCE&quot;</span>,</span><br><span class="line"><span class="string">&quot;city&quot;</span>:<span class="string">&quot;CITY&quot;</span>,</span><br><span class="line"><span class="string">&quot;country&quot;</span>:<span class="string">&quot;COUNTRY&quot;</span>,</span><br><span class="line"><span class="string">&quot;headimgurl&quot;</span>: <span class="string">&quot;https://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;</span>,</span><br><span class="line"><span class="string">&quot;privilege&quot;</span>:[</span><br><span class="line"><span class="string">&quot;PRIVILEGE1&quot;</span>,</span><br><span class="line"><span class="string">&quot;PRIVILEGE2&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;unionid&quot;</span>: <span class="string">&quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">参数            说明</span><br><span class="line">openid        普通用户的标识，对当前开发者帐号唯一</span><br><span class="line">nickname        普通用户昵称</span><br><span class="line">sex            普通用户性别，1为男性，2为女性</span><br><span class="line">province        普通用户个人资料填写的省份</span><br><span class="line">city            普通用户个人资料填写的城市</span><br><span class="line">country        国家，如中国为CN</span><br><span class="line">headimgurl        用户头像，最后一个数值代表正方形头像大小（有0、46、64、96、132数值可选，0代表640*640正方形头像），用户没有头像时该项为空</span><br><span class="line">privilege        用户特权信息，json数组，如微信沃卡用户为（chinaunicom）</span><br><span class="line">unionid          用户统一标识。针对一个微信开放平台帐号下的应用，同一用户的 unionid 是唯一的。</span><br></pre></td></tr></table></figure><h2 id="4-2-准备开发环境"><a href="#4-2-准备开发环境" class="headerlink" title="4.2 准备开发环境"></a>4.2 准备开发环境</h2><h3 id="4-2-1-添加应用"><a href="#4-2-1-添加应用" class="headerlink" title="4.2.1 添加应用"></a>4.2.1 添加应用</h3><p>1、注册微信开放平台</p><p><a href="https://open.weixin.qq.com/">https://open.weixin.qq.com/</a></p><p>2、添加应用</p><p>进入网站应用，添加应用</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmM1ZDA1MTU2NmIxZWE0Nzc5NTRhMGQwNzQ2ODNiZWFfcks5R0hDRm5INFF4SHU0TmdWZGo1b1RMSm9RMHphOERfVG9rZW46WlpXY2IybXphb0dPTjR4OWhMdGNNaWUybkFiXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>3、添加应用需要指定一个外网域名作为微信回调域名</p><p>审核通过后，生成app密钥。</p><p>最终获取appID和AppSecret</p><h3 id="4-2-2-内网穿透"><a href="#4-2-2-内网穿透" class="headerlink" title="4.2.2 内网穿透"></a>4.2.2 内网穿透</h3><p>我们的开发环境在局域网，微信回调指向一个公网域名。</p><p>如何让微信回调请求至我们的开发计算机上呢？</p><p>可以使用内网穿透技术，什么是内网穿透？</p><p>内网穿透简单来说就是将内网外网通过隧道打通,让内网的数据让外网可以获取。比如常用的办公室软件等，一般在办公室或家里，通过拨号上网，这样办公软件只有在本地的局域网之内才能访问，那么问题来了，如果是手机上，或者公司外地的办公人员，如何访问到办公软件呢？这就需要内网穿透工具了。开启隧道之后，网穿透工具会分配一个专属域名/端口,办公软件就已经在公网上了,在外地的办公人员可以在任何地方愉快的访问办公软件了~~</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NWI0MjRmZjMwNjVhMDA1MDIwZWM0MWQ0MWQzNmJlODBfVHdrcWxLWlBTRktCZ2lyMW5hSEd6TXNIUlF0NThTWmdfVG9rZW46U3R6RGJUS3BRb3RuTVV4SkJQSWNXbzRKbkVmXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>1、在内网穿透服务器上开通隧道，配置外网域名，配置穿透内网的端口即本地电脑上的端口。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjdmZDk1ZGQyZWIzOWQ0MmNhYWRjNjBhZjY2MjYyNDRfc2Fmc1pLU2xMRHRQWDVjRUpWOWh0empVZEcyVVZPc2NfVG9rZW46SU5uRGJVRUo1b1lpSlJ4ekNHUGNtU2dzbmFoXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>这里我们配置认证服务端口，最终实现通过外网域名访问本地认证服务。</p><p>2、在本地电脑上安装内网穿透的工具，工具上配置内网穿透服务器隧道token。</p><p>市面上做内网穿透的商家很多，需要时可以查阅资料了解下。</p><h2 id="4-3-接入微信登录"><a href="#4-3-接入微信登录" class="headerlink" title="4.3 接入微信登录"></a>4.3 接入微信登录</h2><h3 id="4-3-1-接入分析"><a href="#4-3-1-接入分析" class="headerlink" title="4.3.1 接入分析"></a>4.3.1 接入分析</h3><p>根据OAuth2协议授权码流程，结合本项目自身特点，分析接入微信扫码登录的流程如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NmNhNDczMzA2NmM4MzJlMDVhZWE5ZmI5YzczNzIxZDBfNlZQRkNTRVpVb0hLaTJ0R2hyaXd6SXdiRmlQOVY5TVFfVG9rZW46SFV0TWJxbGZ4b2pXYU54VVNQdmNMTFlIbnFkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>本项目认证服务需要做哪些事？</p><p>1、需要定义接口接收微信下发的授权码。</p><p>2、收到授权码调用微信接口申请令牌。</p><p>3、申请到令牌调用微信获取用户信息</p><p>4、获取用户信息成功将其写入本项目用户中心数据库。</p><p>5、最后重定向到浏览器自动登录。</p><h3 id="4-3-2-定义接口"><a href="#4-3-2-定义接口" class="headerlink" title="4.3.2 定义接口"></a>4.3.2 定义接口</h3><p>参考接口规范中“请求获取授权码” 定义接收微信下发的授权码接口，</p><p>定义WxLoginController类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxLoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/wxLogin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">wxLogin</span><span class="params">(String code, String state)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;微信扫码回调,code:&#123;&#125;,state:&#123;&#125;&quot;</span>,code,state);</span><br><span class="line">        <span class="comment">//请求微信申请令牌，拿到令牌查询用户信息，将用户信息写入本项目数据库</span></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUser</span>();</span><br><span class="line">        <span class="comment">//暂时硬编写，目的是调试环境</span></span><br><span class="line">        xcUser.setUsername(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(xcUser==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:http://www.51xuecheng.cn/error.html&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> xcUser.getUsername();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:http://www.51xuecheng.cn/sign.html?username=&quot;</span>+username+<span class="string">&quot;&amp;authType=wx&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义微信认证的service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.ucenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 微信扫码认证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/29 12:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;wx_authservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//账号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authParamsDto.getUsername();</span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, username));</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;账号不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">XcUserExt</span> <span class="variable">xcUserExt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUserExt</span>();</span><br><span class="line">        BeanUtils.copyProperties(user,xcUserExt);</span><br><span class="line">        <span class="keyword">return</span> xcUserExt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-接口环境测试"><a href="#4-3-3-接口环境测试" class="headerlink" title="4.3.3 接口环境测试"></a>4.3.3 接口环境测试</h3><p>接口定义好下边进行测试下，主要目的是测试接口调度的环境。</p><p>1、启动内网穿透工具</p><p>2、在/wxLogin接口中打断点</p><p>3、打开前端微信扫码页面</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBlOTRjNzk3MzI3N2M4MDI4MTc1MTRiZjMxZWYwZDJfYm9aRXpNQWdrbUd5N3g2MEMwWHZtWW9kQWFsVDNhOUhfVG9rZW46UGhNNmI0VGpSb3dpeWN4QTJZM2NlSUdJbmVmXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>点击微信图标打开二维码</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQzODM1YTViZGY5MmZlMWU0ZGI0NzE0NmIzNDY2OGFfanFvanpQQzdWR0xFbHhjY044MDZWMmRSZHNvaUJkbVZfVG9rZW46VndVeGI5MzVrb21yM2d4NEIzUWN0ZXZRblZmXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>用户扫码，确认授权</p><p>此时正常进入 /wxLogin  方法，最后跳转到<a href="http://www.51xuecheng.cn/sign.html?username=t1&amp;authType=wx。">http://www.51xuecheng.cn/sign.html?username=t1&amp;authType=wx。</a></p><h3 id="4-3-4-接入微信认证"><a href="#4-3-4-接入微信认证" class="headerlink" title="4.3.4 接入微信认证"></a>4.3.4 接入微信认证</h3><p>接下来请求微信申请令牌。</p><p>1、使用restTemplate请求微信，配置RestTemplate bean</p><p>在启动类配置restTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>(<span class="keyword">new</span> <span class="title class_">OkHttp3ClientHttpRequestFactory</span>());</span><br><span class="line">    <span class="keyword">return</span>  restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、定义与微信认证的service接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 微信认证接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/21 22:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WxAuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> XcUser <span class="title function_">wxAuth</span><span class="params">(String code)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、下边在controller中调用wxAuth接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxLoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WxAuthService wxAuthService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/wxLogin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">wxLogin</span><span class="params">(String code, String state)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;微信扫码回调,code:&#123;&#125;,state:&#123;&#125;&quot;</span>,code,state);</span><br><span class="line">        <span class="comment">//请求微信申请令牌，拿到令牌查询用户信息，将用户信息写入本项目数据库</span></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> wxAuthService.wxAuth(code);</span><br><span class="line">        <span class="keyword">if</span>(xcUser==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:http://www.51xuecheng.cn/error.html&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> xcUser.getUsername();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:http://www.51xuecheng.cn/sign.html?username=&quot;</span>+username+<span class="string">&quot;&amp;authType=wx&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、在WxAuthService 的wxAuth方法中实现申请令牌、查询用户信息等内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;wx_authservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span>, WxAuthService &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">XcUserMapper xcUserMapper;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;weixin.appid&#125;&quot;)</span></span><br><span class="line">String appid;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;weixin.secret&#125;&quot;)</span></span><br><span class="line">String secret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> XcUser <span class="title function_">wxAuth</span><span class="params">(String code)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到code调用微信接口申请access_token</span></span><br><span class="line">    Map&lt;String, String&gt; access_token_map = getAccess_token(code);</span><br><span class="line">    <span class="keyword">if</span>(access_token_map==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(access_token_map);</span><br><span class="line">    <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">access_token</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">    <span class="comment">//拿access_token查询用户信息</span></span><br><span class="line">    Map&lt;String, String&gt; userinfo = getUserinfo(access_token, openid);</span><br><span class="line">    <span class="keyword">if</span>(userinfo==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加用户到数据库</span></span><br><span class="line">    <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> xcUser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 申请访问令牌,响应示例</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment"> &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span></span><br><span class="line"><span class="comment"> &quot;expires_in&quot;:7200,</span></span><br><span class="line"><span class="comment"> &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span></span><br><span class="line"><span class="comment"> &quot;openid&quot;:&quot;OPENID&quot;,</span></span><br><span class="line"><span class="comment"> &quot;scope&quot;:&quot;SCOPE&quot;,</span></span><br><span class="line"><span class="comment"> &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">getAccess_token</span><span class="params">(String code)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">wxUrl_template</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&amp;secret=%s&amp;code=%s&amp;grant_type=authorization_code&quot;</span>;</span><br><span class="line">    <span class="comment">//请求微信地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">wxUrl</span> <span class="operator">=</span> String.format(wxUrl_template, appid, secret, code);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;调用微信接口申请access_token, url:&#123;&#125;&quot;</span>, wxUrl);</span><br><span class="line"></span><br><span class="line">    ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(wxUrl, HttpMethod.POST, <span class="literal">null</span>, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> exchange.getBody();</span><br><span class="line">    log.info(<span class="string">&quot;调用微信接口申请access_token: 返回值:&#123;&#125;&quot;</span>, result);</span><br><span class="line">    Map&lt;String,String&gt; resultMap = JSON.parseObject(result, Map.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**获取用户信息，示例如下：</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment"> &quot;openid&quot;:&quot;OPENID&quot;,</span></span><br><span class="line"><span class="comment"> &quot;nickname&quot;:&quot;NICKNAME&quot;,</span></span><br><span class="line"><span class="comment"> &quot;sex&quot;:1,</span></span><br><span class="line"><span class="comment"> &quot;province&quot;:&quot;PROVINCE&quot;,</span></span><br><span class="line"><span class="comment"> &quot;city&quot;:&quot;CITY&quot;,</span></span><br><span class="line"><span class="comment"> &quot;country&quot;:&quot;COUNTRY&quot;,</span></span><br><span class="line"><span class="comment"> &quot;headimgurl&quot;: &quot;https://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,</span></span><br><span class="line"><span class="comment"> &quot;privilege&quot;:[</span></span><br><span class="line"><span class="comment"> &quot;PRIVILEGE1&quot;,</span></span><br><span class="line"><span class="comment"> &quot;PRIVILEGE2&quot;</span></span><br><span class="line"><span class="comment"> ],</span></span><br><span class="line"><span class="comment"> &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">getUserinfo</span><span class="params">(String access_token,String openid)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">wxUrl_template</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/sns/userinfo?access_token=%s&amp;openid=%s&quot;</span>;</span><br><span class="line">    <span class="comment">//请求微信地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">wxUrl</span> <span class="operator">=</span> String.format(wxUrl_template, access_token,openid);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;调用微信接口申请access_token, url:&#123;&#125;&quot;</span>, wxUrl);</span><br><span class="line"></span><br><span class="line">    ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(wxUrl, HttpMethod.POST, <span class="literal">null</span>, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止乱码进行转码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span>     <span class="title class_">String</span>(exchange.getBody().getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);</span><br><span class="line">    log.info(<span class="string">&quot;调用微信接口申请access_token: 返回值:&#123;&#125;&quot;</span>, result);</span><br><span class="line">    Map&lt;String,String&gt; resultMap = JSON.parseObject(result, Map.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>测试获取用户信息</p><p>1、在获取用户信息处打断点</p><p>2、进入<a href="http://www.51xuecheng.cn/wxsign.html">http://www.51xuecheng.cn/wxsign.html</a></p><p>3、手机扫码授权</p><h3 id="4-3-5-保存用户信息"><a href="#4-3-5-保存用户信息" class="headerlink" title="4.3.5 保存用户信息"></a>4.3.5 保存用户信息</h3><p>向数据库保存用户信息，如果用户不存在将其保存在数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">XcUserRoleMapper xcUserRoleMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> XcUser <span class="title function_">addWxUser</span><span class="params">(Map userInfo_map)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">unionid</span> <span class="operator">=</span> userInfo_map.get(<span class="string">&quot;unionid&quot;</span>).toString();</span><br><span class="line">    <span class="comment">//根据unionid查询数据库</span></span><br><span class="line">    <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getWxUnionid, unionid));</span><br><span class="line">    <span class="keyword">if</span>(xcUser!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> xcUser;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    xcUser = <span class="keyword">new</span> <span class="title class_">XcUser</span>();</span><br><span class="line">    xcUser.setId(userId);</span><br><span class="line">    xcUser.setWxUnionid(unionid);</span><br><span class="line">    <span class="comment">//记录从微信得到的昵称</span></span><br><span class="line">    xcUser.setNickname(userInfo_map.get(<span class="string">&quot;nickname&quot;</span>).toString());</span><br><span class="line">    xcUser.setUserpic(userInfo_map.get(<span class="string">&quot;headimgurl&quot;</span>).toString());</span><br><span class="line">    xcUser.setName(userInfo_map.get(<span class="string">&quot;nickname&quot;</span>).toString());</span><br><span class="line">    xcUser.setUsername(unionid);</span><br><span class="line">    xcUser.setPassword(unionid);</span><br><span class="line">    xcUser.setUtype(<span class="string">&quot;101001&quot;</span>);<span class="comment">//学生类型</span></span><br><span class="line">    xcUser.setStatus(<span class="string">&quot;1&quot;</span>);<span class="comment">//用户状态</span></span><br><span class="line">    xcUser.setCreateTime(LocalDateTime.now());</span><br><span class="line">    xcUserMapper.insert(xcUser);</span><br><span class="line">    <span class="type">XcUserRole</span> <span class="variable">xcUserRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUserRole</span>();</span><br><span class="line">    xcUserRole.setId(UUID.randomUUID().toString());</span><br><span class="line">    xcUserRole.setUserId(userId);</span><br><span class="line">    xcUserRole.setRoleId(<span class="string">&quot;17&quot;</span>);<span class="comment">//学生角色</span></span><br><span class="line">    xcUserRoleMapper.insert(xcUserRole);</span><br><span class="line">    <span class="keyword">return</span> xcUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用保存用户信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">WxAuthServiceImpl currentProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> XcUser <span class="title function_">wxAuth</span><span class="params">(String code)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到code调用微信接口申请access_token</span></span><br><span class="line">    Map&lt;String, String&gt; access_token_map = getAccess_token(code);</span><br><span class="line">    <span class="keyword">if</span>(access_token_map==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(access_token_map);</span><br><span class="line">    <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">access_token</span> <span class="operator">=</span> access_token_map.get(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">    <span class="comment">//拿access_token查询用户信息</span></span><br><span class="line">    Map&lt;String, String&gt; userinfo = getUserinfo(access_token, openid);</span><br><span class="line">    <span class="keyword">if</span>(userinfo==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将用户信息保存到数据库</span></span><br><span class="line">    <span class="type">XcUser</span> <span class="variable">xcUser</span> <span class="operator">=</span> currentProxy.addWxUser(userinfo);</span><br><span class="line">    <span class="keyword">return</span> xcUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试保存用户信息</p><p>1、在保存用户信息处打断点</p><p>2、进入<a href="http://www.51xuecheng.cn/wxsign.html">http://www.51xuecheng.cn/wxsign.html</a></p><p>3、手机扫码授权</p><p>4、自动跳转到登录页面，提交认证成功。</p><h1 id="5-用户授权"><a href="#5-用户授权" class="headerlink" title="5 用户授权"></a>5 用户授权</h1><h2 id="5-1-RBAC"><a href="#5-1-RBAC" class="headerlink" title="5.1 RBAC"></a>5.1 RBAC</h2><p>如何实现授权？业界通常基于RBAC实现授权。</p><p>RBAC分为两种方式：</p><p>基于角色的访问控制（Role-Based Access Control）</p><p>基于资源的访问控制（Resource-Based Access Control）</p><p>角色的访问控制（Role-Based Access Control）是按角色进行授权，比如：主体的角色为总经理可以查询企业运营报表，查询员工工资信息等，访问控制流程如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWZmODJhMTllZDQxMDU1ZWNiYTg2ZTBhZDVlM2FkNDRfZTVWdUV5S0JHeFYxZWt6dUlxUkFYMGh6WWpCZVZpak9fVG9rZW46QWRNaGJWTjR4b3cxdlZ4RXlKTWNtdW9lbkdlXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>根据上图中的判断逻辑，授权代码可表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(主体.hasRole(<span class="string">&quot;总经理角色id&quot;</span>))&#123;</span><br><span class="line">查询工资</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上图中查询工资所需要的角色变化为总经理和部门经理，此时就需要修改判断逻辑为“判断用户的角色是否是总经理或部门经理”，修改代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(主体.hasRole(<span class="string">&quot;总经理角色id&quot;</span>) ||  主体.hasRole(<span class="string">&quot;部门经理角色id&quot;</span>))&#123;</span><br><span class="line">    查询工资</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上边的例子发现，当需要修改角色的权限时就需要修改授权的相关代码，系统可扩展性差。</p><p>基于资源的访问控制（Resource-Based Access</p><p>Control）是按资源（或权限）进行授权，比如：用户必须具有查询工资权限才可以查询员工工资信息等，访问控制流程如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=OTQ3ODQxYjUzZDY2OGIxMzUxNmY3Zjg0MTFiYjdiOGJfZjUzQkRONUpDamhzc2s4S3h5Z1RzU1FwZGFxN1lYOVRfVG9rZW46UkZzNGJVMnZEbzBIbkp4bzQ1Z2NIY1owbktiXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>根据上图中的判断，授权代码可以表示为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(主体.hasPermission(<span class="string">&quot;查询工资权限标识&quot;</span>))&#123;</span><br><span class="line">    查询工资</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：系统设计时定义好查询工资的权限标识，即使查询工资所需要的角色变化为总经理和部门经理也不需要修改授权代码，系统可扩展性强。</p><h2 id="5-2-资源服务授权流程"><a href="#5-2-资源服务授权流程" class="headerlink" title="5.2 资源服务授权流程"></a>5.2 资源服务授权流程</h2><p>本项目在资源服务内部进行授权，基于资源的授权模式，因为接口在资源服务，通过在接口处添加授权注解实现授权。</p><p>1、首先配置nginx代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> http &#123;</span><br><span class="line">  server_names_hash_bucket_size <span class="number">64</span>;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line"> #前端开发服务</span><br><span class="line">upstream uidevserver&#123;</span><br><span class="line">  server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8601</span> weight=<span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line"> server &#123;</span><br><span class="line">      listen       <span class="number">80</span>;</span><br><span class="line">      server_name  teacher.51xuecheng.cn;</span><br><span class="line">      #charset koi8-r;</span><br><span class="line">      ssi on;</span><br><span class="line">      ssi_silent_errors on;</span><br><span class="line">      #access_log  logs/host.access.log  main;</span><br><span class="line">      #location / &#123;</span><br><span class="line">       #   alias   D:/itcast2022/xc_edu3<span class="number">.0</span>/code_1/dist/;</span><br><span class="line">       #   index  index.html index.htm;</span><br><span class="line">      #&#125;</span><br><span class="line">      location / &#123;</span><br><span class="line">          proxy_pass   http:<span class="comment">//uidevserver;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      location /api/ &#123;</span><br><span class="line">              proxy_pass http:<span class="comment">//gatewayserver/;</span></span><br><span class="line">      &#125; </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>加载nginx 配置。</p><p>2、在资源服务集成Spring Security</p><p>在需要授权的接口处使用@PreAuthorize(“hasAuthority(‘权限标识符’)”)进行控制</p><p>下边代码指定/course/list接口需要拥有xc_teachmanager_course_list 权限。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MDM1OTA1Y2EzNzZjYjIyNjg0ZTA4ZTNjNTllMGQzOGVfeE13azVlQ004dlBLWlVQM091b2hVaFJkbmdQZ1FGc1lfVG9rZW46RHMyQWJ2bGh0b3o2MnZ4SDh4TGNHYlVwbmJnXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>设置了@PreAuthorize表示执行此方法需要授权，如果当前用户请求接口没有权限则抛出异常</p><p>org.springframework.security.access.AccessDeniedException: 不允许访问</p><p>3、在统一异常处理处解析此异常信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line"><span class="keyword">public</span> RestErrorResponse <span class="title function_">exception</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line"></span><br><span class="line">   log.error(<span class="string">&quot;【系统异常】&#123;&#125;&quot;</span>,e.getMessage(),e);</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   <span class="keyword">if</span>(e.getMessage().equals(<span class="string">&quot;不允许访问&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(<span class="string">&quot;没有操作此功能的权限&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(CommonError.UNKOWN_ERROR.getErrMessage());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、重启资源服务进行测试</p><p>使用教学机构用户登录系统</p><p>这里使用t1用户登录，账号:t1、密码：111111</p><p>登录成功，点击“教学机构”</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=M2IyZjAwMWI2NjM2ZDg1YTY5MzI1YjdiMjQ4ZTRkODFfcTF6eWNpbmpKRkE4VjBYM0ZBU0dHRkxrb1ZqekJNOU1fVG9rZW46U09rUmJvbDNFbzlnQ3F4Zjd1NWNyMHpEbjAwXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>当用户没有权限时页面提示：没有操作此功能的权限。</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTcxNGRhY2QwZDY3NzI3NmJkMGM3NzhjOGNmYjBlM2NfbUYxRlJDOG5mNWdQQ0tZUzJWVmpVQ2NxdDF4dlJweFpfVG9rZW46V04yTmJIbDB1bzJZNGF4SjNLd2MyVjdJblBkXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><h2 id="5-3-授权相关的数据模型"><a href="#5-3-授权相关的数据模型" class="headerlink" title="5.3 授权相关的数据模型"></a>5.3 授权相关的数据模型</h2><p>如何给用户分配权限呢？</p><p>首先要学习数据模型，本项目授权相关的数据表如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MWE5ZjcwNjYyYzY3YzliZjkwZTRjM2JkOWEyYjVmNTFfbFRlcWlPMldIaU96aWw2eGFUZE9hRXI2ckVkZzY0UDhfVG9rZW46UWxNNGJqMlRib0txOGt4Zm95V2NpUEk4bnNmXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>说明如下：</p><p>xc_user：用户表，存储了系统用户信息，用户类型包括：学生、老师、管理员等</p><p>xc_role：角色表，存储了系统的角色信息，学生、老师、教学管理员、系统管理员等。</p><p>xc_user_role：用户角色表，一个用户可拥有多个角色，一个角色可被多个用户所拥有</p><p>xc_menu:模块表，记录了菜单及菜单下的权限</p><p>xc_permission:角色权限表，一个角色可拥有多个权限，一个权限可被多个角色所拥有</p><p>本项目教学阶段不再实现权限定义及用户权限分配的功能，权限分配的界面原型如下图所示：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=NDE4ZDA5ZThlZThlNzI5NWVmZjZmYTM4YWRhMGVjZTVfRjFRS0pSVEJZa1U3YTY4TFdiRVdidXdkZll4bm03aGhfVG9rZW46WWpSVWJLb09BbzNRbkp4cWxRTGNXSmNVbklXXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>本项目要求掌握基于权限数据模型（5张数据表），要求在数据库中操作完成给用户分配权限、查询用户权限等需求。</p><p>1、查询用户所拥有的权限</p><p>步骤：</p><p>查询用户的id</p><p>查询用户所拥有的角色</p><p>查询用户所拥有的权限</p><p>例子：</p><p>SELECT * FROM xc_menu WHERE id IN(    SELECT menu_id FROM xc_permission WHERE role_id IN(        SELECT role_id FROM xc_user_role WHERE user_id = ‘49’    ) )</p><p>2、给用户分配权限</p><p>1）添加权限</p><p>查询用户的id</p><p>查询权限的id</p><p>查询用户的角色，如果没有角色需要先给用户指定角色</p><p>向角色权限表添加记录</p><p>2）删除用户权限</p><p>本项目是基于角色分配权限，如果要删除用户的权限可以给用户换角色，那么新角色下的权限就是用户的权限；如果不换用户的角色可以删除角色下的权限即删除角色权限关系表相应记录，这样操作是将角色下的权限删除，属于该角色的用户都将删除此权限。</p><h2 id="5-4-查询用户权限"><a href="#5-4-查询用户权限" class="headerlink" title="5.4 查询用户权限"></a><strong>5.4 查询用户权限</strong></h2><p>使用Spring Security进行授权，首先在生成jwt前会查询用户的权限，如下图：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MTA3MmQ0NmE4OGU0MGJlMWI1MmE5NzYwN2JmMzhjM2ZfazFDVmt4TGg5blZOVU9ZaDhkcnZsdm5VRnQ2NGc3VjJfVG9rZW46UFdqYWJiVHVyb1N6WTV4a0c2ZGNucHczbkpjXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>接下来需要修改UserServiceImpl和PasswordAuthServiceImpl从数据库查询用户的权限。</p><p>1、定义mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">XcMenuMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;XcMenu&gt; &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT    * FROM xc_menu WHERE id IN (SELECT menu_id FROM xc_permission WHERE role_id IN ( SELECT role_id FROM xc_user_role WHERE user_id = #&#123;userId&#125; ))&quot;)</span></span><br><span class="line">    List&lt;XcMenu&gt; <span class="title function_">selectPermissionByUserId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> String userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、修改PasswordAuthServiceImpl</p><p>修改UserServiceImpl类的getUserPrincipal方法，查询权限信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询用户身份</span></span><br><span class="line"><span class="keyword">public</span> UserDetails <span class="title function_">getUserPrincipal</span><span class="params">(XcUserExt user)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">    <span class="comment">//查询用户权限</span></span><br><span class="line">    List&lt;XcMenu&gt; xcMenus = menuMapper.selectPermissionByUserId(user.getId());</span><br><span class="line">    List&lt;String&gt; permissions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(xcMenus.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//用户权限,如果不加则报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">        permissions.add(<span class="string">&quot;p1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        xcMenus.forEach(menu-&gt;&#123;</span><br><span class="line">            permissions.add(menu.getCode());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将用户权限放在XcUserExt中</span></span><br><span class="line">    user.setPermissions(permissions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了安全在令牌中不放密码</span></span><br><span class="line">    user.setPassword(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//将user对象转json</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">    String[] authorities = permissions.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(userString).password(password).authorities(authorities).build();</span><br><span class="line">    <span class="keyword">return</span> userDetails;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-授权测试"><a href="#5-5-授权测试" class="headerlink" title="5.5 授权测试"></a>5.5 授权测试</h2><p>以上实现了认证时从数据库查询用户的权限，下边进行用户授权测试。</p><p>重启认证服务，使用内容管理课程列表查询为例，代码如下：</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmVlOTU4ODI1OWVjZTg4YTUyYTA1YjdiOGM4ZjNlMDJfTmxKVGtBQXRxVWhiUXAyejlRbTY2bU9OWW5Jd0ZBTFpfVG9rZW46SThjV2JmR3dzb2F5S0d4ZUVVM2NDeE9kbkdoXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>用户拥有xc_teachmanager_course_list权限方可访问课程查询接口。</p><p>以用户stu1为例，当它没有此权限时页面报“没有此操作的权限”错误</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YTcwNWJlMTA1ZmYxMDFkZWVjMGZkMjNiYjliYjFiOWVfTE8wdDI3bDNMNHNzVzNuUWdrSkpKRVdpWlhvNWxDZFpfVG9rZW46S25HT2JwTmwxb0FHTWx4eEhEOGNnNE44bnViXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>将xc_teachmanager_course_list权限分配给用户。</p><p>1）首先找到当前用户的角色</p><p>2）找到xc_teachmanager_course_list权限的主键</p><p>3）在角色权限关系表中添加记录</p><p>分配完权限需要重新登录</p><p>由于用户分配了xc_teachmanager_course_list权限，用户具有访问课程查询接口的权限。</p><h2 id="5-6-细粒度授权"><a href="#5-6-细粒度授权" class="headerlink" title="5.6 细粒度授权"></a>5.6 细粒度授权</h2><h3 id="5-6-1-什么是细粒度授权"><a href="#5-6-1-什么是细粒度授权" class="headerlink" title="5.6.1 什么是细粒度授权"></a>5.6.1 什么是细粒度授权</h3><p>什么是细粒度授权？</p><p>细粒度授权也叫数据范围授权，即不同的用户所拥有的操作权限相同，但是能够操作的数据范围是不一样的。一个例子：用户A和用户B都是教学机构，他们都拥有“我的课程”权限，但是两个用户所查询到的数据是不一样的。</p><p>本项目有哪些细粒度授权？</p><p>比如：</p><p>我的课程，教学机构只允许查询本教学机构下的课程信息。</p><p>我的选课，学生只允许查询自己所选课。</p><p>如何实现细粒度授权？</p><p>细粒度授权涉及到不同的业务逻辑，通常在service层实现，根据不同的用户进行校验，根据不同的参数查询不同的数据或操作不同的数据。</p><h3 id="5-6-2-教学机构细粒度授权"><a href="#5-6-2-教学机构细粒度授权" class="headerlink" title="5.6.2 教学机构细粒度授权"></a>5.6.2 教学机构细粒度授权</h3><p>教学机构在维护课程时只允许维护本机构的课程，教学机构细粒度授权过程如下：</p><p>1）获取当前登录的用户身份</p><p>2）得到用户所属教育机构的Id</p><p>3）查询该教学机构下的课程信息</p><p>最终实现了用户只允许查询自己机构的课程信息。</p><p>根据公司Id查询课程，流程如下：</p><p>1）教学机构用户登录系统，从用户身份中取出所属机构的id</p><p>在用户表中设计了company_id字段存储该用户所属的机构id.</p><p>2）接口层取出当前登录用户的身份，取出机构id</p><p>\3) 将机构id传入service方法。</p><p>\4) service方法将机构id传入Dao方法，最终查询出本机构的课程信息。</p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程查询接口&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;xc_teachmanager_course_list&#x27;)&quot;)</span><span class="comment">//拥有课程列表查询的权限方可访问</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/course/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PageResult&lt;CourseBase&gt; <span class="title function_">list</span><span class="params">(PageParams pageParams, <span class="meta">@RequestBody</span> QueryCourseParamsDto queryCourseParams)</span>&#123;</span><br><span class="line">    <span class="comment">//取出用户身份</span></span><br><span class="line">    <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> SecurityUtil.getUser();</span><br><span class="line">    <span class="comment">//机构id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">companyId</span> <span class="operator">=</span> user.getCompanyId();</span><br><span class="line">    <span class="keyword">return</span> courseBaseInfoService.queryCourseBaseList(Long.parseLong(companyId),pageParams,queryCourseParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult&lt;CourseBase&gt; <span class="title function_">queryCourseBaseList</span><span class="params">(Long companyId,PageParams pageParams, QueryCourseParamsDto queryCourseParamsDto)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//构建查询条件对象</span></span><br><span class="line"> LambdaQueryWrapper&lt;CourseBase&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">//机构id</span></span><br><span class="line"> queryWrapper.eq(CourseBase::getCompanyId,companyId);</span><br><span class="line"> ....</span><br></pre></td></tr></table></figure><h3 id="5-6-3-教学机构细粒度授权测试"><a href="#5-6-3-教学机构细粒度授权测试" class="headerlink" title="5.6.3 教学机构细粒度授权测试"></a>5.6.3 教学机构细粒度授权测试</h3><p>使用一个教学机构的用户登录项目，并且此用户具有查询课程的权限。</p><p>手机修改数据库指定用户归属到一个机构中，涉及以下数据表：</p><p>xc_company为机构表</p><p>xc_company_user为机构用户关系表</p><p>xc_user表中有company_id字段。</p><p>我们准备了t1 用户作为此次测试的用户，使用此用户登录系统：</p><p>提前在查询课程列表接口处打上断点。</p><p>经过测试可以正常取出用户所属的机构id</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=YjhhMTVhYzM1MDYwYmVhMmMyYWJhNGFhZDkwODY3OWZfaDEyTUF5WnVoc01ha1k5OGt2d0xhdmZRenMyRDg3QVhfVG9rZW46TjJDTGJKUTNZb2VCZFF4QklENWN5eFBEbm5mXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>跟踪持久层日志发现已将机构id传入dao方法，拼装sql语句，查询本机构的课程信息</p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJkYjNjYTUwOTA3NzAyNjdlYzVhZWMzMTJiZmQwN2JfYjlZMURiQlpHU05DV2dzYkVPTjZHZWt1cVRxVTNCOWhfVG9rZW46WEIwbmJWT1lab0g0Q3V4QjhmaWNnYXBTbklmXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><h1 id="6-实战"><a href="#6-实战" class="headerlink" title="6 实战"></a>6 实战</h1><h2 id="6-1-找回密码-实战"><a href="#6-1-找回密码-实战" class="headerlink" title="6.1 找回密码(实战)"></a>6.1 找回密码(实战)</h2><p>需求：忘记密码需要找回，可以通过手机号找回密码，通过邮箱找回密码以及人工通道。</p><p>界面访问地址：<a href="http://www.51xuecheng.cn/findpassword.html">http://www.51xuecheng.cn/findpassword.html</a></p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MDE5YWVjMDBhYjc4MDBlYmZmOWRhMWU1N2JiNzAyODBfakV2ZWROZ0JwQlVUazNpVzZvWENSYUtrUVZ2SG1LdGNfVG9rZW46T1lEcmJQT1Zyb0xOZkt4N0xndGNUVng4bjhnXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>接口：</p><p>手机验证码：/api/checkcode/phone?param1=手机号</p><p>邮箱验证码：/api/checkcode/phone?param1=电子邮箱地址</p><p>找回密码：/api/auth/findpassword</p><p>请求：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">     cellphone<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">     email<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">     checkcodekey<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">     checkcode<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">     confirmpwd<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">     password<span class="punctuation">:</span>&#x27;&#x27;</span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>响应：</p><p>200: 找回成功</p><p>其它：找回失败，失败原因使用统一异常处理返回的信息格式</p><p>执行流程 1、校验验证码，不一致则抛出异常</p><p>2、判断两次密码是否一致，不一致则抛出异常</p><p>3、根据手机号和邮箱查询用户</p><p>4、如果找到用户更新为新密码</p><h2 id="6-2-注册-实战"><a href="#6-2-注册-实战" class="headerlink" title="6.2 注册(实战)"></a>6.2 注册(实战)</h2><p>需求：为学生提供注册入口，通过此入口注册的用户为学生用户。</p><p>界面访问地址：<a href="http://www.51xuecheng.cn/register.html">http://www.51xuecheng.cn/register.html</a></p><p><img src="https://mx67xggunk5.feishu.cn/space/api/box/stream/download/asynccode/?code=MjkyMjYzMTZkODBkOWViNmRhOGFjN2ZmNTc5ZWE1YWJfT00zNFhRWGVwb1F0THgxMGl4RTkwVVBtR3RuTVVxTHVfVG9rZW46Vm5URGJtVG11b2RrSXF4UUJBMWNPdHd1bkxlXzE3NDE4NjgwMDE6MTc0MTg3MTYwMV9WNA" alt="img"></p><p>接口：</p><p>手机验证码：/api/checkcode/phone?param1=手机号</p><p>注册：/api/auth/register</p><p>请求：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   cellphone<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">   username<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">   email<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">   nickname<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">   password<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">   confirmpwd<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">   checkcodekey<span class="punctuation">:</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">   checkcode<span class="punctuation">:</span>&#x27;&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>响应：</p><p>200: 注册成功</p><p>其它：注册失败，失败原因使用统一异常处理返回的信息格式</p><p>执行流程：</p><p>1、校验验证码，如果不一致则抛出异常</p><p>2、校验两次密码是否一致，如果不一致则抛出异常</p><p>3、校验用户是否存在，如果存在则抛出异常</p><p>4、向用户表、用户角色关系表添加数据。角色为学生角色。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-模块需求分析&quot;&gt;&lt;a href=&quot;#1-模块需求分析&quot; class=&quot;headerlink&quot; title=&quot;1 模块需求分析&quot;&gt;&lt;/a&gt;1 模块需求分析&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是认证授权&quot;&gt;&lt;a href=&quot;#1-1-什么是认证授权&quot; class</summary>
      
    
    
    
    <category term="八股" scheme="https://amirokd.dpdns.org/categories/%E5%85%AB%E8%82%A1/"/>
    
    
    <category term="Spring Security" scheme="https://amirokd.dpdns.org/tags/Spring-Security/"/>
    
    <category term="认证授权" scheme="https://amirokd.dpdns.org/tags/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/"/>
    
    <category term="token" scheme="https://amirokd.dpdns.org/tags/token/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础篇</title>
    <link href="https://amirokd.dpdns.org/posts/4604f75b.html"/>
    <id>https://amirokd.dpdns.org/posts/4604f75b.html</id>
    <published>2025-03-03T11:30:58.000Z</published>
    <updated>2025-05-07T14:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础篇Redis"><a href="#基础篇Redis" class="headerlink" title="基础篇Redis"></a>基础篇Redis</h1><h2 id="开篇导读"><a href="#开篇导读" class="headerlink" title="开篇导读"></a>开篇导读</h2><p><strong>理想课程</strong></p><h2 id="1-Redis简单介绍"><a href="#1-Redis简单介绍" class="headerlink" title="1.Redis简单介绍"></a>1.Redis简单介绍</h2><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li>键值型</li><li>NoSql</li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key.value对的形式存储，而value的形式多种多样，可以是字符串.数值.甚至json：</p><p><img src="https://zhangweiluo.dpdns.org/img/1652882668159.png" alt="1652882668159"></p><p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p><p>对于存储的数据，没有类似Mysql那么严格的约束，比如唯一性，是否可以为null等等，所以我们把这种松散结构的数据库，称之为NoSQL数据库。</p><h2 id="2-课程目录"><a href="#2-课程目录" class="headerlink" title="2.课程目录"></a>2.课程目录</h2><blockquote><ul><li>初始Redis<ul><li>认识NoSQL</li><li>认识Redis</li><li>安装Redis</li></ul></li><li>Redis常见命令<ul><li>5种常见数据结构</li><li>通用命令</li><li>不同数据结构的操作命令</li></ul></li><li>Redis的Java客户端<ul><li>Jedis客户端</li><li>SpringDataRedis客户端</li></ul></li></ul></blockquote><h2 id="3-初始Redis"><a href="#3-初始Redis" class="headerlink" title="3.初始Redis"></a>3.初始Redis</h2><h3 id="3-1-认识NoSQL"><a href="#3-1-认识NoSQL" class="headerlink" title="3.1.认识NoSQL"></a>3.1.认识NoSQL</h3><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p><h4 id="3-1-1-结构化与非结构化"><a href="#3-1-1-结构化与非结构化" class="headerlink" title="3.1.1.结构化与非结构化"></a>3.1.1.结构化与非结构化</h4><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束：</p><p><img src="https://i.imgur.com/4tUgFo6.png" alt=""></p><p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p><p>可以是键值型：</p><p><img src="https://i.imgur.com/GdqOSsj.png" alt=""></p><p>也可以是文档型：</p><p><img src="https://i.imgur.com/zBBQfcc.png" alt=""></p><p>甚至可以是图格式：</p><p><img src="https://i.imgur.com/zBnKxWf.png" alt=""></p><h4 id="3-1-2-关联和非关联"><a href="#3-1-2-关联和非关联" class="headerlink" title="3.1.2.关联和非关联"></a>3.1.2.关联和非关联</h4><p>传统数据库的表与表之间往往存在关联，例如外键：</p><p><img src="https://i.imgur.com/tXYSl5x.png" alt=""></p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p><h4 id="3-1-3-查询方式"><a href="#3-1-3-查询方式" class="headerlink" title="3.1.3.查询方式"></a>3.1.3.查询方式</h4><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><p><img src="https://i.imgur.com/AzaHOTF.png" alt=""></p><h4 id="3-1-4-事务"><a href="#3-1-4-事务" class="headerlink" title="3.1.4.事务"></a>3.1.4.事务</h4><p>传统关系型数据库能满足事务ACID的原则。</p><p><img src="https://i.imgur.com/J1MqOJM.png" alt=""></p><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h4 id="3-1-5-总结"><a href="#3-1-5-总结" class="headerlink" title="3.1.5.总结"></a>3.1.5.总结</h4><p>除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><p><img src="https://i.imgur.com/kZP40dQ.png" alt=""></p><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h3 id="3-2-认识Redis"><a href="#3-2-认识Redis" class="headerlink" title="3.2.认识Redis"></a>3.2.认识Redis</h3><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存.IO多路复用.良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群.分片集群</li><li>支持多语言客户端</li></ul><p><strong>作者</strong>：Antirez</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h3 id="3-3-安装Redis"><a href="#3-3-安装Redis" class="headerlink" title="3.3.安装Redis"></a>3.3.安装Redis</h3><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><h4 id="3-3-1-依赖库"><a href="#3-3-1-依赖库" class="headerlink" title="3.3.1.依赖库"></a>3.3.1.依赖库</h4><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><h4 id="3-3-2-上传安装包并解压"><a href="#3-3-2-上传安装包并解压" class="headerlink" title="3.3.2.上传安装包并解压"></a>3.3.2.上传安装包并解压</h4><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p><img src="https://i.imgur.com/SyjanS5.png" alt=""></p><p>例如，我放到了/usr/local/src 目录：</p><p><img src="https://i.imgur.com/01DTNCf.png" alt=""></p><p>解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><p>解压后：</p><p><img src="https://i.imgur.com/8V6zvCD.png" alt="image-20211211080339076"></p><p>进入redis目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure><p>运行编译命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p><img src="https://i.imgur.com/YSxkGm7.png" alt=""></p><p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h4 id="3-3-3-启动"><a href="#3-3-3-启动" class="headerlink" title="3.3.3.启动"></a>3.3.3.启动</h4><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h4 id="3-3-4-默认启动"><a href="#3-3-4-默认启动" class="headerlink" title="3.3.4.默认启动"></a>3.3.4.默认启动</h4><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">server</span></span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://i.imgur.com/v7xWsqC.png" alt=""></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h4 id="3-3-5-指定配置启动"><a href="#3-3-5-指定配置启动" class="headerlink" title="3.3.5.指定配置启动"></a>3.3.5.指定配置启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="https://zhangweiluo.dpdns.org/img/image-20211211082225509.png" alt="image-20211211082225509"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span> redis.<span class="keyword">conf</span> redis.<span class="keyword">conf</span>.bck</span><br></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志.持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure><h4 id="3-3-6-开机自启"><a href="#3-3-6-开机自启" class="headerlink" title="3.3.6.开机自启"></a>3.3.6.开机自启</h4><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h3 id="3-4-Redis桌面客户端"><a href="#3-4-Redis桌面客户端" class="headerlink" title="3.4.Redis桌面客户端"></a>3.4.Redis桌面客户端</h3><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h4 id="3-4-1-Redis命令行客户端"><a href="#3-4-1-Redis命令行客户端" class="headerlink" title="3.4.1.Redis命令行客户端"></a>3.4.1.Redis命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码 </li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><p><img src="https://i.imgur.com/OYYWPNo.png" alt=""></p><h4 id="3-4-2-图形化桌面客户端"><a href="#3-4-2-图形化桌面客户端" class="headerlink" title="3.4.2.图形化桌面客户端"></a>3.4.2.图形化桌面客户端</h4><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><h4 id="3-4-3-安装"><a href="#3-4-3-安装" class="headerlink" title="3.4.3.安装"></a>3.4.3.安装</h4><p>在课前资料中可以找到Redis的图形化桌面客户端：</p><p><img src="https://i.imgur.com/BZ4Agbi.png" alt=""></p><p>解压缩后，运行安装程序即可安装：</p><p><img src="https://i.imgur.com/hguGHbX.png" alt=""></p><p>安装完成后，在安装目录下找到rdm.exe文件：</p><p><img src="https://i.imgur.com/hwK5LQ8.png" alt=""></p><p>双击即可运行：</p><p><img src="https://i.imgur.com/6hUqslY.png" alt=""></p><h4 id="3-4-4-建立连接"><a href="#3-4-4-建立连接" class="headerlink" title="3.4.4.建立连接"></a>3.4.4.建立连接</h4><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p><p><img src="https://i.imgur.com/9qTGyoN.png" alt=""></p><p>在弹出的窗口中填写Redis服务信息：</p><p><img src="https://i.imgur.com/DshNnKC.png" alt=""></p><p>点击确定后，在左侧菜单会出现这个链接：</p><p><img src="https://i.imgur.com/A2cOm7Q.png" alt=""></p><p>点击即可建立连接了。</p><p><img src="https://i.imgur.com/ja8Fd9s.png" alt=""></p><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line"><span class="keyword">select</span> 0</span><br></pre></td></tr></table></figure><h2 id="4-Redis常见命令"><a href="#4-Redis常见命令" class="headerlink" title="4.Redis常见命令"></a>4.Redis常见命令</h2><h3 id="4-1-Redis数据结构介绍"><a href="#4-1-Redis数据结构介绍" class="headerlink" title="4.1 Redis数据结构介绍"></a>4.1 Redis数据结构介绍</h3><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p><p><img src="https://zhangweiluo.dpdns.org/img/1652887393157.png" alt="1652887393157"></p><p><strong>贴心小建议：命令不要死记，学会查询就好啦</strong></p><p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands</a> ）可以查看到不同的命令：</p><p><img src="https://zhangweiluo.dpdns.org/img/1652887648826.png" alt="1652887648826"></p><p>当然我们也可以通过Help命令来帮助我们去查看命令</p><p><img src="https://zhangweiluo.dpdns.org/img/1652887748279.png" alt="1652887748279"></p><h3 id="4-2-Redis-通用命令"><a href="#4-2-Redis-通用命令" class="headerlink" title="4.2 Redis 通用命令"></a>4.2 Redis 通用命令</h3><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><p><img src="https://zhangweiluo.dpdns.org/img/1652887865189.png" alt="1652887865189"></p><p>课堂代码如下</p><ul><li>KEYS</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询以a开头的key</span></span><br><span class="line">127.0.0.1:6379&gt; keys a*</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>贴心小提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高</strong></p><ul><li>DEL</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> del</span><br><span class="line"></span><br><span class="line">  DEL key [key ...]</span><br><span class="line">  summary: Delete a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del name <span class="comment">#删除单个</span></span><br><span class="line">(<span class="built_in">integer</span>) 1  <span class="comment">#成功删除1个</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 <span class="comment">#批量添加数据</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">4) <span class="string">&quot;age&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del k1 k2 k3 k4</span><br><span class="line">(<span class="built_in">integer</span>) 3   <span class="comment">#此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment">#再查询全部的key</span></span><br><span class="line">1) <span class="string">&quot;age&quot;</span><span class="comment">#只剩下一个了</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>贴心小提示：同学们在拷贝代码的时候，只需要拷贝对应的命令哦~</strong></p><ul><li>EXISTS</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> EXISTS</span><br><span class="line"></span><br><span class="line">  EXISTS key [key ...]</span><br><span class="line">  summary: Determine <span class="keyword">if</span> a key exists</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><ul><li>EXPIRE</li></ul><p><strong>贴心小提示</strong>：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire age 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2  <span class="comment">#当这个key过期了，那么此时查询出来就是-2 </span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 10 <span class="comment">#如果没有设置过期时间</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -1  <span class="comment"># ttl的返回值就是-1</span></span><br></pre></td></tr></table></figure><h3 id="4-3-Redis命令-String命令"><a href="#4-3-Redis命令-String命令" class="headerlink" title="4.3 Redis命令-String命令"></a>4.3 Redis命令-String命令</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><p><img src="https://zhangweiluo.dpdns.org/img/1652890121291.png" alt="1652890121291"></p><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><p><strong>贴心小提示</strong>：以上命令除了INCRBYFLOAT 都是常用命令</p><ul><li>SET 和GET: 如果key不存在则是新增，如果存在则是修改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Rose  <span class="comment">//原来不存在</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name </span><br><span class="line"><span class="string">&quot;Rose&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack <span class="comment">//原来存在，就是修改</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br></pre></td></tr></table></figure><ul><li>MSET和MGET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MSET k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MGET name age k1 k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Jack&quot;</span> <span class="comment">//之前存在的name</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;10&quot;</span>   <span class="comment">//之前存在的age</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure><ul><li>INCR和INCRBY和DECY</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incr age <span class="comment">//增加1</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age <span class="comment">//获得age</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span> <span class="comment">//一次增加2</span></span><br><span class="line">(integer) <span class="number">13</span> <span class="comment">//返回目前的age的值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">15</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">1</span> <span class="comment">//也可以增加负数，相当于减</span></span><br><span class="line">(integer) <span class="number">14</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">2</span> <span class="comment">//一次减少2个</span></span><br><span class="line">(integer) <span class="number">12</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR age <span class="comment">//相当于 incr 负数，减少正常用法</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>SETNX</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; help setnx</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only <span class="keyword">if</span> the key does not exist</span><br><span class="line">  since: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack  <span class="comment">//设置名称</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name lisi <span class="comment">//如果key不存在，则添加成功</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name <span class="comment">//由于name已经存在，所以lisi的操作失败</span></span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name2 lisi <span class="comment">//name2 不存在，所以操作成功</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name2 </span><br><span class="line"><span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure><ul><li>SETEX</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex name 10 jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h3 id="4-4-Redis命令-Key的层级结构"><a href="#4-4-Redis命令-Key的层级结构" class="headerlink" title="4.4 Redis命令-Key的层级结构"></a>4.4 Redis命令-Key的层级结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><p><img src="https://zhangweiluo.dpdns.org/img/1652941631682.png" alt="1652941631682"></p><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><div class="table-container"><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table></div><p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据</p><p><img src="https://zhangweiluo.dpdns.org/img/1652941883537.png" alt="1652941883537"></p><h3 id="4-5-Redis命令-Hash命令"><a href="#4-5-Redis命令-Hash命令" class="headerlink" title="4.5 Redis命令-Hash命令"></a>4.5 Redis命令-Hash命令</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="https://zhangweiluo.dpdns.org/img/1652941995945.png" alt="1652941995945"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="https://zhangweiluo.dpdns.org/img/1652942027719.png" alt="1652942027719"></p><p><strong>Hash类型的常见命令</strong></p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><p><strong>贴心小提示</strong>：哈希结构也是我们以后实际开发中常用的命令哟</p><ul><li>HSET和HGET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> name Lucy<span class="comment">//大key是 heima:user:3 小key是name，小value是Lucy</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">21</span><span class="comment">// 如果操作不存在的数据，则是新增</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">17</span> <span class="comment">//如果操作存在的数据，则是修改</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> name </span><br><span class="line"><span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> age</span><br><span class="line"><span class="string">&quot;17&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HMSET和HMGET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name HanMeiMei</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name LiLei age <span class="number">20</span> sex man</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMGET heima:user:<span class="number">4</span> name age sex</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HGETALL</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HKEYS和HVALS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HKEYS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HINCRBY</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">22</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;22&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age -<span class="number">2</span></span><br><span class="line">(integer) <span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>HSETNX</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user4 sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user:<span class="number">3</span> sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;woman&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-6-Redis命令-List命令"><a href="#4-6-Redis命令-List命令" class="headerlink" title="4.6 Redis命令-List命令"></a>4.6 Redis命令-List命令</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p><strong>List的常见命令有：</strong></p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><img src="https://zhangweiluo.dpdns.org/img/1652943604992.png" alt="1652943604992"></p><ul><li>LPUSH和RPUSH</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH users <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPUSH users <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure><ul><li>LPOP和RPOP</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPOP users</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPOP users</span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure><ul><li>LRANGE</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE users <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-7-Redis命令-Set命令"><a href="#4-7-Redis命令-Set命令" class="headerlink" title="4.7 Redis命令-Set命令"></a>4.7 Redis命令-Set命令</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><p><strong>Set类型的常见命令</strong></p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2 … ：求key1与key2的差集</li><li>SUNION key1 key2 ..：求key1和key2的并集</li></ul><p>例如两个集合：s1和s2:</p><p><img src="https://i.imgur.com/ha8x86R.png" alt=""></p><p>求交集：SINTER s1 s2</p><p>求s1与s2的不同：SDIFF s1 s2</p><p><img src="https://i.imgur.com/L9vTv2X.png" alt=""></p><p><strong>具体命令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd s1 a b <span class="title function_">c</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers s1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">b</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">s1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><ul><li>将下列数据用Redis的Set集合来存储：</li><li>张三的好友有：李四.王五.赵六</li><li>李四的好友有：王五.麻子.二狗</li><li>利用Set的命令实现下列功能：</li><li>计算张三的好友有几人</li><li>计算张三和李四有哪些共同好友</li><li>查询哪些人是张三的好友却不是李四的好友</li><li>查询张三和李四的好友总共有哪些人</li><li>判断李四是否是张三的好友</li><li>判断张三是否是李四的好友</li><li>将李四从张三的好友列表中移除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD zs lisi wangwu <span class="title function_">zhaoliu</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD ls wangwu mazi <span class="title function_">ergou</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">zs</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SINTER zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SDIFF zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SUNION zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;mazi&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;ergou&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER ls <span class="title function_">zhangsan</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SREM zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SMEMBERS zs</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-8-Redis命令-SortedSet类型"><a href="#4-8-Redis命令-SortedSet类型" class="headerlink" title="4.8 Redis命令-SortedSet类型"></a>4.8 Redis命令-SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul><h2 id="5-Redis的Java客户端-Jedis"><a href="#5-Redis的Java客户端-Jedis" class="headerlink" title="5.Redis的Java客户端-Jedis"></a>5.Redis的Java客户端-Jedis</h2><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p><img src="https://i.imgur.com/9f68ivq.png" alt=""></p><p>其中Java客户端也包含很多：</p><p><img src="https://zhangweiluo.dpdns.org/img/image-20220609102817435.png" alt="image-20220609102817435"></p><p>标记为❤的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h3 id="5-1-Jedis快速入门"><a href="#5-1-Jedis快速入门" class="headerlink" title="5.1 Jedis快速入门"></a>5.1 Jedis快速入门</h3><p><strong>入门案例详细步骤</strong></p><p>案例分析：</p><p>0）创建工程：</p><p><img src="\Redis.assets\1652959239813.png" alt="1652959239813"></p><p>1）引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">    <span class="comment">// 2.设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入hash数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-Jedis连接池"><a href="#5-2-Jedis连接池" class="headerlink" title="5.2 Jedis连接池"></a>5.2 Jedis连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p><p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。</p><h4 id="5-2-1-创建Jedis的连接池"><a href="#5-2-1-创建Jedis的连接池" class="headerlink" title="5.2.1.创建Jedis的连接池"></a>5.2.1.创建Jedis的连接池</h4><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFacotry</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//配置连接池</span></span><br><span class="line">         <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">         poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">         poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">//创建连接池对象</span></span><br><span class="line">         jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                 <span class="string">&quot;192.168.150.101&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>代码说明：</strong></p><ul><li><p>1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p></li><li><p>2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化</p></li><li><p>3）最后提供返回连接池中连接的方法.</p></li></ul><h4 id="5-2-2-改造原始代码"><a href="#5-2-2-改造原始代码" class="headerlink" title="5.2.2.改造原始代码"></a>5.2.2.改造原始代码</h4><p><strong>代码说明:</strong></p><p>1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。</p><p>，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p><p>2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@BeforeEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//建立连接</span></span><br><span class="line">     <span class="comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span></span><br><span class="line">     jedis = JedisConnectionFacotry.getJedis();</span><br><span class="line">      <span class="comment">//选择库</span></span><br><span class="line">     jedis.select(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">         jedis.close();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="6-Redis的Java客户端-SpringDataRedis"><a href="#6-Redis的Java客户端-SpringDataRedis" class="headerlink" title="6.Redis的Java客户端-SpringDataRedis"></a>6.Redis的Java客户端-SpringDataRedis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="https://zhangweiluo.dpdns.org/img/1652976773295.png" alt="1652976773295"></p><h3 id="6-1-快速入门"><a href="#6-1-快速入门" class="headerlink" title="6.1.快速入门"></a>6.1.快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：</p><h4 id="6-1-1-导入pom坐标"><a href="#6-1-1-导入pom坐标" class="headerlink" title="6.1.1.导入pom坐标"></a>6.1.1.导入pom坐标</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-1-2-配置文件"><a href="#6-1-2-配置文件" class="headerlink" title="6.1.2 .配置文件"></a>6.1.2 .配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span>  <span class="comment">#最大连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>   <span class="comment">#最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>   <span class="comment">#最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure><h4 id="6-1-3-测试代码"><a href="#6-1-3-测试代码" class="headerlink" title="6.1.3.测试代码"></a>6.1.3.测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>贴心小提示：SpringDataJpa使用起来非常简单，记住如下几个步骤即可</strong></p><p>SpringDataRedis的使用步骤：</p><ul><li>引入spring-boot-starter-data-redis依赖</li><li>在application.yml配置Redis信息</li><li>注入RedisTemplate</li></ul><h3 id="6-2-数据序列化器"><a href="#6-2-数据序列化器" class="headerlink" title="6.2 .数据序列化器"></a>6.2 .数据序列化器</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="https://i.imgur.com/OEMcbuu.png" alt=""></p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><p><img src="https://i.imgur.com/5FjtWk5.png" alt=""></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="https://i.imgur.com/XOAq3cN.png" alt=""></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><h3 id="6-3-StringRedisTemplate"><a href="#6-3-StringRedisTemplate" class="headerlink" title="6.3 StringRedisTemplate"></a>6.3 StringRedisTemplate</h3><p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：</p><p><img src="https://zhangweiluo.dpdns.org/img/1653054602930.png" alt="1653054602930"></p><p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><p>为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间</p><p><img src="https://zhangweiluo.dpdns.org/img/1653054744832.png" alt="1653054744832"></p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><p><img src="https://i.imgur.com/zXH6Qn6.png" alt=""></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;verify:phone:13600527634&quot;</span>, <span class="string">&quot;124143&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再来看一看存储的数据，小伙伴们就会发现那个class数据已经不在了，节约了我们的空间~</p><p><img src="https://zhangweiluo.dpdns.org/img/1653054945211.png" alt="1653054945211"></p><p>最后小总结：</p><p>RedisTemplate的两种序列化实践方案：</p><ul><li><p>方案一：</p><ul><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ul></li><li><p>方案二：</p><ul><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ul></li></ul><h3 id="6-4-Hash结构操作"><a href="#6-4-Hash结构操作" class="headerlink" title="6.4 Hash结构操作"></a>6.4 Hash结构操作</h3><p>在基础篇的最后，咱们对Hash结构操作一下，收一个小尾巴，这个代码咱们就不再解释啦</p><p>马上就开始新的篇章~~~进入到我们的Redis实战篇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;entries = &quot;</span> + entries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础篇Redis&quot;&gt;&lt;a href=&quot;#基础篇Redis&quot; class=&quot;headerlink&quot; title=&quot;基础篇Redis&quot;&gt;&lt;/a&gt;基础篇Redis&lt;/h1&gt;&lt;h2 id=&quot;开篇导读&quot;&gt;&lt;a href=&quot;#开篇导读&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="数据库" scheme="https://amirokd.dpdns.org/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://amirokd.dpdns.org/tags/Redis/"/>
    
    <category term="基础篇" scheme="https://amirokd.dpdns.org/tags/%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>【AmiroKDの算法日记】102-二叉树的层序遍历</title>
    <link href="https://amirokd.dpdns.org/posts/ac7d6339.html"/>
    <id>https://amirokd.dpdns.org/posts/ac7d6339.html</id>
    <published>2025-02-14T06:48:46.000Z</published>
    <updated>2025-02-14T09:42:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h1><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt=""></p><p><strong>输入：</strong>root = [3,9,20,null,null,15,7]<br><strong>输出：</strong>[[3],[9,20],[15,7]]</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>root = [1]<br><strong>输出：</strong>[[1]]</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>root = []<br><strong>输出：</strong>[]</p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h3><h4 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h4><p><strong>思路和算法</strong></p><p>我们可以用广度优先搜索解决这个问题。</p><p>我们可以想到最朴素的方法是用一个二元组 <code>(node, level)</code> 来表示状态，它表示某个节点和它所在的层数，每个新进队列的节点的 <code>level</code> 值都是父亲节点的 <code>level</code> 值加一。最后根据每个点的 <code>level</code> 对点进行分类，分类的时候我们可以利用哈希表，维护一个以 <code>level</code> 为键，对应节点值组成的数组为值，广度优先搜索结束以后按键 <code>level</code> 从小到大取出所有值，组成答案返回即可。</p><p>考虑如何优化空间开销：如何不用哈希映射，并且只用一个变量 <code>node</code> 表示状态，实现这个功能呢？</p><p>我们可以用一种巧妙的方法修改广度优先搜索：</p><ul><li>首先根元素入队</li><li>当队列不为空的时候<ul><li>求当前队列的长度 si​</li><li>依次从队列中取 si​ 个元素进行拓展，然后进入下一次迭代</li></ul></li></ul><p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 si​ 个元素。在上述过程中的第 i 次迭代就得到了二叉树的第 i 层的 si​ 个元素。</p><p>为什么这么做是对的呢？我们观察这个算法，可以归纳出这样的<a href="https://leetcode.cn/link/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F">循环不变式</a>：第 i 次迭代前，队列中的所有元素就是第 i 层的所有元素，并且按照从左向右的顺序排列。证明它的三条性质（你也可以把它理解成数学归纳法）：</p><ul><li><strong>初始化</strong>：i\=1 的时候，队列里面只有 <code>root</code>，是唯一的层数为 1 的元素，因为只有一个元素，所以也显然满足「从左向右排列」；</li><li><strong>保持</strong>：如果 i\=k 时性质成立，即第 k 轮中出队 sk​ 的元素是第 k 层的所有元素，并且顺序从左到右。因为对树进行广度优先搜索的时候由低 k 层的点拓展出的点一定也只能是 k+1 层的点，并且 k+1 层的点只能由第 k 层的点拓展到，所以由这 sk​ 个点能拓展到下一层所有的 sk+1​ 个点。又因为队列的先进先出（FIFO）特性，既然第 k 层的点的出队顺序是从左向右，那么第 k+1 层也一定是从左向右。<strong>至此，我们已经可以通过数学归纳法证明循环不变式的正确性。</strong></li><li><strong>终止</strong>：因为该循环不变式是正确的，所以按照这个方法迭代之后每次迭代得到的也就是当前层的层次遍历结果。<strong>至此，我们证明了算法是正确的。</strong></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 用于存储最终的层序遍历结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 root 为空，直接返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个队列，用于进行 BFS 遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);  <span class="comment">// 将根节点入队</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始层序遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();  <span class="comment">// 存储当前层的节点值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentLevelSize</span> <span class="operator">=</span> queue.size();  <span class="comment">// 当前层的节点数量</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前层的所有节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();  <span class="comment">// 取出队列头部的节点</span></span><br><span class="line">                level.add(node.val);  <span class="comment">// 记录当前节点的值</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该节点的左子节点存在，则加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果该节点的右子节点存在，则加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把当前层的结果加入最终返回结果中</span></span><br><span class="line">            ret.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>记树上所有节点的个数为 n。</p><ul><li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li><li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#102-二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;102. 二叉树的层序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/binary-tree</summary>
      
    
    
    
    <category term="算法" scheme="https://amirokd.dpdns.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode 热题 100" scheme="https://amirokd.dpdns.org/tags/LeetCode-%E7%83%AD%E9%A2%98-100/"/>
    
    <category term="二叉树" scheme="https://amirokd.dpdns.org/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【AmiroKDの算法日记】24-两两交换链表中的节点</title>
    <link href="https://amirokd.dpdns.org/posts/49fbc8df.html"/>
    <id>https://amirokd.dpdns.org/posts/49fbc8df.html</id>
    <published>2025-02-05T08:48:27.000Z</published>
    <updated>2025-02-05T09:26:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h1><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt=""></p><p><strong>输入：</strong>head = [1,2,3,4]<br><strong>输出：</strong>[2,1,4,3]</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>head = []<br><strong>输出：</strong>[]</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>head = [1]<br><strong>输出：</strong>[1]</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p><strong>思路与算法</strong></p><p>可以通过递归的方式实现两两交换链表中的节点。</p><p>递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。</p><p>如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。</p><p>用 <code>head</code> 表示原始链表的头节点，新的链表的第二个节点，用 <code>newHead</code> 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 <code>newHead.next</code>。令 <code>head.next = swapPairs(newHead.next)</code>，表示将其余节点进行两两交换，交换后的新的头节点为 <code>head</code> 的下一个节点。然后令 <code>newHead.next = head</code>，即完成了所有节点的交换。最后返回新的链表的头节点 <code>newHead</code>。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> head.next; <span class="comment">// 取出第二个节点</span></span><br><span class="line">        head.next = swapPairs(newHead.next); <span class="comment">// 递归处理剩下的链表，并将当前第一个节点连接到交换后的后续部分</span></span><br><span class="line">        newHead.next = head; <span class="comment">// 让第二个节点指向第一个节点，完成交换</span></span><br><span class="line">        <span class="keyword">return</span> newHead; <span class="comment">// 返回交换后的新头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。</p></li><li><p>空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。</p></li></ul><h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p><strong>思路与算法</strong></p><p>也可以通过迭代的方式实现两两交换链表中的节点。</p><p>创建哑结点 <code>dummyHead</code>，令 <code>dummyHead.next = head</code>。令 <code>temp</code> 表示当前到达的节点，初始时 <code>temp = dummyHead</code>。每次需要交换 <code>temp</code> 后面的两个节点。</p><p>如果 <code>temp</code> 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。否则，获得 <code>temp</code> 后面的两个节点 <code>node1</code> 和 <code>node2</code>，通过更新节点的指针关系实现两两交换节点。</p><p>具体而言，交换之前的节点关系是 <code>temp -&gt; node1 -&gt; node2</code>，交换之后的节点关系要变成 <code>temp -&gt; node2 -&gt; node1</code>，因此需要进行如下操作。</p><pre><code>temp.next = node2node1.next = node2.nextnode2.next = node1</code></pre><p>完成上述操作之后，节点关系即变成 <code>temp -&gt; node2 -&gt; node1</code>。再令 <code>temp = node1</code>，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。</p><p>两两交换链表中的节点之后，新的链表的头节点是 <code>dummyHead.next</code>，返回新的链表的头节点即可。</p><p><img src="https://assets.leetcode-cn.com/solution-static/24/1.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/2.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/3.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/4.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/5.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/6.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/7.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/8.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/9.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/10.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/11.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/12.png" alt=""><img src="https://assets.leetcode-cn.com/solution-static/24/13.png" alt=""></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">        dummyHead.next = head; <span class="comment">// 让 dummyHead 指向 head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummyHead; <span class="comment">// temp 作为遍历指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="literal">null</span> &amp;&amp; temp.next.next != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> temp.next;       <span class="comment">// 指向当前的第一个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> temp.next.next;  <span class="comment">// 指向当前的第二个节点</span></span><br><span class="line"></span><br><span class="line">            temp.next = node2;   <span class="comment">// 让前驱节点 temp 指向 node2（第二个节点）</span></span><br><span class="line">            node1.next = node2.next;  <span class="comment">// 让 node1（第一个节点）指向 node2 之后的节点</span></span><br><span class="line">            node2.next = node1;  <span class="comment">// 让 node2（第二个节点）指向 node1，完成交换</span></span><br><span class="line"></span><br><span class="line">            temp = node1;  <span class="comment">// 让 temp 移动到 node1，准备处理下一对</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next; <span class="comment">// 返回真正的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。</p></li><li><p>空间复杂度：O(1)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;24-两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#24-两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;24. 两两交换链表中的节点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/swap-nod</summary>
      
    
    
    
    <category term="算法" scheme="https://amirokd.dpdns.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode 热题 100" scheme="https://amirokd.dpdns.org/tags/LeetCode-%E7%83%AD%E9%A2%98-100/"/>
    
    <category term="链表" scheme="https://amirokd.dpdns.org/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【AmiroKDの算法日记】19-删除链表的倒数第 N 个结点</title>
    <link href="https://amirokd.dpdns.org/posts/ba18dbcc.html"/>
    <id>https://amirokd.dpdns.org/posts/ba18dbcc.html</id>
    <published>2025-02-04T12:26:26.000Z</published>
    <updated>2025-05-07T14:03:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1,2,3,5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><h4 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> len - n;</span><br><span class="line">        list.remove(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新连接节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            list.get(i).next = list.get(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        list.get(list.size() - <span class="number">1</span>).next = <span class="literal">null</span>; <span class="comment">// 确保最后一个节点的next为null</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的 next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。</p><p>例如，在本题中，如果我们要删除节点 y，我们需要知道节点 y 的前驱节点 x，并将 x 的指针指向 y 的后继节点。但由于头节点不存在前驱节点，因此我们需要在删除头节点时进行特殊判断。但如果我们添加了哑节点，那么头节点的前驱节点就是哑节点本身，此时我们就只需要考虑通用的情况即可。</p><p>特别地，在某些语言中，由于需要自行对内存进行管理。因此在实际的面试中，对于「是否需要释放被删除节点对应的空间」这一问题，我们需要和面试官进行积极的沟通以达成一致。下面的代码中默认不释放空间。</p><h4 id="方法一：计算链表长度"><a href="#方法一：计算链表长度" class="headerlink" title="方法一：计算链表长度"></a>方法一：计算链表长度</h4><p><strong>思路与算法</strong></p><p>一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 L。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L−n+1 个节点时，它就是我们需要删除的节点。</p><blockquote><p>为了与题目中的 n 保持一致，节点的编号从 1 开始，头节点为编号 1 的节点。</p></blockquote><p>为了方便删除操作，我们可以从哑节点开始遍历 L−n+1 个节点。当遍历到第 L−n+1 个节点时，<strong>它的下一个节点</strong>就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。</p><p><img src="https://zhangweiluo.dpdns.org/img/p1.png" alt="p1"></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(L)，其中 L 是链表的长度。</p></li><li><p>空间复杂度：O(1)。</p></li></ul><h4 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h4><p><strong>思路与算法</strong></p><p>我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        prev.next = prev.next.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(L)，其中 L 是链表的长度。</p></li><li><p>空间复杂度：O(L)，其中 L 是链表的长度。主要为栈的开销。</p></li></ul><h4 id="方法三：双指针"><a href="#方法三：双指针" class="headerlink" title="方法三：双指针"></a>方法三：双指针</h4><p><strong>思路与算法</strong></p><p>我们也可以在不预处理出链表的长度，以及使用常数空间的前提下解决本题。</p><p>由于我们需要找到倒数第 n 个节点，因此我们可以使用两个指针 first 和 second 同时对链表进行遍历，并且 first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点。</p><p>具体地，初始时 first 和 second 均指向头节点。我们首先使用 first 对链表进行遍历，遍历的次数为 n。此时，first 和 second 之间间隔了 n−1 个节点，即 first 比 second 超前了 n 个节点。</p><p>在这之后，我们同时使用 first 和 second 对链表进行遍历。当 first 遍历到链表的末尾（即 first 为空指针）时，second 恰好指向倒数第 n 个节点。</p><p>根据方法一和方法二，如果我们能够得到的是倒数第 n 个节点的前驱节点而不是倒数第 n 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 second 指向哑节点，其余的操作步骤不变。这样一来，当 first 遍历到链表的末尾时，second 的<strong>下一个节点</strong>就是我们需要删除的节点。</p><p><img src="https://zhangweiluo.dpdns.org/img/p3.png" alt="p3"></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(L)，其中 L 是链表的长度。</p></li><li><p>空间复杂度：O(1)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;19-删除链表的倒数第-N-个结点&quot;&gt;&lt;a href=&quot;#19-删除链表的倒数第-N-个结点&quot; class=&quot;headerlink&quot; title=&quot;19. 删除链表的倒数第 N 个结点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/probl</summary>
      
    
    
    
    <category term="算法" scheme="https://amirokd.dpdns.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode 热题 100" scheme="https://amirokd.dpdns.org/tags/LeetCode-%E7%83%AD%E9%A2%98-100/"/>
    
    <category term="链表" scheme="https://amirokd.dpdns.org/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【AmiroKDの算法日记】21-合并两个有序链表</title>
    <link href="https://amirokd.dpdns.org/posts/95494616.html"/>
    <id>https://amirokd.dpdns.org/posts/95494616.html</id>
    <published>2025-02-04T12:08:35.000Z</published>
    <updated>2025-02-04T12:09:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[1,2,4]</span>, l2 = <span class="comment">[1,3,4]</span></span><br><span class="line">输出：<span class="comment">[1,1,2,3,4,4]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[]</span>, l2 = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h3 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p><strong>思路</strong></p><p>我们可以如下递归地定义两个链表里的 <code>merge</code> 操作（忽略边界情况，比如空链表等）：</p><p>{list1[0]+merge(list1[1:],list2)list2[0]+merge(list1,list2[1:])list1[0]&lt;list2[0]otherwise</p><p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并。</p><p><strong>算法</strong></p><p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p><p>如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;   <span class="comment">//结尾</span></span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;    <span class="comment">//结尾</span></span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);   <span class="comment">//往下遍历小的那个</span></span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 <code>l1</code> 或者 <code>l2</code> 的头节点（直到至少有一个链表为空），函数 <code>mergeTwoList</code> 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。</p></li><li><p>空间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。递归调用 <code>mergeTwoLists</code> 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 <code>mergeTwoLists</code> 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)。</p></li></ul><h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p><strong>思路</strong></p><p>我们可以用迭代的方法来实现上述算法。当 <code>l1</code> 和 <code>l2</code> 都不是空链表时，判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p><p><strong>算法</strong></p><p>首先，我们设定一个哨兵节点 <code>prehead</code> ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 <code>prev</code> 指针，我们需要做的是调整它的 <code>next</code> 指针。然后，我们重复以下过程，直到 <code>l1</code> 或者 <code>l2</code> 指向了 <code>null</code> ：如果 <code>l1</code> 当前节点的值小于等于 <code>l2</code> ，我们就把 <code>l1</code> 当前的节点接在 <code>prev</code> 节点的后面同时将 <code>l1</code> 指针往后移一位。否则，我们对 <code>l2</code> 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 <code>prev</code> 向后移一位。</p><p>在循环终止的时候， <code>l1</code> 和 <code>l2</code> 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p><p>下图展示了 <code>1-&gt;4-&gt;5</code> 和 <code>1-&gt;2-&gt;3-&gt;6</code> 两个链表迭代合并的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prehead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> prehead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，<code>l1</code> 和 <code>l2</code> 只有一个元素会被放进合并链表中， 因此 <code>while</code> 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。</p></li><li><p>空间复杂度：O(1)。我们只需要常数的空间存放若干变量。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;21-合并两个有序链表&quot;&gt;&lt;a href=&quot;#21-合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21. 合并两个有序链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-two-sort</summary>
      
    
    
    
    <category term="算法" scheme="https://amirokd.dpdns.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode 热题 100" scheme="https://amirokd.dpdns.org/tags/LeetCode-%E7%83%AD%E9%A2%98-100/"/>
    
    <category term="链表" scheme="https://amirokd.dpdns.org/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【AmiroKDの算法日记】2-两数相加</title>
    <link href="https://amirokd.dpdns.org/posts/b4dcde1a.html"/>
    <id>https://amirokd.dpdns.org/posts/b4dcde1a.html</id>
    <published>2025-02-04T12:05:06.000Z</published>
    <updated>2025-05-07T14:03:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h1><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://zhangweiluo.dpdns.org/img/addtwonumber1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[2,4,3]</span>, l2 = <span class="comment">[5,6,4]</span></span><br><span class="line">输出：<span class="comment">[7,0,8]</span></span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[0]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">9,9,9,9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], l2 = [<span class="number">9,9,9,9</span>]</span><br><span class="line">输出：[<span class="number">8,9,9,9</span>,<span class="number">0,0,0,1</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h3 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h3><h4 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h4><p><strong>思路与算法</strong></p><p>由于输入的两个链表都是<strong>逆序</strong>存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。</p><p>我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 n1,n2，进位值为 carry，则它们的和为 n1+n2+carry；其中，答案链表处相应位置的数字为 (n1+n2+carry)mod10，而新的进位值为 <img src="https://zhangweiluo.dpdns.org/img/image-20250204200350639.png" alt="image-20250204200350639">。</p><p>如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 。</p><p>此外，如果链表遍历结束后，有 carry>0，还需要在答案链表的后面附加一个节点，节点的值为 carry。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>, tail = <span class="literal">null</span>; <span class="comment">// 初始化结果链表的头和尾指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 初始化进位值为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历两个链表，直到两个链表都为空</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的值，如果节点为空，则值为0</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算当前位的和，包括进位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> n1 + n2 + carry;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建新节点，并将其添加到结果链表</span></span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果结果链表为空，创建头节点和尾节点</span></span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果结果链表不为空，将新节点添加到尾部</span></span><br><span class="line">                tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新进位值</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动到下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最后有进位，则添加一个新节点</span></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(max(m,n))，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。</p></li><li><p>空间复杂度：O(1)。注意返回值不计入空间复杂度。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-两数相加&quot;&gt;&lt;a href=&quot;#2-两数相加&quot; class=&quot;headerlink&quot; title=&quot;2. 两数相加&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/add-two-numbers/&quot;&gt;2. 两数相加&lt;/a&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://amirokd.dpdns.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode 热题 100" scheme="https://amirokd.dpdns.org/tags/LeetCode-%E7%83%AD%E9%A2%98-100/"/>
    
    <category term="链表" scheme="https://amirokd.dpdns.org/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【AmiroKDの算法日记】141-环形链表</title>
    <link href="https://amirokd.dpdns.org/posts/6eac35ce.html"/>
    <id>https://amirokd.dpdns.org/posts/6eac35ce.html</id>
    <published>2025-02-02T14:48:31.000Z</published>
    <updated>2025-05-07T14:03:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://zhangweiluo.dpdns.org/img/circularlinkedlist.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [3,2,0,-4], pos = 1</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://zhangweiluo.dpdns.org/img/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2], pos = 0</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://zhangweiluo.dpdns.org/img/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1], pos = -1</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><div class="tip warning"><p><b>注意这里的的pos是测试变量，并不是输入的变量。只是说明最后一个节点的next不为null，而是pos</b></p></div><h3 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a><strong>方法一：哈希表</strong></h3><p><strong>思路及算法</strong></p><p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p><p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!seen.add(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(N)，其中 N 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</p></li><li><p>空间复杂度：O(N)，其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p></li></ul><h3 id="方法二：快慢指针"><a href="#方法二：快慢指针" class="headerlink" title="方法二：快慢指针"></a>方法二：快慢指针</h3><p><strong>思路及算法</strong></p><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 <code>head</code>，而快指针在位置 <code>head.next</code>。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><p><strong>细节</strong></p><p>为什么我们要规定初始时慢指针在位置 <code>head</code>，快指针在位置 <code>head.next</code>，而不是两个指针都在位置 <code>head</code>（即与「乌龟」和「兔子」中的叙述相同）？</p><ul><li><p>观察下面的代码，我们使用的是 <code>while</code> 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 <code>head</code>，那么 <code>while</code> 循环就不会执行。因此，我们可以假想一个在 <code>head</code> 之前的虚拟节点，慢指针从虚拟节点移动一步到达 <code>head</code>，快指针从虚拟节点移动两步到达 <code>head.next</code>，这样我们就可以使用 <code>while</code> 循环了。</p></li><li><p>当然，我们也可以使用 <code>do-while</code> 循环。此时，我们就可以把快慢指针的初始值都置为 <code>head</code>。</p></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 边界条件检查：空链表或单节点无环的情况</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化快慢指针，slow从head开始，fast从head.next开始</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;       <span class="comment">// 慢指针，每次移动1步</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;  <span class="comment">// 快指针，每次移动2步</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只要快慢指针未相遇，就继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="comment">// 如果快指针或其下一个节点为null，说明链表无环</span></span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移动指针：慢指针走1步，快指针走2步</span></span><br><span class="line">            slow = slow.next;        <span class="comment">// 慢指针移动</span></span><br><span class="line">            fast = fast.next.next;   <span class="comment">// 快指针移动（跳两步）</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 退出循环说明快慢指针相遇，链表有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(N)，其中 N 是链表中的节点数。</p><ul><li><p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p></li><li><p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p></li></ul></li><li><p>空间复杂度：O(1)。我们只使用了两个指针的额外空间。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;141-环形链表&quot;&gt;&lt;a href=&quot;#141-环形链表&quot; class=&quot;headerlink&quot; title=&quot;141. 环形链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/linked-list-cycle/&quot;&gt;141</summary>
      
    
    
    
    <category term="算法" scheme="https://amirokd.dpdns.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode 热题 100" scheme="https://amirokd.dpdns.org/tags/LeetCode-%E7%83%AD%E9%A2%98-100/"/>
    
    <category term="链表" scheme="https://amirokd.dpdns.org/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【AmiroKDの算法日记】206-反转链表</title>
    <link href="https://amirokd.dpdns.org/posts/6fb84027.html"/>
    <id>https://amirokd.dpdns.org/posts/6fb84027.html</id>
    <published>2025-01-27T15:45:46.000Z</published>
    <updated>2025-02-01T12:55:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt=""></p><p><strong>输入：</strong>head = [1,2,3,4,5]<br><strong>输出：</strong>[5,4,3,2,1]</p><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt=""></p><p><strong>输入：</strong>head = [1,2]<br><strong>输出：</strong>[2,1]</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>head = []<br><strong>输出：</strong>[]</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h2 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h2><p><code>就是将整个链表的指针反转</code></p><p>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。</p><p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化一个指向前一个节点的指针，开始时为 null</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 当前指针指向链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 遍历整个链表，直到当前节点为 null</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 保存当前节点的下一个节点，以便后续遍历</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            <span class="comment">// 反转当前节点的指向，使其指向前一个节点</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            <span class="comment">// 将 prev 更新为当前节点，为下次遍历准备</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            <span class="comment">// 将 curr 更新为下一个节点，继续遍历</span></span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回反转后的链表头节点，prev 现在指向原链表的最后一个节点</span></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。</p></li><li><p>空间复杂度：O(1)。</p></li></ul><hr><h2 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h2><p>递归版本稍微复杂一些，其关键在于反向工作。假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？</p><p>假设链表为：<br>n1​→…→nk−1​→nk​→nk+1​→…→nm​→∅</p><p>若从节点 nk+1​ 到 nm​ 已经被反转，而我们正处于 nk​。</p><p>n1​→…→nk−1​→nk​→nk+1​←…←nm​</p><p>我们希望 nk+1​ 的下一个节点指向 nk​。</p><p>所以，nk​.next.next\=nk​。</p><p>需要注意的是 n1​ 的下一个节点必须指向 ∅。如果忽略了这一点，链表中可能会产生环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以链表1-&gt;2-&gt;3-&gt;4-&gt;5举例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            直到当前节点的下一个节点为空时返回当前节点</span></span><br><span class="line"><span class="comment">            由于5没有下一个节点了，所以此处返回节点5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归传入下一个节点，目的是为了到达最后一个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">        第一轮出栈，head为5，head.next为空，返回5</span></span><br><span class="line"><span class="comment">        第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，</span></span><br><span class="line"><span class="comment">                  把当前节点的子节点的子节点指向当前节点</span></span><br><span class="line"><span class="comment">                  此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null</span></span><br><span class="line"><span class="comment">                  此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5</span></span><br><span class="line"><span class="comment">                  返回节点5</span></span><br><span class="line"><span class="comment">        第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，</span></span><br><span class="line"><span class="comment">                  此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null</span></span><br><span class="line"><span class="comment">                  此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                  返回节点5</span></span><br><span class="line"><span class="comment">        第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2，</span></span><br><span class="line"><span class="comment">                  此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2.next=null</span></span><br><span class="line"><span class="comment">                  此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                  返回节点5</span></span><br><span class="line"><span class="comment">        第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，</span></span><br><span class="line"><span class="comment">                  此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null</span></span><br><span class="line"><span class="comment">                  此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                  返回节点5</span></span><br><span class="line"><span class="comment">        出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。</p></li><li><p>空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。</p></li></ul><blockquote><p>本题为后端高频面试题，收录于《<a href="https://leetcode.cn/leetbook/detail/2021-fall-recruitment/">热招技术岗上岸指南</a>》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;206-反转链表&quot;&gt;&lt;a href=&quot;#206-反转链表&quot; class=&quot;headerlink&quot; title=&quot;206. 反转链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list/&quot;&gt;2</summary>
      
    
    
    
    <category term="算法" scheme="https://amirokd.dpdns.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode 热题 100" scheme="https://amirokd.dpdns.org/tags/LeetCode-%E7%83%AD%E9%A2%98-100/"/>
    
    <category term="链表" scheme="https://amirokd.dpdns.org/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【AmiroKDの算法日记】240-搜索二维矩阵 II</title>
    <link href="https://amirokd.dpdns.org/posts/beb99d2e.html"/>
    <id>https://amirokd.dpdns.org/posts/beb99d2e.html</id>
    <published>2025-01-26T15:37:46.000Z</published>
    <updated>2025-01-26T16:15:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h1><p>编写一个高效的算法来搜索 <code>_m_ x _n_</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" alt=""></p><p><strong>输入：</strong>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5<br><strong>输出：</strong>true</p><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" alt=""></p><p><strong>输入：</strong>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20<br><strong>输出：</strong>false</p><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= n, m &lt;= 300</code></li><li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li><li>每行的所有元素从左到右升序排列</li><li>每列的所有元素从上到下升序排列</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h4 id="方法一：直接查找"><a href="#方法一：直接查找" class="headerlink" title="方法一：直接查找"></a>方法一：直接查找</h4><p><strong>思路与算法</strong></p><p>我们直接遍历整个矩阵 matrix，判断 target 是否出现即可。<br><code>直接暴力</code></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> element : row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (element == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(mn)。</p></li><li><p>空间复杂度：O(1)。</p></li></ul><h4 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h4><p><strong>思路与算法</strong></p><p>由于矩阵 matrix 中每一行的元素都是升序排列的，因此我们可以对每一行都使用一次二分查找，判断 target 是否在该行中，从而判断 target 是否出现。</p><p><strong>代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : matrix) &#123;  <span class="comment">//使用增强型for循环将row数组进行二分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> search(row, target);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123; <span class="comment">//二分查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = nums.length - <span class="number">1</span>;    <span class="comment">//最大和最小</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (high - low) / <span class="number">2</span> + low;   <span class="comment">//加low是偏移量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[mid];    <span class="comment">//中间值</span></span><br><span class="line">            <span class="keyword">if</span> (num == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(mlogn)。对一行使用二分查找的时间复杂度为 O(logn)，最多需要进行 m 次二分查找。</p></li><li><p>空间复杂度：O(1)。</p></li></ul><h4 id="方法三：Z-字形查找"><a href="#方法三：Z-字形查找" class="headerlink" title="方法三：Z 字形查找"></a>方法三：Z 字形查找</h4><p><strong>思路与算法</strong></p><p>我们可以从矩阵 matrix 的右上角 (0,n−1) 进行搜索。在每一步的搜索过程中，如果我们位于位置 (x,y)，那么我们希望在以 matrix 的左下角为左下角、以 (x,y) 为右上角的矩阵中进行搜索，即行的范围为 [x,m−1]，列的范围为 [0,y]：</p><ul><li><p>如果 matrix[x,y]\=target，说明搜索完成；</p></li><li><p>如果 matrix[x,y]>target，由于每一列的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 y 列的元素都是严格大于 target 的，因此我们可以将它们全部忽略，即将 y 减少 1；</p></li><li><p>如果 matrix[x,y]&lt;target，由于每一行的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 x 行的元素都是严格小于 target 的，因此我们可以将它们全部忽略，即将 x 增加 1。</p></li></ul><p>在搜索的过程中，如果我们超出了矩阵的边界，那么说明矩阵中不存在 target。</p><p><strong>代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取矩阵的行数 m 和列数 n</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 从矩阵的右上角开始搜索</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环条件：当前坐标 (x, y) 必须在矩阵范围内</span></span><br><span class="line">        <span class="keyword">while</span> (x &lt; m &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果找到目标值，返回 true</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前值大于目标值，向左移动一列</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] &gt; target) &#123;</span><br><span class="line">                --y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// 如果当前值小于目标值，向下移动一行</span></span><br><span class="line">                ++x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果遍历结束未找到目标值，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(m+n)。在搜索的过程中，如果我们没有找到 target，那么我们要么将 y 减少 1，要么将 x 增加 1。由于 (x,y) 的初始值分别为 (0,n−1)，因此 y 最多能被减少 n 次，x 最多能被增加 m 次，总搜索次数为 m+n。在这之后，x 和 y 就会超出矩阵的边界。</p></li><li><p>空间复杂度：O(1)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;240-搜索二维矩阵-II&quot;&gt;&lt;a href=&quot;#240-搜索二维矩阵-II&quot; class=&quot;headerlink&quot; title=&quot;240. 搜索二维矩阵 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/search-a</summary>
      
    
    
    
    <category term="算法" scheme="https://amirokd.dpdns.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="矩阵" scheme="https://amirokd.dpdns.org/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="LeetCode 热题 100" scheme="https://amirokd.dpdns.org/tags/LeetCode-%E7%83%AD%E9%A2%98-100/"/>
    
  </entry>
  
  <entry>
    <title>【AmiroKDの算法日记】48-旋转图像</title>
    <link href="https://amirokd.dpdns.org/posts/c2131d9a.html"/>
    <id>https://amirokd.dpdns.org/posts/c2131d9a.html</id>
    <published>2025-01-26T15:07:33.000Z</published>
    <updated>2025-05-07T14:03:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h1><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = <span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[4,5,6]</span>,<span class="comment">[7,8,9]</span>]</span></span><br><span class="line">输出：<span class="comment">[1,2,3,6,9,8,7,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1,2,3,4</span>],[<span class="number">5,6,7,8</span>],[<span class="number">9,10,11,12</span>]]</span><br><span class="line">输出：[<span class="number">1,2,3,4</span>,<span class="number">8,12,11,10</span>,<span class="number">9,5,6,7</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><p><img src="https://zhangweiluo.dpdns.org/img/image-20250126233020378.png" alt="image-20250126233020378" style="zoom:150%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;  <span class="comment">//单行的长</span></span><br><span class="line">        <span class="type">int</span>[][] matrix_new = <span class="keyword">new</span> <span class="title class_">int</span>[n][n]; <span class="comment">//定义一个新的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                matrix_new[j][n - i - <span class="number">1</span>] = matrix[i][j];</span><br><span class="line">                <span class="comment">//对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                matrix[i][j] = matrix_new[i][j];    <span class="comment">//clone数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;48-旋转图像&quot;&gt;&lt;a href=&quot;#48-旋转图像&quot; class=&quot;headerlink&quot; title=&quot;48. 旋转图像&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/rotate-image/&quot;&gt;48. 旋转图像&lt;/a</summary>
      
    
    
    
    <category term="算法" scheme="https://amirokd.dpdns.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="矩阵" scheme="https://amirokd.dpdns.org/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="LeetCode 热题 100" scheme="https://amirokd.dpdns.org/tags/LeetCode-%E7%83%AD%E9%A2%98-100/"/>
    
  </entry>
  
</feed>
